{"ast":null,"code":"/**\r\n * Category axis module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Axis, AxisDataItem } from \"./Axis\";\nimport { AxisRendererX } from \"./AxisRendererX\";\nimport { AxisRendererY } from \"./AxisRendererY\";\nimport { registry } from \"../../core/Registry\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Defines a [[DataItem]] for [[CategoryAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\nvar CategoryAxisDataItem = /** @class */function (_super) {\n  __extends(CategoryAxisDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n  function CategoryAxisDataItem() {\n    var _this = _super.call(this) || this;\n    _this.seriesDataItems = {};\n    _this.className = \"CategoryAxisDataItem\";\n    _this.text = \"{category}\";\n    _this.locations.category = 0;\n    _this.locations.endCategory = 1;\n    _this.deltaPosition = 0;\n    _this.applyTheme();\n    return _this;\n  }\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"category\", {\n    /**\r\n     * @return Category\r\n     */\n    get: function () {\n      if (this._adapterO) {\n        if (this._adapterO.isEnabled(\"category\")) {\n          return this._adapterO.apply(\"category\", this.properties.category);\n        }\n      }\n      return this.properties.category;\n    },\n    /**\r\n     * Category.\r\n     *\r\n     * @param value  Category\r\n     */\n    set: function (value) {\n      var oldCategory = this.properties.category;\n      this.setProperty(\"category\", value);\n      if ($type.hasValue(oldCategory) && oldCategory != value) {\n        if (this.component) {\n          this.component.validateDataElement(this);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"endCategory\", {\n    /**\r\n     * @return End category\r\n     */\n    get: function () {\n      return this.properties.endCategory;\n    },\n    /**\r\n     * End category.\r\n     *\r\n     * Used for items that span several categories, like [[CategoryAxisBreak]].\r\n     *\r\n     * @param value  End category\r\n     */\n    set: function (value) {\n      this.setProperty(\"endCategory\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"deltaPosition\", {\n    get: function () {\n      return this.properties.deltaCoordinate;\n    },\n    set: function (value) {\n      if (value != this.properties.deltaCoordinate) {\n        this.setProperty(\"deltaCoordinate\", value);\n        if (this.component) {\n          this.component.invalidateDataItems();\n          this.component.invalidateSeries();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return CategoryAxisDataItem;\n}(AxisDataItem);\nexport { CategoryAxisDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Used to create a category-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"CategoryAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Clients\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link ICategoryAxisEvents} for a list of available Events\r\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\nvar CategoryAxis = /** @class */function (_super) {\n  __extends(CategoryAxis, _super);\n  /**\r\n   * Constructor\r\n   */\n  function CategoryAxis() {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    /**\r\n     * A collection that holds Axis' data items sorted by each category.\r\n     */\n    _this.dataItemsByCategory = new Dictionary();\n    _this.className = \"CategoryAxis\";\n    // Set field name\n    _this.axisFieldName = \"category\";\n    _this._lastDataItem = _this.createDataItem();\n    _this._lastDataItem.component = _this;\n    _this._disposers.push(_this._lastDataItem);\n    // Apply theme\n    _this.applyTheme();\n    var dataItemsByCategory = _this.dataItemsByCategory;\n    _this.addDisposer(_this.mainDataSet.events.on(\"removed\", function (event) {\n      dataItemsByCategory.removeKey(event.oldValue.category);\n    }));\n    return _this;\n  }\n  /**\r\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n  CategoryAxis.prototype.createDataItem = function () {\n    return new CategoryAxisDataItem();\n  };\n  /**\r\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n   *\r\n   * @return Axis break\r\n   */\n  CategoryAxis.prototype.createAxisBreak = function () {\n    return new CategoryAxisBreak();\n  };\n  /**\r\n   * Processes a related series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  Data item\r\n   */\n  CategoryAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\n    _super.prototype.processSeriesDataItem.call(this, dataItem, axisLetter);\n    var category = dataItem[\"category\" + this.axisLetter];\n    if ($type.hasValue(category)) {\n      var categoryAxisDataItem = this.dataItemsByCategory.getKey(category);\n      if (categoryAxisDataItem) {\n        var seriesId = dataItem.component.uid;\n        var seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\n        if (!seriesDataItems) {\n          seriesDataItems = [];\n          categoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\n        }\n        seriesDataItems.push(dataItem);\n      }\n    } else {\n      dataItem.component.dataItems.remove(dataItem);\n    }\n  };\n  /**\r\n   * Validates the data range.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n  CategoryAxis.prototype.validateDataRange = function () {\n    var _this = this;\n    _super.prototype.validateDataRange.call(this);\n    $iter.each(this._series.iterator(), function (series) {\n      if (series.xAxis instanceof CategoryAxis && series.yAxis instanceof CategoryAxis) {\n        series.invalidateDataRange();\n      } else {\n        var startIndex = _this.positionToIndex(_this.start);\n        var endIndex = _this.positionToIndex(_this.end);\n        if (endIndex >= _this.dataItems.length) {\n          endIndex--;\n        }\n        var seriesId = series.uid;\n        var minIndex = void 0;\n        var maxIndex = void 0;\n        for (var i = startIndex; i <= endIndex; i++) {\n          var axisDataItem = _this.dataItems.getIndex(i);\n          if (axisDataItem) {\n            var seriesDataItems = axisDataItem.seriesDataItems[seriesId];\n            if (seriesDataItems) {\n              for (var i_1 = 0; i_1 < seriesDataItems.length; i_1++) {\n                var seriesDataItem = seriesDataItems[i_1];\n                if (seriesDataItem) {\n                  var index = seriesDataItem.index;\n                  if (!$type.isNumber(minIndex) || index < minIndex) {\n                    minIndex = index;\n                  }\n                  if (!$type.isNumber(maxIndex) || index > maxIndex) {\n                    maxIndex = index;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if ($type.isNumber(minIndex)) {\n          series.startIndex = minIndex;\n        } else {\n          series.start = _this.start;\n        }\n        if ($type.isNumber(maxIndex)) {\n          series.endIndex = maxIndex + 1;\n        } else {\n          series.end = _this.end;\n        }\n        // range might not change, but axis breaks might.\n        if (_this._axisBreaks && _this._axisBreaks.length > 0) {\n          series.invalidateDataRange();\n        }\n      }\n    });\n  };\n  /**\r\n   * Validates the whole axis. Causes it to redraw.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n  CategoryAxis.prototype.validate = function () {\n    var _this = this;\n    _super.prototype.validate.call(this);\n    var dataCount = this.dataItems.length;\n    var startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\n    var endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\n    if (this.renderer.invalid) {\n      this.renderer.validate();\n    }\n    // find frequency at which we'll show items\n    var maxCount = this.renderer.axisLength / Math.max(this.renderer.minGridDistance, 1 / Number.MAX_SAFE_INTEGER);\n    var frequency = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\n    this._startIndex = Math.floor(startIndex / frequency) * frequency;\n    this._endIndex = Math.ceil(this.end * dataCount);\n    this.fixAxisBreaks();\n    if (this._startIndex == this._endIndex) {\n      this._endIndex++;\n    }\n    this._frequency = frequency;\n    if (this.axisLength <= 0) {\n      return;\n    }\n    this.maxZoomFactor = this.dataItems.length;\n    if (this.dataItems.length <= 0) {\n      this.maxZoomFactor = 1;\n    }\n    this.resetIterators();\n    // it's important to use protected variables here, as getters will return 0 - length\n    // TODO use iterator instead\n    // @ todo: not solved cat axis item fading\n    startIndex = $math.max(0, this._startIndex - this._frequency);\n    endIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\n    var itemIndex = 0;\n    for (var i = 0; i < startIndex; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n    for (var i = endIndex, len = this.dataItems.length; i < len; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n    for (var i = startIndex; i < endIndex; i++) {\n      if (i < this.dataItems.length) {\n        var dataItem = this.dataItems.getIndex(i);\n        if (i / this._frequency == Math.round(i / this._frequency)) {\n          var axisBreak = this.isInBreak(i);\n          if (!axisBreak) {\n            this.appendDataItem(dataItem);\n            this.validateDataElement(dataItem, itemIndex);\n          }\n          itemIndex++;\n        } else {\n          //previously we disabled all before, but this is better for cpu\n          //this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\n          dataItem.__disabled = true;\n        }\n      }\n    }\n    this.appendDataItem(this._lastDataItem);\n    this.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      axisBreaks.each(function (axisBreak) {\n        var adjustedStartValue = axisBreak.adjustedStartValue;\n        var adjustedEndValue = axisBreak.adjustedEndValue;\n        if ($math.intersect({\n          start: adjustedStartValue,\n          end: adjustedEndValue\n        }, {\n          start: _this._startIndex,\n          end: _this._endIndex\n        })) {\n          for (var b = adjustedStartValue; b <= adjustedEndValue; b++) {\n            var dataItem = _this.dataItems.getIndex(b);\n            dataItem.__disabled = true;\n          }\n          var frequency_1 = $math.fitToRange(Math.ceil(_this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\n          var itemIndex_1 = 0;\n          if (axisBreak.breakSize > 0) {\n            // TODO use iterator instead\n            for (var b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency_1) {\n              var dataItem = _this.dataItems.getIndex(b);\n              dataItem.__disabled = false;\n              _this.appendDataItem(dataItem);\n              _this.validateDataElement(dataItem, itemIndex_1);\n              itemIndex_1++;\n            }\n          }\n        }\n      });\n    }\n    this.validateBreaks();\n    this.validateAxisRanges();\n    this.ghostLabel.invalidate(); // solves font issue\n    this.renderer.invalidateLayout();\n  };\n  /**\r\n   * [validateDataElement description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem   [description]\r\n   * @param itemIndex  [description]\r\n   */\n  CategoryAxis.prototype.validateDataElement = function (dataItem, itemIndex, index) {\n    _super.prototype.validateDataElement.call(this, dataItem);\n    dataItem.itemIndex = this._axisItemCount;\n    this._axisItemCount++;\n    //dataItem.__disabled = false;\n    var renderer = this.renderer;\n    if (!$type.isNumber(index)) {\n      index = this.categoryToIndex(dataItem.category);\n    }\n    var endIndex = this.categoryToIndex(dataItem.endCategory);\n    if (!$type.isNumber(endIndex)) {\n      endIndex = index;\n    }\n    var position = this.indexToPosition(index, dataItem.locations.category);\n    var endPosition = this.indexToPosition(endIndex, dataItem.locations.endCategory);\n    dataItem.position = position;\n    var fillEndIndex;\n    var fillPosition;\n    var fillEndPosition;\n    if (dataItem.isRange) {\n      fillEndIndex = endIndex;\n      fillPosition = this.indexToPosition(index, dataItem.locations.category);\n      fillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\n    }\n    dataItem.point = renderer.positionToPoint(position);\n    var tick = dataItem.tick;\n    if (tick && !tick.disabled) {\n      renderer.updateTickElement(tick, position, endPosition);\n    }\n    var grid = dataItem.grid;\n    if (grid && !grid.disabled) {\n      renderer.updateGridElement(grid, position, endPosition);\n    }\n    var label = dataItem.label;\n    if (label && !label.disabled) {\n      // theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" won't work, which is not intuitive.\n      if (!dataItem.isRange || label.text == undefined) {\n        dataItem.text = dataItem.text;\n      }\n      renderer.updateLabelElement(label, position, endPosition);\n      if (renderer instanceof AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth || renderer instanceof AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight) {\n        if (dataItem.label.html) {\n          this.ghostLabel.html = dataItem.label.currentText;\n        } else {\n          this.ghostLabel.text = dataItem.label.currentText;\n        }\n      }\n    }\n    var fill = dataItem.axisFill;\n    if (fill && !fill.disabled) {\n      if (!dataItem.isRange) {\n        fillEndIndex = index + this._frequency;\n        fillPosition = this.indexToPosition(index, fill.location);\n        fillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\n      }\n      renderer.updateFillElement(fill, fillPosition, fillEndPosition);\n      if (!dataItem.isRange) {\n        this.fillRule(dataItem, itemIndex);\n      }\n    }\n    if (dataItem.bullet) {\n      renderer.updateBullet(dataItem.bullet, position, endPosition);\n    }\n    var mask = dataItem.mask;\n    if (mask) {\n      renderer.updateFillElement(mask, fillPosition, fillEndPosition);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n  CategoryAxis.prototype.disposeData = function () {\n    this.dataItemsByCategory.clear();\n    _super.prototype.disposeData.call(this);\n  };\n  /**\r\n   * Processes the axis data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem     Data item\r\n   * @param dataContext  The raw data that corresponds to this data item\r\n   */\n  CategoryAxis.prototype.processDataItem = function (dataItem, dataContext) {\n    if (dataItem) {\n      // creat a collection for fast access\n      _super.prototype.processDataItem.call(this, dataItem, dataContext);\n      // check if such category already exists\n      //let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\n      //if (existingDataItem && existingDataItem != dataItem) {\n      //\tthis.dataItems.remove(existingDataItem);\n      //}\n      if ($type.hasValue(dataItem.category)) {\n        this.dataItemsByCategory.setKey(dataItem.category, dataItem);\n      }\n    }\n  };\n  CategoryAxis.prototype.getDataItem = function (dataContext) {\n    var category = dataContext[this.dataFields.category];\n    if ($type.hasValue(category)) {\n      var dataItem = this.dataItemsByCategory.getKey(category);\n      if (dataItem) {\n        return dataItem;\n      } else {\n        return this.dataItems.create();\n      }\n    }\n  };\n  /**\r\n   * Converts a category index to an actual screen coordinate on the axis.\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   *\r\n   * @param index     Index\r\n   * @param location  Location (0-1)\r\n   * @return Position (px)\r\n   */\n  CategoryAxis.prototype.indexToPosition = function (index, location) {\n    if (!$type.isNumber(location)) {\n      location = 0.5;\n    }\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = this.adjustDifference(startIndex, endIndex);\n    var startLocation = this.startLocation;\n    var endLocation = this.endLocation;\n    difference -= startLocation;\n    difference -= 1 - endLocation;\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n        var breakStartIndex = axisBreak.adjustedStartValue;\n        var breakEndIndex = axisBreak.adjustedEndValue;\n        if (index < startIndex || !$type.isNumber(breakStartIndex) || !$type.isNumber(breakEndIndex)) {\n          return false;\n        }\n        if ($math.intersect({\n          start: breakStartIndex,\n          end: breakEndIndex\n        }, {\n          start: startIndex,\n          end: endIndex\n        })) {\n          breakStartIndex = Math.max(startIndex, breakStartIndex);\n          breakEndIndex = Math.min(endIndex, breakEndIndex);\n          var breakSize = axisBreak.breakSize;\n          // value to the right of break end\n          if (index > breakEndIndex) {\n            startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n          }\n          // value to the left of break start\n          else if (index < breakStartIndex) {}\n          // value within break\n          else {\n            index = breakStartIndex + (index - breakStartIndex) * breakSize;\n          }\n        }\n        return true;\n      });\n    }\n    var deltaPosition = 0;\n    var dataItem = this.dataItems.getIndex(index);\n    if (dataItem) {\n      deltaPosition = dataItem.deltaPosition;\n    }\n    return $math.round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);\n  };\n  /**\r\n   * Converts a string category name to relative position on axis.\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   *\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Position\r\n   */\n  CategoryAxis.prototype.categoryToPosition = function (category, location) {\n    var index = this.categoryToIndex(category);\n    return this.indexToPosition(index, location);\n  };\n  /**\r\n   * Converts a string category name to a orientation point (x, y, angle) on axis\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Orientation point\r\n   */\n  CategoryAxis.prototype.categoryToPoint = function (category, location) {\n    var position = this.categoryToPosition(category, location);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\r\n   * Converts a string category name to a orientation point (x, y, angle) on axis\r\n   *\r\n   * `location` identifies relative location within category. 0 - beginning,\r\n   * 0.5 - middle, 1 - end, and anything inbetween.\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Orientation point\r\n   */\n  CategoryAxis.prototype.anyToPoint = function (category, location) {\n    return this.categoryToPoint(category, location);\n  };\n  /**\r\n   * Converts a string category name to relative position on axis.\r\n   *\r\n   * An alias to `categoryToPosition()`.\r\n   *\r\n   * @param category  Category name\r\n   * @param location  Location (0-1)\r\n   * @return Relative position\r\n   */\n  CategoryAxis.prototype.anyToPosition = function (category, location) {\n    return this.categoryToPosition(category, location);\n  };\n  /**\r\n   * Converts named category to an index of data item it corresponds to.\r\n   *\r\n   * @param category  Category\r\n   * @return Data item index\r\n   */\n  CategoryAxis.prototype.categoryToIndex = function (category) {\n    if ($type.hasValue(category)) {\n      var dataItem = this.dataItemsByCategory.getKey(category);\n      if (dataItem) {\n        return dataItem.index;\n      }\n    }\n  };\n  /**\r\n   * Zooms the axis to specific named ctaegories.\r\n   *\r\n   * @param startCategory  Start category\r\n   * @param endCategory    End category\r\n   */\n  CategoryAxis.prototype.zoomToCategories = function (startCategory, endCategory) {\n    this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\n  };\n  /**\r\n   * [getAnyRangePath description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param start         [description]\r\n   * @param end           [description]\r\n   * @param startLocation [description]\r\n   * @param endLocation   [description]\r\n   * @return [description]\r\n   */\n  CategoryAxis.prototype.getAnyRangePath = function (start, end, startLocation, endLocation) {\n    var startPos = this.categoryToPosition(start, startLocation);\n    var endPos = this.categoryToPosition(end, endLocation);\n    return this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\n  };\n  /**\r\n   * Takes an absolute position (px) within axis and adjust it to a specific\r\n   * `location` within category it corresponds to.\r\n   *\r\n   * @param position  Source position (px)\r\n   * @param location  Location within category (0-1)\r\n   * @return Adjusted position (px)\r\n   */\n  CategoryAxis.prototype.roundPosition = function (position, location) {\n    var index = this.positionToIndex(position);\n    return this.indexToPosition(index, location);\n  };\n  /**\r\n   * Finds and returns first series data item with specific category\r\n   * @param series    Target series\r\n   * @param category  Category\r\n   * @return XYSeriesDataItem data item\r\n   */\n  CategoryAxis.prototype.getFirstSeriesDataItem = function (series, category) {\n    for (var i = 0; i < series.dataItems.length; i++) {\n      var dataItem = series.dataItems.getIndex(i);\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  };\n  /**\r\n   * Finds and returns last series data item with specific category.\r\n   * @param series    Target series\r\n   * @param category  Category\r\n   * @return XYSeriesDataItem data item\r\n   */\n  CategoryAxis.prototype.getLastSeriesDataItem = function (series, category) {\n    for (var i = series.dataItems.length - 1; i >= 0; i--) {\n      var dataItem = series.dataItems.getIndex(i);\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  };\n  // todo: optimize\n  CategoryAxis.prototype.getSeriesDataItemByCategory = function (category, series) {\n    var _this = this;\n    var seriesDataItem;\n    series.dataItems.each(function (dataItem) {\n      if (series.xAxis == _this) {\n        if (dataItem.categoryX == category) {\n          seriesDataItem = dataItem;\n        }\n      } else if (series.yAxis == _this) {\n        if (dataItem.categoryY == category) {\n          seriesDataItem = dataItem;\n        }\n      }\n    });\n    return seriesDataItem;\n  };\n  /**\r\n   * Returns a data item from Series that corresponds to a specific absolute\r\n   * position on the Axis.\r\n   *\r\n   * @param series    Target series\r\n   * @param position  Position (px)\r\n   * @return XYSeriesDataItem data item\r\n   */\n  CategoryAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\n    var _this = this;\n    if ($type.isNumber(position)) {\n      var index_1 = this.positionToIndex(position);\n      if (index_1 >= this.dataItems.length) {\n        index_1--;\n      }\n      var dataItem = this.dataItems.getIndex(index_1);\n      if (dataItem) {\n        var category_1 = dataItem.category;\n        var sdi_1;\n        var seriesDataItem = series.dataItems.getIndex(index_1);\n        if (seriesDataItem) {\n          if (series.xAxis == this) {\n            if (seriesDataItem.categoryX == category_1) {\n              return seriesDataItem;\n            }\n          }\n          if (series.yAxis == this) {\n            if (seriesDataItem.categoryY == category_1) {\n              return seriesDataItem;\n            }\n          }\n        }\n        series.dataItems.each(function (dataItem) {\n          if (series.xAxis == _this) {\n            if (dataItem.categoryX == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n          if (series.yAxis == _this) {\n            if (dataItem.categoryY == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n        });\n        //@todo\n        if (findNearest) {}\n        return sdi_1;\n      }\n    }\n  };\n  /**\r\n   * Returns the X coordinate for series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @return X coordinate (px)\r\n   */\n  CategoryAxis.prototype.getX = function (dataItem, key, location, stackKey, range) {\n    var position = this.getPositionX(dataItem, key, location, stackKey, range);\n    if ($type.isNaN(position)) {\n      return this.basePoint.x;\n    } else {\n      return this.renderer.positionToPoint(position).x;\n    }\n  };\n  /**\r\n   * Returns relative position on axis for series' data item.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Category\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n  CategoryAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\n    var position;\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return position;\n  };\n  /**\r\n   * Returns the Y coordinate for series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @return Y coordinate (px)\r\n   */\n  CategoryAxis.prototype.getY = function (dataItem, key, location, stackKey, range) {\n    var position = this.getPositionY(dataItem, key, location, stackKey, range);\n    if ($type.isNaN(position)) {\n      return this.basePoint.y;\n    } else {\n      return this.renderer.positionToPoint(position).y;\n    }\n  };\n  /**\r\n   * Returns relative position on axis for series' data item.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Category\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n  CategoryAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\n    var position;\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return position;\n  };\n  /**\r\n   * Returns an angle for series data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Category\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  Stack key (?)\r\n   * @param range Range to fit in\r\n   * @return Angle\r\n   */\n  CategoryAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\n    var position = this.categoryToPosition(dataItem.categories[key], location);\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return this.positionToAngle(position);\n  };\n  /**\r\n   * Returns an absolute pixel coordinate of the start of the cell (category),\r\n   * that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Position (px)\r\n   * @return Cell start position (px)\r\n   */\n  CategoryAxis.prototype.getCellStartPosition = function (position) {\n    return this.roundPosition(position, 0);\n  };\n  /**\r\n   * Returns an absolute pixel coordinate of the end of the cell (category),\r\n   * that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Position (px)\r\n   * @return Cell end position (px)\r\n   */\n  CategoryAxis.prototype.getCellEndPosition = function (position) {\n    return this.roundPosition(position, 1);\n  };\n  /**\r\n   * Returns text to show in a category tooltip, based on specific position\r\n   * within axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position (px)\r\n   * @return Label (category)\r\n   */\n  CategoryAxis.prototype.getTooltipText = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n    if (dataItem) {\n      this.tooltipDataItem = dataItem;\n      this.tooltip.dataItem = dataItem;\n      if (this.tooltipText) {\n        return this.tooltipText;\n      }\n      if (!this._adapterO) {\n        return dataItem.category;\n      } else {\n        return this._adapterO.apply(\"getTooltipText\", dataItem.category);\n      }\n    }\n  };\n  /**\r\n   * Returns an index of the category that corresponds to specific pixel\r\n   * position within axis.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Category index\r\n   */\n  CategoryAxis.prototype.positionToIndex = function (position) {\n    position = $math.round(position, 10);\n    if (position < 0) {\n      position = 0;\n    }\n    if (position > 1) {\n      position = 1;\n    }\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = endIndex - startIndex - this.startLocation - (1 - this.endLocation);\n    position += 1 / difference * this.startLocation;\n    var index = null;\n    if (this._axisBreaks) {\n      var axisBreaks = this._axisBreaks;\n      // in case we have some axis breaks\n      $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n        var breakStartPosition = axisBreak.startPosition;\n        var breakEndPosition = axisBreak.endPosition;\n        var breakStartIndex = axisBreak.adjustedStartValue;\n        var breakEndIndex = axisBreak.adjustedEndValue;\n        breakStartIndex = $math.max(breakStartIndex, startIndex);\n        breakEndIndex = $math.min(breakEndIndex, endIndex);\n        var breakSize = axisBreak.breakSize;\n        difference -= (breakEndIndex - breakStartIndex) * (1 - breakSize);\n        // position to the right of break end\n        if (position > breakEndPosition) {\n          startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n        }\n        // position to the left of break start\n        else if (position < breakStartPosition) {}\n        // value within break\n        else {\n          var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\n          index = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\n          return false;\n        }\n        return true;\n      });\n    }\n    if (!$type.isNumber(index)) {\n      index = Math.floor(position * difference + startIndex);\n    }\n    if (index >= this.dataItems.length) {\n      index = this.dataItems.length - 1;\n    }\n    // not good, when panning out of bounds, each time one less item gets selected\n    //if (index >= endIndex) {\n    //\tindex--;\n    //}\n    return index;\n  };\n  /**\r\n   * Returns category based on position.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\r\n   *\r\n   * @since 4.3.8\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n  CategoryAxis.prototype.positionToCategory = function (position) {\n    return this.getPositionLabel(position);\n  };\n  /**\r\n   * Returns category based on position.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n  CategoryAxis.prototype.getPositionLabel = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n    if (dataItem) {\n      return dataItem.category;\n    }\n  };\n  Object.defineProperty(CategoryAxis.prototype, \"basePoint\", {\n    /**\r\n     * Coordinates of the actual axis start.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Base point\r\n     */\n    get: function () {\n      // This makes base grid to be drawn at the end of the axis and adds extra\n      // grid which we need to nicely close the chart.\n      return this.renderer.positionToPoint(1);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Initializes Axis' renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  CategoryAxis.prototype.initRenderer = function () {\n    _super.prototype.initRenderer.call(this);\n    var renderer = this.renderer;\n    renderer.baseGrid.disabled = true;\n  };\n  Object.defineProperty(CategoryAxis.prototype, \"frequency\", {\n    /**\r\n     * Current frequency of labels of the axis.\r\n     *\r\n     * Normally it would be 1, but when labels start to be hidden due\r\n     * to `minGridDistance` this read-only property will increase.\r\n     *\r\n     * @readonly\r\n     * @since 4.2.0\r\n     * @return Label frequency\r\n     */\n    get: function () {\n      return this._frequency;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxis.prototype, \"sortBySeries\", {\n    /**\r\n     * @return Sort categories?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"sortBySeries\");\n    },\n    /**\r\n     * If set to a reference of [[ColumnSeries]] the categories will be sorted\r\n     * by actual values.\r\n     *\r\n     * The categories are ordered in descending order (from highest values to\r\n     * lowest). To reverse the order, use axis renderer's `inversed` setting.\r\n     * E.g.:\r\n     *\r\n     * ```TypeScript\r\n     * categoryAxis.sortBySeries = series;\r\n     * categoryAxis.renderer.inversed = true;\r\n     * ```\r\n     * ```JavaScript\r\n     * categoryAxis.sortBySeries = series;\r\n     * categoryAxis.renderer.inversed = true;\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"xAxes\": [{\r\n     *     // ...\r\n     *     \"sortBySeries\": \"s1\",\r\n     *     \"renderer\": {\r\n     *       // ...\r\n     *       \"inversed\": true\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * @since 4.8.7\r\n     * @param  value  Sort categories?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"sortBySeries\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n  CategoryAxis.prototype.processConfig = function (config) {\n    if (config) {\n      if ($type.hasValue(config.sortBySeries) && $type.isString(config.sortBySeries)) {\n        if (this.map.hasKey(config.sortBySeries)) {\n          config.sortBySeries = this.map.getKey(config.sortBySeries);\n        } else {\n          this.addDelayedMap(\"sortBySeries\", config.sortBySeries);\n          delete config.sortBySeries;\n        }\n      }\n    }\n    _super.prototype.processConfig.call(this, config);\n  };\n  return CategoryAxis;\n}(Axis);\nexport { CategoryAxis };\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;","map":{"version":3,"names":["__extends","Axis","AxisDataItem","AxisRendererX","AxisRendererY","registry","Dictionary","CategoryAxisBreak","$math","$type","$iter","CategoryAxisDataItem","_super","_this","call","seriesDataItems","className","text","locations","category","endCategory","deltaPosition","applyTheme","Object","defineProperty","prototype","get","_adapterO","isEnabled","apply","properties","set","value","oldCategory","setProperty","hasValue","component","validateDataElement","enumerable","configurable","deltaCoordinate","invalidateDataItems","invalidateSeries","CategoryAxis","dataItemsByCategory","axisFieldName","_lastDataItem","createDataItem","_disposers","push","addDisposer","mainDataSet","events","on","event","removeKey","oldValue","createAxisBreak","processSeriesDataItem","dataItem","axisLetter","categoryAxisDataItem","getKey","seriesId","uid","dataItems","remove","validateDataRange","each","_series","iterator","series","xAxis","yAxis","invalidateDataRange","startIndex","positionToIndex","start","endIndex","end","length","minIndex","maxIndex","i","axisDataItem","getIndex","i_1","seriesDataItem","index","isNumber","_axisBreaks","validate","dataCount","fitToRange","Math","floor","ceil","renderer","invalid","maxCount","axisLength","max","minGridDistance","Number","MAX_SAFE_INTEGER","frequency","min","_startIndex","_endIndex","fixAxisBreaks","_frequency","maxZoomFactor","resetIterators","itemIndex","__disabled","len","round","axisBreak","isInBreak","appendDataItem","axisBreaks","adjustedStartValue","adjustedEndValue","intersect","b","frequency_1","breakSize","itemIndex_1","validateBreaks","validateAxisRanges","ghostLabel","invalidate","invalidateLayout","_axisItemCount","categoryToIndex","position","indexToPosition","endPosition","fillEndIndex","fillPosition","fillEndPosition","isRange","point","positionToPoint","tick","disabled","updateTickElement","grid","updateGridElement","label","undefined","updateLabelElement","measuredWidth","measuredHeight","html","currentText","fill","axisFill","location","updateFillElement","fillRule","bullet","updateBullet","mask","disposeData","clear","processDataItem","dataContext","setKey","getDataItem","dataFields","create","difference","adjustDifference","startLocation","endLocation","eachContinue","breakStartIndex","breakEndIndex","categoryToPosition","categoryToPoint","angle","positionToAngle","x","y","anyToPoint","anyToPosition","zoomToCategories","startCategory","zoomToIndexes","getAnyRangePath","startPos","endPos","getPositionRangePath","roundPosition","getFirstSeriesDataItem","categoryX","categoryY","getLastSeriesDataItem","getSeriesDataItemByCategory","getSeriesDataItem","findNearest","index_1","category_1","sdi_1","abs","getX","key","stackKey","range","getPositionX","isNaN","basePoint","categories","getY","getPositionY","getAngle","getCellStartPosition","getCellEndPosition","getTooltipText","tooltipDataItem","tooltip","tooltipText","breakStartPosition","startPosition","breakEndPosition","breakPosition","positionToCategory","getPositionLabel","initRenderer","baseGrid","getPropertyValue","setPropertyValue","processConfig","config","sortBySeries","isString","map","hasKey","addDelayedMap","registeredClasses"],"sources":["D:/alodelivery test/node_modules/@amcharts/amcharts4/.internal/charts/axes/CategoryAxis.js"],"sourcesContent":["/**\r\n * Category axis module\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Axis, AxisDataItem } from \"./Axis\";\r\nimport { AxisRendererX } from \"./AxisRendererX\";\r\nimport { AxisRendererY } from \"./AxisRendererY\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Defines a [[DataItem]] for [[CategoryAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nvar CategoryAxisDataItem = /** @class */ (function (_super) {\r\n    __extends(CategoryAxisDataItem, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function CategoryAxisDataItem() {\r\n        var _this = _super.call(this) || this;\r\n        _this.seriesDataItems = {};\r\n        _this.className = \"CategoryAxisDataItem\";\r\n        _this.text = \"{category}\";\r\n        _this.locations.category = 0;\r\n        _this.locations.endCategory = 1;\r\n        _this.deltaPosition = 0;\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(CategoryAxisDataItem.prototype, \"category\", {\r\n        /**\r\n         * @return Category\r\n         */\r\n        get: function () {\r\n            if (this._adapterO) {\r\n                if (this._adapterO.isEnabled(\"category\")) {\r\n                    return this._adapterO.apply(\"category\", this.properties.category);\r\n                }\r\n            }\r\n            return this.properties.category;\r\n        },\r\n        /**\r\n         * Category.\r\n         *\r\n         * @param value  Category\r\n         */\r\n        set: function (value) {\r\n            var oldCategory = this.properties.category;\r\n            this.setProperty(\"category\", value);\r\n            if ($type.hasValue(oldCategory) && oldCategory != value) {\r\n                if (this.component) {\r\n                    this.component.validateDataElement(this);\r\n                }\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CategoryAxisDataItem.prototype, \"endCategory\", {\r\n        /**\r\n         * @return End category\r\n         */\r\n        get: function () {\r\n            return this.properties.endCategory;\r\n        },\r\n        /**\r\n         * End category.\r\n         *\r\n         * Used for items that span several categories, like [[CategoryAxisBreak]].\r\n         *\r\n         * @param value  End category\r\n         */\r\n        set: function (value) {\r\n            this.setProperty(\"endCategory\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CategoryAxisDataItem.prototype, \"deltaPosition\", {\r\n        get: function () {\r\n            return this.properties.deltaCoordinate;\r\n        },\r\n        set: function (value) {\r\n            if (value != this.properties.deltaCoordinate) {\r\n                this.setProperty(\"deltaCoordinate\", value);\r\n                if (this.component) {\r\n                    this.component.invalidateDataItems();\r\n                    this.component.invalidateSeries();\r\n                }\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return CategoryAxisDataItem;\r\n}(AxisDataItem));\r\nexport { CategoryAxisDataItem };\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Used to create a category-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"CategoryAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Clients\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link ICategoryAxisEvents} for a list of available Events\r\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nvar CategoryAxis = /** @class */ (function (_super) {\r\n    __extends(CategoryAxis, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function CategoryAxis() {\r\n        var _this = \r\n        // Init\r\n        _super.call(this) || this;\r\n        /**\r\n         * A collection that holds Axis' data items sorted by each category.\r\n         */\r\n        _this.dataItemsByCategory = new Dictionary();\r\n        _this.className = \"CategoryAxis\";\r\n        // Set field name\r\n        _this.axisFieldName = \"category\";\r\n        _this._lastDataItem = _this.createDataItem();\r\n        _this._lastDataItem.component = _this;\r\n        _this._disposers.push(_this._lastDataItem);\r\n        // Apply theme\r\n        _this.applyTheme();\r\n        var dataItemsByCategory = _this.dataItemsByCategory;\r\n        _this.addDisposer(_this.mainDataSet.events.on(\"removed\", function (event) {\r\n            dataItemsByCategory.removeKey(event.oldValue.category);\r\n        }));\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n     *\r\n     * @see {@link DataItem}\r\n     * @return Data Item\r\n     */\r\n    CategoryAxis.prototype.createDataItem = function () {\r\n        return new CategoryAxisDataItem();\r\n    };\r\n    /**\r\n     * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n     *\r\n     * @return Axis break\r\n     */\r\n    CategoryAxis.prototype.createAxisBreak = function () {\r\n        return new CategoryAxisBreak();\r\n    };\r\n    /**\r\n     * Processes a related series' data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param dataItem  Data item\r\n     */\r\n    CategoryAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\r\n        _super.prototype.processSeriesDataItem.call(this, dataItem, axisLetter);\r\n        var category = dataItem[\"category\" + this.axisLetter];\r\n        if ($type.hasValue(category)) {\r\n            var categoryAxisDataItem = this.dataItemsByCategory.getKey(category);\r\n            if (categoryAxisDataItem) {\r\n                var seriesId = dataItem.component.uid;\r\n                var seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\r\n                if (!seriesDataItems) {\r\n                    seriesDataItems = [];\r\n                    categoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\r\n                }\r\n                seriesDataItems.push(dataItem);\r\n            }\r\n        }\r\n        else {\r\n            dataItem.component.dataItems.remove(dataItem);\r\n        }\r\n    };\r\n    /**\r\n     * Validates the data range.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     */\r\n    CategoryAxis.prototype.validateDataRange = function () {\r\n        var _this = this;\r\n        _super.prototype.validateDataRange.call(this);\r\n        $iter.each(this._series.iterator(), function (series) {\r\n            if ((series.xAxis instanceof CategoryAxis) && (series.yAxis instanceof CategoryAxis)) {\r\n                series.invalidateDataRange();\r\n            }\r\n            else {\r\n                var startIndex = _this.positionToIndex(_this.start);\r\n                var endIndex = _this.positionToIndex(_this.end);\r\n                if (endIndex >= _this.dataItems.length) {\r\n                    endIndex--;\r\n                }\r\n                var seriesId = series.uid;\r\n                var minIndex = void 0;\r\n                var maxIndex = void 0;\r\n                for (var i = startIndex; i <= endIndex; i++) {\r\n                    var axisDataItem = _this.dataItems.getIndex(i);\r\n                    if (axisDataItem) {\r\n                        var seriesDataItems = axisDataItem.seriesDataItems[seriesId];\r\n                        if (seriesDataItems) {\r\n                            for (var i_1 = 0; i_1 < seriesDataItems.length; i_1++) {\r\n                                var seriesDataItem = seriesDataItems[i_1];\r\n                                if (seriesDataItem) {\r\n                                    var index = seriesDataItem.index;\r\n                                    if (!$type.isNumber(minIndex) || index < minIndex) {\r\n                                        minIndex = index;\r\n                                    }\r\n                                    if (!$type.isNumber(maxIndex) || index > maxIndex) {\r\n                                        maxIndex = index;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if ($type.isNumber(minIndex)) {\r\n                    series.startIndex = minIndex;\r\n                }\r\n                else {\r\n                    series.start = _this.start;\r\n                }\r\n                if ($type.isNumber(maxIndex)) {\r\n                    series.endIndex = maxIndex + 1;\r\n                }\r\n                else {\r\n                    series.end = _this.end;\r\n                }\r\n                // range might not change, but axis breaks might.\r\n                if (_this._axisBreaks && _this._axisBreaks.length > 0) {\r\n                    series.invalidateDataRange();\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Validates the whole axis. Causes it to redraw.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     */\r\n    CategoryAxis.prototype.validate = function () {\r\n        var _this = this;\r\n        _super.prototype.validate.call(this);\r\n        var dataCount = this.dataItems.length;\r\n        var startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\r\n        var endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\r\n        if (this.renderer.invalid) {\r\n            this.renderer.validate();\r\n        }\r\n        // find frequency at which we'll show items\r\n        var maxCount = this.renderer.axisLength / Math.max(this.renderer.minGridDistance, 1 / Number.MAX_SAFE_INTEGER);\r\n        var frequency = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\r\n        this._startIndex = Math.floor(startIndex / frequency) * frequency;\r\n        this._endIndex = Math.ceil(this.end * dataCount);\r\n        this.fixAxisBreaks();\r\n        if (this._startIndex == this._endIndex) {\r\n            this._endIndex++;\r\n        }\r\n        this._frequency = frequency;\r\n        if (this.axisLength <= 0) {\r\n            return;\r\n        }\r\n        this.maxZoomFactor = this.dataItems.length;\r\n        if (this.dataItems.length <= 0) {\r\n            this.maxZoomFactor = 1;\r\n        }\r\n        this.resetIterators();\r\n        // it's important to use protected variables here, as getters will return 0 - length\r\n        // TODO use iterator instead\r\n        // @ todo: not solved cat axis item fading\r\n        startIndex = $math.max(0, this._startIndex - this._frequency);\r\n        endIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\r\n        var itemIndex = 0;\r\n        for (var i = 0; i < startIndex; i++) {\r\n            var dataItem = this.dataItems.getIndex(i);\r\n            dataItem.__disabled = true;\r\n        }\r\n        for (var i = endIndex, len = this.dataItems.length; i < len; i++) {\r\n            var dataItem = this.dataItems.getIndex(i);\r\n            dataItem.__disabled = true;\r\n        }\r\n        for (var i = startIndex; i < endIndex; i++) {\r\n            if (i < this.dataItems.length) {\r\n                var dataItem = this.dataItems.getIndex(i);\r\n                if (i / this._frequency == Math.round(i / this._frequency)) {\r\n                    var axisBreak = this.isInBreak(i);\r\n                    if (!axisBreak) {\r\n                        this.appendDataItem(dataItem);\r\n                        this.validateDataElement(dataItem, itemIndex);\r\n                    }\r\n                    itemIndex++;\r\n                }\r\n                else {\r\n                    //previously we disabled all before, but this is better for cpu\r\n                    //this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\r\n                    dataItem.__disabled = true;\r\n                }\r\n            }\r\n        }\r\n        this.appendDataItem(this._lastDataItem);\r\n        this.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\r\n        if (this._axisBreaks) {\r\n            var axisBreaks = this._axisBreaks;\r\n            axisBreaks.each(function (axisBreak) {\r\n                var adjustedStartValue = axisBreak.adjustedStartValue;\r\n                var adjustedEndValue = axisBreak.adjustedEndValue;\r\n                if ($math.intersect({ start: adjustedStartValue, end: adjustedEndValue }, { start: _this._startIndex, end: _this._endIndex })) {\r\n                    for (var b = adjustedStartValue; b <= adjustedEndValue; b++) {\r\n                        var dataItem = _this.dataItems.getIndex(b);\r\n                        dataItem.__disabled = true;\r\n                    }\r\n                    var frequency_1 = $math.fitToRange(Math.ceil(_this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\r\n                    var itemIndex_1 = 0;\r\n                    if (axisBreak.breakSize > 0) {\r\n                        // TODO use iterator instead\r\n                        for (var b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency_1) {\r\n                            var dataItem = _this.dataItems.getIndex(b);\r\n                            dataItem.__disabled = false;\r\n                            _this.appendDataItem(dataItem);\r\n                            _this.validateDataElement(dataItem, itemIndex_1);\r\n                            itemIndex_1++;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        this.validateBreaks();\r\n        this.validateAxisRanges();\r\n        this.ghostLabel.invalidate(); // solves font issue\r\n        this.renderer.invalidateLayout();\r\n    };\r\n    /**\r\n     * [validateDataElement description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param dataItem   [description]\r\n     * @param itemIndex  [description]\r\n     */\r\n    CategoryAxis.prototype.validateDataElement = function (dataItem, itemIndex, index) {\r\n        _super.prototype.validateDataElement.call(this, dataItem);\r\n        dataItem.itemIndex = this._axisItemCount;\r\n        this._axisItemCount++;\r\n        //dataItem.__disabled = false;\r\n        var renderer = this.renderer;\r\n        if (!$type.isNumber(index)) {\r\n            index = this.categoryToIndex(dataItem.category);\r\n        }\r\n        var endIndex = this.categoryToIndex(dataItem.endCategory);\r\n        if (!$type.isNumber(endIndex)) {\r\n            endIndex = index;\r\n        }\r\n        var position = this.indexToPosition(index, dataItem.locations.category);\r\n        var endPosition = this.indexToPosition(endIndex, dataItem.locations.endCategory);\r\n        dataItem.position = position;\r\n        var fillEndIndex;\r\n        var fillPosition;\r\n        var fillEndPosition;\r\n        if (dataItem.isRange) {\r\n            fillEndIndex = endIndex;\r\n            fillPosition = this.indexToPosition(index, dataItem.locations.category);\r\n            fillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\r\n        }\r\n        dataItem.point = renderer.positionToPoint(position);\r\n        var tick = dataItem.tick;\r\n        if (tick && !tick.disabled) {\r\n            renderer.updateTickElement(tick, position, endPosition);\r\n        }\r\n        var grid = dataItem.grid;\r\n        if (grid && !grid.disabled) {\r\n            renderer.updateGridElement(grid, position, endPosition);\r\n        }\r\n        var label = dataItem.label;\r\n        if (label && !label.disabled) {\r\n            // theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" won't work, which is not intuitive.\r\n            if (!dataItem.isRange || label.text == undefined) {\r\n                dataItem.text = dataItem.text;\r\n            }\r\n            renderer.updateLabelElement(label, position, endPosition);\r\n            if ((renderer instanceof AxisRendererY && dataItem.label.measuredWidth > this.ghostLabel.measuredWidth) || (renderer instanceof AxisRendererX && dataItem.label.measuredHeight > this.ghostLabel.measuredHeight)) {\r\n                if (dataItem.label.html) {\r\n                    this.ghostLabel.html = dataItem.label.currentText;\r\n                }\r\n                else {\r\n                    this.ghostLabel.text = dataItem.label.currentText;\r\n                }\r\n            }\r\n        }\r\n        var fill = dataItem.axisFill;\r\n        if (fill && !fill.disabled) {\r\n            if (!dataItem.isRange) {\r\n                fillEndIndex = index + this._frequency;\r\n                fillPosition = this.indexToPosition(index, fill.location);\r\n                fillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\r\n            }\r\n            renderer.updateFillElement(fill, fillPosition, fillEndPosition);\r\n            if (!dataItem.isRange) {\r\n                this.fillRule(dataItem, itemIndex);\r\n            }\r\n        }\r\n        if (dataItem.bullet) {\r\n            renderer.updateBullet(dataItem.bullet, position, endPosition);\r\n        }\r\n        var mask = dataItem.mask;\r\n        if (mask) {\r\n            renderer.updateFillElement(mask, fillPosition, fillEndPosition);\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    CategoryAxis.prototype.disposeData = function () {\r\n        this.dataItemsByCategory.clear();\r\n        _super.prototype.disposeData.call(this);\r\n    };\r\n    /**\r\n     * Processes the axis data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param dataItem     Data item\r\n     * @param dataContext  The raw data that corresponds to this data item\r\n     */\r\n    CategoryAxis.prototype.processDataItem = function (dataItem, dataContext) {\r\n        if (dataItem) {\r\n            // creat a collection for fast access\r\n            _super.prototype.processDataItem.call(this, dataItem, dataContext);\r\n            // check if such category already exists\r\n            //let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\r\n            //if (existingDataItem && existingDataItem != dataItem) {\r\n            //\tthis.dataItems.remove(existingDataItem);\r\n            //}\r\n            if ($type.hasValue(dataItem.category)) {\r\n                this.dataItemsByCategory.setKey(dataItem.category, dataItem);\r\n            }\r\n        }\r\n    };\r\n    CategoryAxis.prototype.getDataItem = function (dataContext) {\r\n        var category = (dataContext[this.dataFields.category]);\r\n        if ($type.hasValue(category)) {\r\n            var dataItem = this.dataItemsByCategory.getKey(category);\r\n            if (dataItem) {\r\n                return dataItem;\r\n            }\r\n            else {\r\n                return this.dataItems.create();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Converts a category index to an actual screen coordinate on the axis.\r\n     *\r\n     * `location` identifies relative location within category. 0 - beginning,\r\n     * 0.5 - middle, 1 - end, and anything inbetween.\r\n     *\r\n     * @param index     Index\r\n     * @param location  Location (0-1)\r\n     * @return Position (px)\r\n     */\r\n    CategoryAxis.prototype.indexToPosition = function (index, location) {\r\n        if (!$type.isNumber(location)) {\r\n            location = 0.5;\r\n        }\r\n        var startIndex = this.startIndex;\r\n        var endIndex = this.endIndex;\r\n        var difference = this.adjustDifference(startIndex, endIndex);\r\n        var startLocation = this.startLocation;\r\n        var endLocation = this.endLocation;\r\n        difference -= startLocation;\r\n        difference -= (1 - endLocation);\r\n        if (this._axisBreaks) {\r\n            var axisBreaks = this._axisBreaks;\r\n            $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\r\n                var breakStartIndex = axisBreak.adjustedStartValue;\r\n                var breakEndIndex = axisBreak.adjustedEndValue;\r\n                if (index < startIndex || !$type.isNumber(breakStartIndex) || !$type.isNumber(breakEndIndex)) {\r\n                    return false;\r\n                }\r\n                if ($math.intersect({ start: breakStartIndex, end: breakEndIndex }, { start: startIndex, end: endIndex })) {\r\n                    breakStartIndex = Math.max(startIndex, breakStartIndex);\r\n                    breakEndIndex = Math.min(endIndex, breakEndIndex);\r\n                    var breakSize = axisBreak.breakSize;\r\n                    // value to the right of break end\r\n                    if (index > breakEndIndex) {\r\n                        startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n                    }\r\n                    // value to the left of break start\r\n                    else if (index < breakStartIndex) {\r\n                    }\r\n                    // value within break\r\n                    else {\r\n                        index = breakStartIndex + (index - breakStartIndex) * breakSize;\r\n                    }\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n        var deltaPosition = 0;\r\n        var dataItem = this.dataItems.getIndex(index);\r\n        if (dataItem) {\r\n            deltaPosition = dataItem.deltaPosition;\r\n        }\r\n        return $math.round(deltaPosition + (index + location - startLocation - startIndex) / difference, 5);\r\n    };\r\n    /**\r\n     * Converts a string category name to relative position on axis.\r\n     *\r\n     * `location` identifies relative location within category. 0 - beginning,\r\n     * 0.5 - middle, 1 - end, and anything inbetween.\r\n     *\r\n     * @param category  Category name\r\n     * @param location  Location (0-1)\r\n     * @return Position\r\n     */\r\n    CategoryAxis.prototype.categoryToPosition = function (category, location) {\r\n        var index = this.categoryToIndex(category);\r\n        return this.indexToPosition(index, location);\r\n    };\r\n    /**\r\n     * Converts a string category name to a orientation point (x, y, angle) on axis\r\n     *\r\n     * `location` identifies relative location within category. 0 - beginning,\r\n     * 0.5 - middle, 1 - end, and anything inbetween.\r\n     * @param category  Category name\r\n     * @param location  Location (0-1)\r\n     * @return Orientation point\r\n     */\r\n    CategoryAxis.prototype.categoryToPoint = function (category, location) {\r\n        var position = this.categoryToPosition(category, location);\r\n        var point = this.renderer.positionToPoint(position);\r\n        var angle = this.renderer.positionToAngle(position);\r\n        return { x: point.x, y: point.y, angle: angle };\r\n    };\r\n    /**\r\n     * Converts a string category name to a orientation point (x, y, angle) on axis\r\n     *\r\n     * `location` identifies relative location within category. 0 - beginning,\r\n     * 0.5 - middle, 1 - end, and anything inbetween.\r\n     * @param category  Category name\r\n     * @param location  Location (0-1)\r\n     * @return Orientation point\r\n     */\r\n    CategoryAxis.prototype.anyToPoint = function (category, location) {\r\n        return this.categoryToPoint(category, location);\r\n    };\r\n    /**\r\n     * Converts a string category name to relative position on axis.\r\n     *\r\n     * An alias to `categoryToPosition()`.\r\n     *\r\n     * @param category  Category name\r\n     * @param location  Location (0-1)\r\n     * @return Relative position\r\n     */\r\n    CategoryAxis.prototype.anyToPosition = function (category, location) {\r\n        return this.categoryToPosition(category, location);\r\n    };\r\n    /**\r\n     * Converts named category to an index of data item it corresponds to.\r\n     *\r\n     * @param category  Category\r\n     * @return Data item index\r\n     */\r\n    CategoryAxis.prototype.categoryToIndex = function (category) {\r\n        if ($type.hasValue(category)) {\r\n            var dataItem = this.dataItemsByCategory.getKey(category);\r\n            if (dataItem) {\r\n                return dataItem.index;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Zooms the axis to specific named ctaegories.\r\n     *\r\n     * @param startCategory  Start category\r\n     * @param endCategory    End category\r\n     */\r\n    CategoryAxis.prototype.zoomToCategories = function (startCategory, endCategory) {\r\n        this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\r\n    };\r\n    /**\r\n     * [getAnyRangePath description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param start         [description]\r\n     * @param end           [description]\r\n     * @param startLocation [description]\r\n     * @param endLocation   [description]\r\n     * @return [description]\r\n     */\r\n    CategoryAxis.prototype.getAnyRangePath = function (start, end, startLocation, endLocation) {\r\n        var startPos = this.categoryToPosition(start, startLocation);\r\n        var endPos = this.categoryToPosition(end, endLocation);\r\n        return this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\r\n    };\r\n    /**\r\n     * Takes an absolute position (px) within axis and adjust it to a specific\r\n     * `location` within category it corresponds to.\r\n     *\r\n     * @param position  Source position (px)\r\n     * @param location  Location within category (0-1)\r\n     * @return Adjusted position (px)\r\n     */\r\n    CategoryAxis.prototype.roundPosition = function (position, location) {\r\n        var index = this.positionToIndex(position);\r\n        return this.indexToPosition(index, location);\r\n    };\r\n    /**\r\n     * Finds and returns first series data item with specific category\r\n     * @param series    Target series\r\n     * @param category  Category\r\n     * @return XYSeriesDataItem data item\r\n     */\r\n    CategoryAxis.prototype.getFirstSeriesDataItem = function (series, category) {\r\n        for (var i = 0; i < series.dataItems.length; i++) {\r\n            var dataItem = series.dataItems.getIndex(i);\r\n            if (series.xAxis == this) {\r\n                if (dataItem.categoryX == category) {\r\n                    return dataItem;\r\n                }\r\n            }\r\n            if (series.yAxis == this) {\r\n                if (dataItem.categoryY == category) {\r\n                    return dataItem;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Finds and returns last series data item with specific category.\r\n     * @param series    Target series\r\n     * @param category  Category\r\n     * @return XYSeriesDataItem data item\r\n     */\r\n    CategoryAxis.prototype.getLastSeriesDataItem = function (series, category) {\r\n        for (var i = series.dataItems.length - 1; i >= 0; i--) {\r\n            var dataItem = series.dataItems.getIndex(i);\r\n            if (series.xAxis == this) {\r\n                if (dataItem.categoryX == category) {\r\n                    return dataItem;\r\n                }\r\n            }\r\n            if (series.yAxis == this) {\r\n                if (dataItem.categoryY == category) {\r\n                    return dataItem;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    // todo: optimize\r\n    CategoryAxis.prototype.getSeriesDataItemByCategory = function (category, series) {\r\n        var _this = this;\r\n        var seriesDataItem;\r\n        series.dataItems.each(function (dataItem) {\r\n            if (series.xAxis == _this) {\r\n                if (dataItem.categoryX == category) {\r\n                    seriesDataItem = dataItem;\r\n                }\r\n            }\r\n            else if (series.yAxis == _this) {\r\n                if (dataItem.categoryY == category) {\r\n                    seriesDataItem = dataItem;\r\n                }\r\n            }\r\n        });\r\n        return seriesDataItem;\r\n    };\r\n    /**\r\n     * Returns a data item from Series that corresponds to a specific absolute\r\n     * position on the Axis.\r\n     *\r\n     * @param series    Target series\r\n     * @param position  Position (px)\r\n     * @return XYSeriesDataItem data item\r\n     */\r\n    CategoryAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\r\n        var _this = this;\r\n        if ($type.isNumber(position)) {\r\n            var index_1 = this.positionToIndex(position);\r\n            if (index_1 >= this.dataItems.length) {\r\n                index_1--;\r\n            }\r\n            var dataItem = this.dataItems.getIndex(index_1);\r\n            if (dataItem) {\r\n                var category_1 = dataItem.category;\r\n                var sdi_1;\r\n                var seriesDataItem = series.dataItems.getIndex(index_1);\r\n                if (seriesDataItem) {\r\n                    if (series.xAxis == this) {\r\n                        if (seriesDataItem.categoryX == category_1) {\r\n                            return seriesDataItem;\r\n                        }\r\n                    }\r\n                    if (series.yAxis == this) {\r\n                        if (seriesDataItem.categoryY == category_1) {\r\n                            return seriesDataItem;\r\n                        }\r\n                    }\r\n                }\r\n                series.dataItems.each(function (dataItem) {\r\n                    if (series.xAxis == _this) {\r\n                        if (dataItem.categoryX == category_1) {\r\n                            if (!sdi_1) {\r\n                                sdi_1 = dataItem;\r\n                            }\r\n                            if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\r\n                                sdi_1 = dataItem;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (series.yAxis == _this) {\r\n                        if (dataItem.categoryY == category_1) {\r\n                            if (!sdi_1) {\r\n                                sdi_1 = dataItem;\r\n                            }\r\n                            if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\r\n                                sdi_1 = dataItem;\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n                //@todo\r\n                if (findNearest) {\r\n                }\r\n                return sdi_1;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns the X coordinate for series' data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param dataItem  Data item\r\n     * @param key       Category\r\n     * @param location  Location (0-1)\r\n     * @return X coordinate (px)\r\n     */\r\n    CategoryAxis.prototype.getX = function (dataItem, key, location, stackKey, range) {\r\n        var position = this.getPositionX(dataItem, key, location, stackKey, range);\r\n        if ($type.isNaN(position)) {\r\n            return this.basePoint.x;\r\n        }\r\n        else {\r\n            return this.renderer.positionToPoint(position).x;\r\n        }\r\n    };\r\n    /**\r\n     * Returns relative position on axis for series' data item.\r\n     *\r\n     * @since 4.5.14\r\n     * @param  dataItem  Data item\r\n     * @param  key       Category\r\n     * @param  location  Location (0-1)\r\n     * @return           Relative position\r\n     */\r\n    CategoryAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\r\n        var position;\r\n        if ($type.hasValue(key)) {\r\n            position = this.categoryToPosition(dataItem.categories[key], location);\r\n        }\r\n        if (range) {\r\n            position = $math.fitToRange(position, range.start, range.end);\r\n        }\r\n        return position;\r\n    };\r\n    /**\r\n     * Returns the Y coordinate for series' data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param dataItem  Data item\r\n     * @param key       Category\r\n     * @param location  Location (0-1)\r\n     * @return Y coordinate (px)\r\n     */\r\n    CategoryAxis.prototype.getY = function (dataItem, key, location, stackKey, range) {\r\n        var position = this.getPositionY(dataItem, key, location, stackKey, range);\r\n        if ($type.isNaN(position)) {\r\n            return this.basePoint.y;\r\n        }\r\n        else {\r\n            return this.renderer.positionToPoint(position).y;\r\n        }\r\n    };\r\n    /**\r\n     * Returns relative position on axis for series' data item.\r\n     *\r\n     * @since 4.5.14\r\n     * @param  dataItem  Data item\r\n     * @param  key       Category\r\n     * @param  location  Location (0-1)\r\n     * @return           Relative position\r\n     */\r\n    CategoryAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\r\n        var position;\r\n        if ($type.hasValue(key)) {\r\n            position = this.categoryToPosition(dataItem.categories[key], location);\r\n        }\r\n        if (range) {\r\n            position = $math.fitToRange(position, range.start, range.end);\r\n        }\r\n        return position;\r\n    };\r\n    /**\r\n     * Returns an angle for series data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param dataItem  Data item\r\n     * @param key       Category\r\n     * @param location  Location (0-1)\r\n     * @param stackKey  Stack key (?)\r\n     * @param range Range to fit in\r\n     * @return Angle\r\n     */\r\n    CategoryAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\r\n        var position = this.categoryToPosition(dataItem.categories[key], location);\r\n        if (range) {\r\n            position = $math.fitToRange(position, range.start, range.end);\r\n        }\r\n        return this.positionToAngle(position);\r\n    };\r\n    /**\r\n     * Returns an absolute pixel coordinate of the start of the cell (category),\r\n     * that specific position value falls into.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param position  Position (px)\r\n     * @return Cell start position (px)\r\n     */\r\n    CategoryAxis.prototype.getCellStartPosition = function (position) {\r\n        return this.roundPosition(position, 0);\r\n    };\r\n    /**\r\n     * Returns an absolute pixel coordinate of the end of the cell (category),\r\n     * that specific position value falls into.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param position  Position (px)\r\n     * @return Cell end position (px)\r\n     */\r\n    CategoryAxis.prototype.getCellEndPosition = function (position) {\r\n        return this.roundPosition(position, 1);\r\n    };\r\n    /**\r\n     * Returns text to show in a category tooltip, based on specific position\r\n     * within axis.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param position  Position (px)\r\n     * @return Label (category)\r\n     */\r\n    CategoryAxis.prototype.getTooltipText = function (position) {\r\n        var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\r\n        if (dataItem) {\r\n            this.tooltipDataItem = dataItem;\r\n            this.tooltip.dataItem = dataItem;\r\n            if (this.tooltipText) {\r\n                return this.tooltipText;\r\n            }\r\n            if (!this._adapterO) {\r\n                return dataItem.category;\r\n            }\r\n            else {\r\n                return this._adapterO.apply(\"getTooltipText\", dataItem.category);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns an index of the category that corresponds to specific pixel\r\n     * position within axis.\r\n     *\r\n     * @param position  Position (px)\r\n     * @return Category index\r\n     */\r\n    CategoryAxis.prototype.positionToIndex = function (position) {\r\n        position = $math.round(position, 10);\r\n        if (position < 0) {\r\n            position = 0;\r\n        }\r\n        if (position > 1) {\r\n            position = 1;\r\n        }\r\n        var startIndex = this.startIndex;\r\n        var endIndex = this.endIndex;\r\n        var difference = endIndex - startIndex - this.startLocation - (1 - this.endLocation);\r\n        position += 1 / difference * this.startLocation;\r\n        var index = null;\r\n        if (this._axisBreaks) {\r\n            var axisBreaks = this._axisBreaks;\r\n            // in case we have some axis breaks\r\n            $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\r\n                var breakStartPosition = axisBreak.startPosition;\r\n                var breakEndPosition = axisBreak.endPosition;\r\n                var breakStartIndex = axisBreak.adjustedStartValue;\r\n                var breakEndIndex = axisBreak.adjustedEndValue;\r\n                breakStartIndex = $math.max(breakStartIndex, startIndex);\r\n                breakEndIndex = $math.min(breakEndIndex, endIndex);\r\n                var breakSize = axisBreak.breakSize;\r\n                difference -= (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n                // position to the right of break end\r\n                if (position > breakEndPosition) {\r\n                    startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n                }\r\n                // position to the left of break start\r\n                else if (position < breakStartPosition) {\r\n                }\r\n                // value within break\r\n                else {\r\n                    var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\r\n                    index = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n        }\r\n        if (!$type.isNumber(index)) {\r\n            index = Math.floor(position * difference + startIndex);\r\n        }\r\n        if (index >= this.dataItems.length) {\r\n            index = this.dataItems.length - 1;\r\n        }\r\n        // not good, when panning out of bounds, each time one less item gets selected\r\n        //if (index >= endIndex) {\r\n        //\tindex--;\r\n        //}\r\n        return index;\r\n    };\r\n    /**\r\n     * Returns category based on position.\r\n     *\r\n     * Please note that `position` represents position within axis which may be\r\n     * zoomed and not correspond to Cursor's `position`.\r\n     *\r\n     * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n     *\r\n     * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\r\n     *\r\n     * @since 4.3.8\r\n     * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n     * @param position  Relative position on axis (0-1)\r\n     * @return Position label\r\n     */\r\n    CategoryAxis.prototype.positionToCategory = function (position) {\r\n        return this.getPositionLabel(position);\r\n    };\r\n    /**\r\n     * Returns category based on position.\r\n     *\r\n     * Please note that `position` represents position within axis which may be\r\n     * zoomed and not correspond to Cursor's `position`.\r\n     *\r\n     * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n     * @param position  Relative position on axis (0-1)\r\n     * @return Position label\r\n     */\r\n    CategoryAxis.prototype.getPositionLabel = function (position) {\r\n        var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\r\n        if (dataItem) {\r\n            return dataItem.category;\r\n        }\r\n    };\r\n    Object.defineProperty(CategoryAxis.prototype, \"basePoint\", {\r\n        /**\r\n         * Coordinates of the actual axis start.\r\n         *\r\n         * @ignore Exclude from docs\r\n         * @return Base point\r\n         */\r\n        get: function () {\r\n            // This makes base grid to be drawn at the end of the axis and adds extra\r\n            // grid which we need to nicely close the chart.\r\n            return this.renderer.positionToPoint(1);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Initializes Axis' renderer.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    CategoryAxis.prototype.initRenderer = function () {\r\n        _super.prototype.initRenderer.call(this);\r\n        var renderer = this.renderer;\r\n        renderer.baseGrid.disabled = true;\r\n    };\r\n    Object.defineProperty(CategoryAxis.prototype, \"frequency\", {\r\n        /**\r\n         * Current frequency of labels of the axis.\r\n         *\r\n         * Normally it would be 1, but when labels start to be hidden due\r\n         * to `minGridDistance` this read-only property will increase.\r\n         *\r\n         * @readonly\r\n         * @since 4.2.0\r\n         * @return Label frequency\r\n         */\r\n        get: function () {\r\n            return this._frequency;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CategoryAxis.prototype, \"sortBySeries\", {\r\n        /**\r\n         * @return Sort categories?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"sortBySeries\");\r\n        },\r\n        /**\r\n         * If set to a reference of [[ColumnSeries]] the categories will be sorted\r\n         * by actual values.\r\n         *\r\n         * The categories are ordered in descending order (from highest values to\r\n         * lowest). To reverse the order, use axis renderer's `inversed` setting.\r\n         * E.g.:\r\n         *\r\n         * ```TypeScript\r\n         * categoryAxis.sortBySeries = series;\r\n         * categoryAxis.renderer.inversed = true;\r\n         * ```\r\n         * ```JavaScript\r\n         * categoryAxis.sortBySeries = series;\r\n         * categoryAxis.renderer.inversed = true;\r\n         * ```\r\n         * ```JSON\r\n         * {\r\n         *   // ...\r\n         *   \"xAxes\": [{\r\n         *     // ...\r\n         *     \"sortBySeries\": \"s1\",\r\n         *     \"renderer\": {\r\n         *       // ...\r\n         *       \"inversed\": true\r\n         *     }\r\n         *   }]\r\n         * }\r\n         * ```\r\n         *\r\n         * @since 4.8.7\r\n         * @param  value  Sort categories?\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"sortBySeries\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Processes JSON-based config before it is applied to the object.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param config  Config\r\n     */\r\n    CategoryAxis.prototype.processConfig = function (config) {\r\n        if (config) {\r\n            if ($type.hasValue(config.sortBySeries) && $type.isString(config.sortBySeries)) {\r\n                if (this.map.hasKey(config.sortBySeries)) {\r\n                    config.sortBySeries = this.map.getKey(config.sortBySeries);\r\n                }\r\n                else {\r\n                    this.addDelayedMap(\"sortBySeries\", config.sortBySeries);\r\n                    delete config.sortBySeries;\r\n                }\r\n            }\r\n        }\r\n        _super.prototype.processConfig.call(this, config);\r\n    };\r\n    return CategoryAxis;\r\n}(Axis));\r\nexport { CategoryAxis };\r\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\r\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}