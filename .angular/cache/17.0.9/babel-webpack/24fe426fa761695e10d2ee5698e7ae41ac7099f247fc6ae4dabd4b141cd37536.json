{"ast":null,"code":"/**\r\n * Text class deals with all text placed on chart.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Container } from \"../Container\";\nimport { registry } from \"../Registry\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { MultiDisposer } from \"../utils/Disposer\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport * as $math from \"../utils/Math\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\nimport * as $dom from \"../utils/DOM\";\nimport { defaultRules, ResponsiveBreakpoints } from \"../utils/Responsive\";\nimport { options } from \"../Options\";\n;\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Text is used to display highly configurable, data-enabled textual elements.\r\n *\r\n * ## Data Binding\r\n *\r\n * A Text element can dynamically parse and populate its contents with values\r\n * from a [[DataItem]].\r\n *\r\n * To activate such binding, set element's `dataItem` property.\r\n *\r\n * When activated, text contents will be parsed for special tags, e.g.:\r\n *\r\n * ```TypeScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n * ```JavaScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n *\r\n * The above will automatically replace \"{title}\" in the string with the\r\n * actual data value from `myDataItem`.\r\n *\r\n * Note, that most often dataItem is set by the Component.\r\n *\r\n *\r\n * @see {@link ILabelEvents} for a list of available events\r\n * @see {@link ILabelAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding\r\n * @todo Vertical align\r\n * @important\r\n */\nvar Label = /** @class */function (_super) {\n  __extends(Label, _super);\n  /**\r\n   * Constructor\r\n   */\n  function Label() {\n    var _this =\n    // Execute super's constructor\n    _super.call(this) || this;\n    /**\r\n     * Indicates if the whole text does not fit into max dimenstions set for it.\r\n     */\n    _this.isOversized = false;\n    // Set this class name\n    _this.className = \"Label\";\n    _this.fill = new InterfaceColorSet().getFor(\"text\");\n    // not good to set this, as then these will appear on each label and values set on container won't be applied.\n    //this.textDecoration = \"none\";\n    //this.fontWeight = \"normal\";\n    // Set defaults\n    _this.wrap = false;\n    _this.truncate = false;\n    _this.fullWords = true;\n    _this.ellipsis = \"â€¦\";\n    _this.textAlign = \"start\";\n    _this.textValign = \"top\";\n    _this.layout = \"absolute\";\n    _this.baseLineRatio = -0.27;\n    //this.pixelPerfect = true;\n    _this._positionPrecision = 1;\n    // Add events to watch for maxWidth/maxHeight changes so that we can\n    // invalidate this\n    _this.events.on(\"maxsizechanged\", function () {\n      if (_this.inited) {\n        _this.handleMaxSize();\n      }\n    }, _this, false);\n    // this solves strange bug when text just added to svg is 0x0\n    _this.events.once(\"validated\", _this.handleValidate, _this, false);\n    // Aply theme\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * A placeholder method that is called **after** element finishes drawing\r\n   * itself.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Label.prototype.afterDraw = function () {\n    // since we removed validatePosition from sprite, we still need it here to handle rotated text\n    _super.prototype.afterDraw.call(this);\n    this.validatePosition();\n  };\n  /**\r\n   * Sets [[Paper]] instance to use to draw elements.\r\n   * @ignore\r\n   * @param paper Paper\r\n   * @return true if paper was changed, false, if it's the same\r\n   */\n  Label.prototype.setPaper = function (paper) {\n    var changed = _super.prototype.setPaper.call(this, paper);\n    if (changed) {\n      this.hardInvalidate();\n    }\n    return changed;\n  };\n  /**\r\n   * @ignore\r\n   */\n  Label.prototype.handleValidate = function () {\n    if ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {\n      registry.events.once(\"exitframe\", this.hardInvalidate, this);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n  Label.prototype.handleMaxSize = function () {\n    if (this.bbox.width > this.availableWidth || this.bbox.width < this.availableWidth && (this.isOversized || this.truncate) || this.bbox.height > this.availableHeight || this.bbox.height < this.availableHeight && this.isOversized) {\n      this.invalidate();\n    } else {\n      //this.alignSVGText();\n    }\n  };\n  /**\r\n   * [arrange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n  Label.prototype.arrange = function () {};\n  /**\r\n   * Updates current text according to data item and supported features.\r\n   * Returns `true` if current text has changed.\r\n   *\r\n   * @return Text changed?\r\n   */\n  Label.prototype.updateCurrentText = function () {\n    // Determine output format\n    var output, text;\n    if ($utils.isNotEmpty(this.html) && this.paper.supportsForeignObject()) {\n      // We favor HTML text if it's set and browser supports `foreignObject`\n      output = \"html\";\n      text = this.html;\n    } else {\n      output = \"svg\";\n      text = this.text;\n    }\n    // Need to toString source?\n    if ($type.isObject(text)) {\n      text = text.toString();\n    }\n    // Need to format text all the time\n    if ($type.hasValue(text) && text !== \"\") {\n      text = this.populateString(text, this.dataItem);\n    }\n    if (output == \"html\") {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"htmlOutput\", text);\n      }\n    } else {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"textOutput\", text);\n      }\n    }\n    // Update the text\n    var changed = text != this.currentText || output != this._currentFormat;\n    this.currentText = text;\n    this._currentFormat = output;\n    return changed;\n  };\n  /**\r\n   * Hard invalidate means the text will be redrawn even if it hasn't changed.\r\n   * This is used when we change `fontSize`, `fontFamily`, or for some other\r\n   * reasons.\r\n   */\n  Label.prototype.hardInvalidate = function () {\n    this._prevStatus = \"\";\n    this.invalidate();\n  };\n  /**\r\n   * Gets line bbox, uses caching to save cpu\r\n   * @ignore\r\n   */\n  Label.prototype.getLineBBox = function (lineInfo) {\n    //let cacheKey = lineInfo.text + lineInfo.style;\n    //let lineBBox = this.getCache(cacheKey);\n    //if (!lineBBox) {\n    //lineBBox = lineInfo.element.getBBox();\n    //if (lineBBox.width != 0 && lineBBox.height != 0) {\n    //\tthis.setCache(cacheKey, lineBBox, 5000);\n    //}\n    //}\n    var element = lineInfo && lineInfo.element;\n    var node = element && element.node;\n    // Check for the parent Node to avoid FF from throwing errors\n    if (node && node.parentNode) {\n      lineInfo.bbox = element.getBBox();\n    }\n  };\n  /**\r\n   * Draws the textual label.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Label.prototype.draw = function () {\n    // Draw super\n    _super.prototype.draw.call(this);\n    var oldW = this.bbox.width;\n    var oldH = this.bbox.height;\n    var topParent = this.topParent;\n    if (topParent) {\n      if (!topParent.maxWidth || !topParent.maxHeight) {\n        topParent.events.once(\"maxsizechanged\", this.hardInvalidate, this, false);\n        return;\n      }\n    }\n    // Calculate max width and height\n    var maxWidth = $math.max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);\n    var maxHeight = $math.max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0);\n    // save\n    var status = maxHeight + \",\" + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis;\n    // Update text\n    if (!this.updateCurrentText() && this.inited && this._prevStatus == status) {\n      return;\n    }\n    this._measuredWidth = 0;\n    this._measuredHeight = 0;\n    // Reset\n    this.isOversized = false;\n    // Determine output format\n    var output = this._currentFormat;\n    var text = this.currentText;\n    // Empty string\n    if (!$type.hasValue(text) || text == \"\") {\n      this.element.attr({\n        display: \"none\"\n      });\n      return;\n    }\n    // Chop up text into lines\n    // We're still processing SVG and HTML in the same way for now\n    var lines = text.split(\"\\n\");\n    // Do we need to go through the trouble of measuring lines\n    //let measure: boolean = true;// (lines.length > 1) || this.wrap;\n    this._prevStatus = status;\n    this.textAlign = this.textAlign;\n    // need this to measure\n    var display = this.group.getAttr(\"display\");\n    if (display == \"none\") {\n      this.group.removeAttr(\"display\");\n    }\n    if (this.textPathElement) {\n      this.textPathElement.removeChildren();\n    }\n    // SVG or HTML?\n    if (output === \"svg\") {\n      /**\r\n       * SVG\r\n       */\n      this.element.removeAttr(\"display\");\n      // Clear the element\n      var group = this.element;\n      //group.removeChildren();\n      this.resetBBox();\n      // Init state variables\n      var currentHeight = 0;\n      var currentFormat = \"\";\n      // Process each line\n      for (var i = 0; i < lines.length; i++) {\n        // Get line\n        var line = lines[i];\n        // Check if line is empty\n        if (line == \"\") {\n          // It is, let's just update currentHeight and go to the next one\n          // If it's the first line, we'll have to use arbirary line height,\n          // since there's nothing to measure. For subsequent lines we can take\n          // previous line's height\n          var tempElement = this.getSVGLineElement(\"\", 0);\n          tempElement.add(this.getSvgElement(\".\", getTextFormatter().translateStyleShortcuts(currentFormat)));\n          group.add(tempElement);\n          var offset = Math.ceil(tempElement.getBBox().height);\n          if (offset > 0) {\n            currentHeight += offset;\n          }\n          group.removeElement(tempElement);\n          // Clear cache if necessary\n          var lineInfo_1 = this.getLineInfo(i);\n          if (lineInfo_1) {\n            lineInfo_1.text = \"\";\n            lineInfo_1.element.textContent = \"\";\n          }\n          continue;\n        }\n        // Chunk up the line and process each chunk\n        var chunks = getTextFormatter().chunk(line, null, this.ignoreFormatting);\n        var currentLineHeight = 0;\n        var firstChunk = true;\n        var skipTextChunks = false;\n        // Create line element or grab it from cache\n        var lineInfo = this.getLineInfo(i);\n        if (lineInfo) {\n          // Empty line\n          lineInfo.text = \"\";\n          lineInfo.element.textContent = \"\";\n        } else {\n          // Init new line info\n          lineInfo = {\n            \"text\": \"\",\n            \"element\": this.getSVGLineElement(\"\", 0),\n            \"complex\": false\n          };\n          // Create the line element\n          //lineInfo.element = this.getSVGLineElement(\"\", 0);\n          //lineElement = this.getSVGLineElement(\"\", 0);\n          group.add(lineInfo.element);\n        }\n        lineInfo.element.removeAttr(\"display\");\n        lineInfo.element.removeChildren(); // memory leak without this\n        if (this.textPathElement) {\n          lineInfo.element.add(this.textPathElement);\n        }\n        /*// @todo not needed anymore\r\n        if (this.rtl) {\r\n            chunks.reverse();\r\n        }*/\n        // Process each chunk\n        for (var x = 0; x < chunks.length; x++) {\n          // If there's more than one chunk, means the line is \"complex\"\n          if (x) {\n            lineInfo.complex = true;\n          }\n          // Get chunk\n          var chunk = chunks[x];\n          // Is this chunk format or text?\n          if (chunk.type === \"format\") {\n            // Log current format, so that we can apply it to multiple lines if\n            // necessary\n            currentFormat = chunk.text;\n          } else {\n            // It's text block\n            // Need to skip?\n            // We do this when truncating. We can't just simply go ahead and\n            // abandon chunk processing as they might have formatting\n            // instructions in them that are relevant for subsequent lines\n            if (skipTextChunks) {\n              continue;\n            }\n            // Add chunk to the current element\n            //lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));\n            lineInfo.text = chunk.text;\n            lineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);\n            if (this.textPathElement) {\n              this.getSvgElement(lineInfo.text, lineInfo.style, this.textPathElement);\n            } else {\n              this.getSvgElement(lineInfo.text, lineInfo.style, lineInfo.element);\n            }\n            this.getLineBBox(lineInfo);\n            lineInfo.bbox.width = Math.ceil(lineInfo.bbox.width);\n            // Updated current line height\n            if (currentLineHeight < lineInfo.bbox.height) {\n              currentLineHeight = lineInfo.bbox.height;\n            }\n            // Wrapping?\n            if ((this.wrap || this.truncate) && lineInfo.bbox.width > maxWidth) {\n              // Set oversized\n              this.isOversized = true;\n              // Take temporary measurements\n              var lineText = lineInfo.element.textContent;\n              var avgCharWidth = lineInfo.bbox.width / lineText.length; // * .9;\n              // Calculate average number of symbols / width\n              var excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\n              // Are we truncating or auto-wrapping text?\n              if (this.truncate) {\n                /**\r\n                 * Processing line truncation\r\n                 * With the addition of each text chunk we measure if current\r\n                 * line does not exceed maxWidth. If it does, we will stop\r\n                 * addition of further chunks as well as try to truncate\r\n                 * current or any number of previous chunks with an added\r\n                 * ellipsis\r\n                 */\n                // Indicator whether we need to add ellipsis to the current\n                // element, even if it fits. This is needed to indicate\n                // whether we have already removed some subsequent chunks in\n                // which case we need to add ellipsis.\n                var addEllipsis = false;\n                // Process each child in the temporary line, until the whole\n                // line fits, preferably with an ellipsis\n                // TODO use iterator instead\n                var node_1 = lineInfo.element.node;\n                if (node_1 && node_1.childNodes) {\n                  for (var e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {\n                    // Get current element\n                    var node_2 = lineInfo.element.node.childNodes[e];\n                    // Add ellipsis only if previous chunk was removed in full\n                    // and this chunk already fits\n                    //if (addEllipsis && (bbox.width <= maxWidth)) {\n                    if (addEllipsis && lineInfo.bbox.width <= maxWidth) {\n                      // Add ellipsis\n                      node_2.textContent += \" \" + this.ellipsis;\n                      // Measure again (we need to make sure ellipsis fits)\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\n                      // If it fits, we're done here\n                      // If it doesn't we continue rolling\n                      if (lineInfo.bbox.width <= maxWidth) {\n                        break;\n                      }\n                    }\n                    addEllipsis = false;\n                    // Get element text\n                    var elementText = node_2.textContent;\n                    // Calculate average number of symbols / width\n                    lineText = lineInfo.element.textContent;\n                    excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\n                    // Do this until we fit\n                    while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                      // Calculate max available chars\n                      var maxChars = $math.max(lineText.length - excessChars - this.ellipsis.length, 1);\n                      // Is there anything left?\n                      if (maxChars <= 1) {\n                        // Nope, let's jump to the previous item\n                        // Set excess characters to zero so that this loop does\n                        // not repeat when it over\n                        excessChars = 0;\n                        // Add ellipsis to previous item\n                        // Subsequent iterations will check if the ellipsis fits\n                        if (e > 0) {\n                          // Indicating to add ellipsis to previous item\n                          addEllipsis = true;\n                          // Removing this node\n                          lineInfo.element.node.removeChild(node_2);\n                        }\n                      }\n                      // Truncate the text\n                      elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);\n                      if (elementText.length > maxChars && this.fullWords) {\n                        // Still too long?\n                        // Let's try truncating breaking words anyway\n                        elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);\n                      }\n                      // Set truncated text\n                      node_2.textContent = elementText;\n                      // Measure again\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\n                      // Increase excess characters count, just in case it still\n                      // doesn't fit and we have to go at it again\n                      excessChars = Math.ceil(excessChars * 1.1);\n                    }\n                    // Do not process further chunks\n                    skipTextChunks = true;\n                  }\n                }\n              } else {\n                /**\r\n                 * Processign auto-wrap\r\n                 * In this case we're going to be adding text chunks until\r\n                 * they don't fit into current line. Once that happens we will\r\n                 * inject the rest of the chunks to the next line\r\n                 */\n                // Get last node added and measure it\n                var node_3 = lineInfo.element.node;\n                if (node_3) {\n                  var lastNode = lineInfo.element.node.lastChild;\n                  // Init split lines\n                  var splitLines = void 0;\n                  while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                    // Calculate max available chars\n                    var maxChars = $math.max(chunk.text.length - excessChars, 1);\n                    // Don't split the words mid-word if it's not the first chunk\n                    // in the line\n                    if (firstChunk) {\n                      // Split mid-word if necessary\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\n                    } else {\n                      // Don't split mid-word\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl, false);\n                      // Check if the first word is too long\n                      if (splitLines[0].length > maxChars || maxChars === 1) {\n                        // Yes - move the whole chunk to the next line\n                        // Remove the element we just added\n                        lineInfo.element.node.removeChild(lastNode);\n                        // Break out of the while on next cycle\n                        excessChars = 0;\n                      }\n                    }\n                    // Use the first line to update last item\n                    if (excessChars > 0) {\n                      var lineText_1 = splitLines.shift();\n                      if (firstChunk) {\n                        lineText_1 = $utils.trim(lineText_1);\n                      }\n                      lastNode.textContent = getTextFormatter().cleanUp(lineText_1);\n                    }\n                    // Measure again, just in case\n                    lineInfo.bbox = lineInfo.element.getBBox();\n                    lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\n                    // Increase excess characters count, just in case it still\n                    // doesn't fit and we have to go at it again\n                    //excessChars = Math.ceil(excessChars * 1.05);\n                    excessChars++;\n                  }\n                  // Construct the rest of the line\n                  if (splitLines.length > 0) {\n                    var restOfLine = \"\";\n                    // Add leftovers from splitting the current chunk\n                    if ($type.hasValue(splitLines)) {\n                      if (this.rtl) {\n                        restOfLine += splitLines.join(\"\") + currentFormat;\n                      } else {\n                        restOfLine += currentFormat + splitLines.join(\"\").replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      }\n                    }\n                    // Add the rest of the chunks\n                    for (var c = x + 1; c < chunks.length; c++) {\n                      if (chunks[c].type == \"value\") {\n                        // We're escaping single square brackets that were\n                        // cleaned up by chunk() back to double square brackets\n                        // so that they are not being treated as format on\n                        // next pass.\n                        restOfLine += chunks[c].text.replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      } else {\n                        restOfLine += chunks[c].text;\n                      }\n                    }\n                    // Inject the rest of the lines as chunks for subsequent\n                    lines.splice(i + 1, 0, restOfLine);\n                  }\n                  // Skip processing the rest of the chunks\n                  skipTextChunks = true;\n                }\n              }\n            }\n            // Let's update the text's bbox with the line's one\n            if (this.bbox.width < lineInfo.bbox.width) {\n              this.bbox.width = lineInfo.bbox.width;\n            }\n            // commented to avoid bug (seen on sankey link) where text is incorrectly aligned\n            //if (this.bbox.x > lineInfo.bbox.x) {\n            //this.bbox.x = lineInfo.bbox.x;\n            //}\n            this.bbox.height = currentHeight + currentLineHeight;\n            // Position current line\n            if (!this.textPathElement) {\n              lineInfo.element.attr({\n                \"x\": \"0\",\n                \"y\": currentHeight + currentLineHeight,\n                \"dy\": $math.round(this.baseLineRatio * currentLineHeight, 3).toString()\n              });\n            } else {\n              lineInfo.element.attr({\n                \"dy\": -this.paddingBottom.toString()\n              });\n            }\n            firstChunk = false;\n          }\n        }\n        // Trim the last item\n        var node = lineInfo.element.node;\n        if (node) {\n          var lastNode = node.lastChild;\n          if (lastNode) {\n            lastNode.textContent = this.rtl ? $utils.ltrim(lastNode.textContent) : $utils.rtrim(lastNode.textContent);\n          }\n        }\n        // Increment collective height\n        currentHeight += currentLineHeight;\n        // Save line cache\n        this.addLineInfo(lineInfo, i);\n      }\n      // Check if maybe we need to hide the whole label if it doesn't fit\n      this.maybeHideOversized();\n      this.measureFailed = false;\n      if (this.bbox.width == 0 || this.bbox.height == 0) {\n        this.measureFailed = true;\n      }\n      // Updated measured dims\n      this._measuredWidth = $math.round($math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));\n      this._measuredHeight = $math.round($math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom));\n      // Align the lines\n      this.alignSVGText();\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight;\n      if (oldH != this._measuredHeight || oldW != this._measuredWidth) {\n        this.dispatch(\"transformed\");\n      }\n      this.hideUnused(lines.length);\n    } else {\n      /**\r\n       * HTML\r\n       */\n      this.element.removeAttr(\"display\");\n      this.resetBBox();\n      // Clear the element\n      var group = this.element;\n      group.removeChildren();\n      this.setCache(\"lineInfo\", [], 0);\n      // Create a ForeignObject to use as HTML container\n      var fo = this.paper.foreignObject();\n      group.add(fo);\n      // Set widths on foreignObject so that autosizing measurements work\n      // This will bet reset to actual content width/height\n      if (this.maxWidth) {\n        fo.attr({\n          width: this.maxWidth - this.pixelPaddingLeft - this.pixelPaddingRight\n        });\n      }\n      if (this.maxHeight) {\n        fo.attr({\n          height: this.maxHeight - this.pixelPaddingTop - this.pixelPaddingBottom\n        });\n      }\n      // Create line element\n      //let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));\n      var lineElement = this.getHTMLLineElement(text);\n      fo.node.appendChild(lineElement);\n      // Temporarily set to inline-block so we can measure real width and height\n      lineElement.style.display = \"inline-block\";\n      var clientWidth = lineElement.clientWidth;\n      var clientHeight = lineElement.clientHeight;\n      lineElement.style.display = \"block\";\n      this._bbox = {\n        x: 0,\n        y: 0,\n        width: clientWidth,\n        height: clientHeight\n      };\n      // Set exact dimensions of foreignObject so it is sized exactly as\n      // the content within (add one pixel to width so it does not wrap)\n      fo.attr({\n        width: clientWidth + 1,\n        height: clientHeight\n      });\n      // Check if maybe we need to hide the whole label if it doesn't fit\n      this.maybeHideOversized();\n      // Set measurements and update bbox\n      this._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\n      this._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight;\n      // Don't let labels bleed out of the alotted area\n      if (this.truncate) {\n        lineElement.style.overflow = \"hidden\";\n      }\n      if (clientWidth > maxWidth || clientHeight > maxHeight) {\n        this.isOversized = true;\n      }\n    }\n    // Set applicable styles\n    this.setStyles();\n    this.updateCenter();\n    this.updateBackground();\n    if (display == \"none\") {\n      this.group.attr({\n        display: \"none\"\n      });\n    }\n    if (this.pathElement) {\n      this.paper.appendDef(this.pathElement);\n    }\n  };\n  /**\r\n   * Hides element if it does not fit into available space\r\n   */\n  Label.prototype.maybeHideOversized = function () {\n    if (this.hideOversized) {\n      if (this.availableWidth < this.bbox.width || this.availableHeight < this.bbox.height) {\n        this.element.attr({\n          display: \"none\"\n        });\n        this.isOversized = true;\n      } else {\n        this.element.removeAttr(\"display\");\n        this.isOversized = false;\n      }\n    }\n  };\n  /**\r\n   * Aligns the lines horizontally and vertically, based on properties.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Label.prototype.alignSVGText = function () {\n    // Get Group\n    var group = this.element;\n    var children = group.node.children || group.node.childNodes;\n    // Is there anything to align?\n    if (!children || children && children.length == 0) {\n      return;\n    }\n    var width = this._measuredWidth;\n    var height = this._measuredHeight;\n    // TODO maybe these aren't needed ?\n    $utils.used(this.pixelPaddingLeft);\n    $utils.used(this.pixelPaddingRight);\n    $utils.used(this.pixelPaddingTop);\n    $utils.used(this.pixelPaddingBottom);\n    if (this.rtl) {\n      group.attr({\n        \"direction\": \"rtl\"\n      });\n    } else {\n      group.removeAttr(\"direction\");\n    }\n    // Process each line\n    //$iter.each(group.children.backwards().iterator(), (element) => {\n    for (var i = children.length - 1; i >= 0; i--) {\n      // Align horizontally\n      // Since we are using `text-anchor` for horizontal alignment, all we need\n      // to do here is move the `x` position\n      var node = children[i];\n      node.setAttribute(\"text-anchor\", this.textAlign);\n      if (this.textPathElement) {\n        node.removeAttribute(\"x\");\n        node.removeAttribute(\"y\");\n      } else {\n        switch (this.textAlign) {\n          case \"middle\":\n            node.setAttribute(\"x\", (width / 2).toString() + \"px\");\n            break;\n          case \"end\":\n            if (this.rtl) {} else {\n              node.setAttribute(\"x\", width.toString());\n            }\n            break;\n          default:\n            if (this.rtl) {\n              node.setAttribute(\"x\", width.toString());\n            } else {\n              node.removeAttribute(\"text-anchor\");\n            }\n            break;\n        }\n        var y = $type.toNumber(node.getAttribute(\"y\"));\n        switch (this.textValign) {\n          case \"middle\":\n            node.setAttribute(\"y\", ((y || 0) + (height - this.bbox.height) / 2).toString());\n            break;\n          case \"bottom\":\n            node.setAttribute(\"y\", ((y || 0) + height - this.bbox.height).toString());\n            break;\n          default:\n            node.setAttribute(\"y\", (y || 0).toString());\n            break;\n        }\n      }\n    }\n  };\n  /**\r\n   * Produces an SVG line element with formatted text.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text    Text to wrap into line\r\n   * @param y       Current line vertical position\r\n   * @return A DOM element\r\n   * @todo Implement HTML support\r\n   */\n  Label.prototype.getSVGLineElement = function (text, y) {\n    // Create a <text> node and set text\n    var element = this.paper.addGroup(\"text\");\n    element.textContent = text;\n    // Set parameters\n    element.attr({\n      \"x\": \"0\"\n      //\"alignment-baseline\": \"hanging\",\n      //\"baseline-shift\": \"-20%\",\n      //\"text-anchor\": \"center\"\n    });\n    // Set `y` position\n    if ($type.hasValue(y)) {\n      element.attr({\n        \"y\": y.toString()\n      });\n    }\n    // Don't let labels blled out of the alotted area\n    if (this.truncate || this.wrap) {\n      element.attr({\n        \"overflow\": \"hidden\"\n      });\n    }\n    // Add RTL?\n    // This has now been moved to this.alignSVGText()\n    // if (this.rtl) {\n    // \telement.attr({\n    // \t\t\"direction\": \"rtl\",\n    // \t\t//\"unicode-bidi\": \"bidi-override\"\n    // \t});\n    // }\n    return element;\n  };\n  Object.defineProperty(Label.prototype, \"rtl\", {\n    /**\r\n     * @return RTL?\r\n     */\n    get: function () {\n      if ($type.hasValue(this._rtl)) {\n        return this._rtl;\n      } else if (this._topParent) {\n        return this._topParent.rtl;\n      }\n      return false;\n    },\n    /**\r\n     * An RTL (right-to-left) setting.\r\n     *\r\n     * RTL may affect alignment, text, and other visual properties.\r\n     *\r\n     * If you set this on a top-level chart object, it will be used for all\r\n     * child elements, e.g. labels, unless they have their own `rtl` setting\r\n     * set directly on them.\r\n     *\r\n     * @param value  `true` for to use RTL\r\n     */\n    set: function (value) {\n      value = $type.toBoolean(value);\n      this._rtl = value;\n      if (this.element) {\n        this.alignSVGText();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Resets cached BBox.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Label.prototype.resetBBox = function () {\n    this._bbox = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  };\n  /**\r\n   * Creates and returns an HTML line element (`<div>`).\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Text to add\r\n   * @return `<div>` element reference\r\n   */\n  Label.prototype.getHTMLLineElement = function (text) {\n    // Create the <div> element\n    var div = document.createElement(\"div\");\n    div.innerHTML = text;\n    // Set text alignment\n    switch (this.textAlign) {\n      case \"middle\":\n        div.style.textAlign = \"center\";\n        break;\n      case \"end\":\n        div.style.textAlign = \"right\";\n        break;\n    }\n    // Disable or enable wrapping\n    if (this.wrap) {\n      div.style.wordWrap = \"break-word\";\n    } else {\n      div.style.whiteSpace = \"nowrap\";\n    }\n    // Don't let labels bleed out of the alotted area\n    // Moved to `draw()` because setting \"hidden\" kills all measuring\n    /*if (this.truncate) {\r\n        div.style.overflow = \"hidden\";\r\n    }*/\n    // Set RTL-related styles\n    if (this.rtl) {\n      div.style.direction = \"rtl\";\n      //div.style.unicodeBidi = \"bidi-override\";\n    }\n    // Translate some of the SVG styles into CSS\n    if ($type.hasValue(this.fill)) {\n      div.style.color = this.fill.toString();\n    }\n    return div;\n  };\n  /**\r\n   * Applies specific styles to text to make it not selectable, unless it is\r\n   * explicitly set as `selectable`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Set styles via AMElement\r\n   */\n  Label.prototype.setStyles = function () {\n    var group = this.element;\n    if (!this.selectable || this.draggable || this.resizable || this.swipeable) {\n      group.addStyle({\n        \"webkitUserSelect\": \"none\",\n        \"msUserSelect\": \"none\"\n      });\n    } else if (this.selectable) {\n      group.removeStyle(\"webkitUserSelect\");\n      group.removeStyle(\"msUserSelect\");\n    }\n  };\n  /**\r\n   * Hides unused lines\r\n   */\n  Label.prototype.hideUnused = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n    if (lines.length >= index) {\n      for (var i = index; i < lines.length; i++) {\n        var line = lines[i];\n        if (line && line.element) {\n          line.element.attr({\n            \"display\": \"none\"\n          });\n        }\n      }\n    }\n  };\n  Object.defineProperty(Label.prototype, \"text\", {\n    /**\r\n     * @return SVG text\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"text\");\n    },\n    /**\r\n     * An SVG text.\r\n     *\r\n     * Please note that setting `html` will override this setting if browser\r\n     * supports `foreignObject` in SGV, such as most modern browsers excluding\r\n     * IEs.\r\n     *\r\n     * @param value  SVG Text\r\n     */\n    set: function (value) {\n      //this.setPropertyValue(\"html\", undefined);\n      this.setPropertyValue(\"text\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"path\", {\n    /**\r\n     * @return Path\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"path\");\n    },\n    /**\r\n     * An SVG path string to position text along. If set, the text will follow\r\n     * the curvature of the path.\r\n     *\r\n     * Location along the path can be set using `locationOnPath`.\r\n     *\r\n     * IMPORTANT: Only SVG text can be put on path. If you are using HTML text\r\n     * this setting will be ignored.\r\n     *\r\n     * @since 4.1.2\r\n     * @param  value  Path\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"path\", value, true)) {\n        if (this.pathElement) {\n          this.pathElement.dispose();\n        }\n        if (this.textPathElement) {\n          this.textPathElement.dispose();\n        }\n        this.pathElement = this.paper.add(\"path\");\n        this.pathElement.attr({\n          \"d\": value\n        });\n        this.pathElement.attr({\n          \"id\": \"text-path-\" + this.uid\n        });\n        this._disposers.push(this.pathElement);\n        this.textPathElement = this.paper.addGroup(\"textPath\");\n        this.textPathElement.attrNS($dom.XLINK, \"xlink:href\", \"#text-path-\" + this.uid);\n        // TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed\n        this.textPathElement.attr({\n          \"path\": value\n        });\n        this._disposers.push(this.textPathElement);\n        this.hardInvalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"locationOnPath\", {\n    /**\r\n     * @return Relatvie location on path\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"locationOnPath\");\n    },\n    /**\r\n     * Relative label location on `path`. Value range is from 0 (beginning)\r\n     * to 1 (end).\r\n     *\r\n     * Works only if you set `path` setting to an SVG path.\r\n     *\r\n     * @since 4.1.2\r\n     * @default 0\r\n     * @param  value  Relatvie location on path\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"locationOnPath\", value);\n      if (this.textPathElement) {\n        this.textPathElement.attr({\n          \"startOffset\": value * 100 + \"%\"\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"baseLineRatio\", {\n    /**\r\n     * @return Base line ratio\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"baseLineRatio\");\n    },\n    /**\r\n     * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n     * the label.\r\n     *\r\n     * @since 4.4.2\r\n     * @default -0.27\r\n     * @param  value  Base line ratio\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"baseLineRatio\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"wrap\", {\n    /**\r\n     * @return Auto-wrap enabled or not\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"wrap\");\n    },\n    /**\r\n     * Enables or disables autowrapping of text.\r\n     *\r\n     * @param value  Auto-wrapping enabled\r\n     */\n    set: function (value) {\n      this.resetBBox();\n      this.setPropertyValue(\"wrap\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"truncate\", {\n    /**\r\n     * @return Truncate text?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"truncate\");\n    },\n    /**\r\n     * Indicates if text lines need to be truncated if they do not fit, using\r\n     * configurable `ellipsis` string.\r\n     *\r\n     * `truncate` overrides `wrap` if both are set to `true`.\r\n     *\r\n     * NOTE: For HTML text, this setting **won't** trigger a parser and actual\r\n     * line truncation with ellipsis. It will just hide everything that goes\r\n     * outside the label.\r\n     *\r\n     * @param value  trincate text?\r\n     */\n    set: function (value) {\n      this.resetBBox();\n      this.setPropertyValue(\"truncate\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"fullWords\", {\n    /**\r\n     * @return Truncate on full words?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"fullWords\");\n    },\n    /**\r\n     * If `truncate` is enabled, should Label try to break only on full words\r\n     * (`true`), or whenever needed, including middle of the word. (`false`)\r\n     *\r\n     * @default true\r\n     * @param value  Truncate on full words?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"fullWords\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ellipsis\", {\n    /**\r\n     * @return Ellipsis string\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"ellipsis\");\n    },\n    /**\r\n     * Ellipsis character to use if `truncate` is enabled.\r\n     *\r\n     * @param value Ellipsis string\r\n     * @default \"...\"\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"ellipsis\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"selectable\", {\n    /**\r\n     * @return Text selectable?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"selectable\");\n    },\n    /**\r\n     * Forces the text to be selectable. This setting will be ignored if the\r\n     * object has some kind of interaction attached to it, such as it is\r\n     * `draggable`, `swipeable`, `resizable`.\r\n     *\r\n     * @param value  Text selectable?\r\n     * @default false\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"selectable\", value, true);\n      this.setStyles();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textAlign\", {\n    /**\r\n     * @return Alignment\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"textAlign\");\n    },\n    /**\r\n     * Horizontal text alignment.\r\n     *\r\n     * Available choices:\r\n     * * \"start\"\r\n     * * \"middle\"\r\n     * * \"end\"\r\n     *\r\n     * @param value  Alignment\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"textAlign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textValign\", {\n    /**\r\n     * @ignore Exclude from docs (not used)\r\n     * @return Alignment\r\n     * @deprecated\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"textValign\");\n    },\n    /**\r\n     * Vertical text alignment.\r\n     *\r\n     * @ignore Exclude from docs (not used)\r\n     * @param value  Alignment\r\n     * @deprecated\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"textValign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"html\", {\n    /**\r\n     * @return HTML content\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"html\");\n    },\n    /**\r\n     * Raw HTML to be used as text.\r\n     *\r\n     * NOTE: HTML text is subject to browser support. It relies on browsers\r\n     * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not\r\n     * support it. On those browsers, the text will fall back to basic SVG text,\r\n     * striping out all HTML markup and styling that goes with it.\r\n     *\r\n     * For more information about `foreignObject` and its browser compatibility\r\n     * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).\r\n     *\r\n     * @param value HTML text\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"html\", value, true);\n      if (!$type.hasValue(value)) {\n        var group = this.element;\n        group.removeChildrenByTag(\"foreignObject\");\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Label.prototype.setFill = function (value) {\n    _super.prototype.setFill.call(this, value);\n    if (this.html) {\n      var group = this.element;\n      var divs = group.node.getElementsByTagName(\"div\");\n      for (var i = 0; i < divs.length; i++) {\n        var div = divs[i];\n        if ($type.hasValue(this.fill)) {\n          div.style.color = this.fill.toString();\n        }\n      }\n    }\n  };\n  Object.defineProperty(Label.prototype, \"hideOversized\", {\n    /**\r\n     * @return Hide if text does not fit?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"hideOversized\");\n    },\n    /**\r\n     * Indicates whether the whole text should be hidden if it does not fit into\r\n     * its allotted space.\r\n     *\r\n     * @param value  Hide if text does not fit?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"hideOversized\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ignoreFormatting\", {\n    /**\r\n     * @return Ignore formatting?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"ignoreFormatting\");\n    },\n    /**\r\n     * If set to `true` square-bracket formatting blocks will be treated as\r\n     * regular text.\r\n     *\r\n     * @default false\r\n     * @param value  Ignore formatting?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"ignoreFormatting\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Override `mesaureElement` so it does not get measure again, because\r\n   * internal `_bbox` is being updated by measuring routines in Text itself.\r\n   */\n  Label.prototype.measureElement = function () {};\n  /**\r\n   * Returns information about a line element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param index  Line index\r\n   * @return Line info object\r\n   */\n  Label.prototype.getLineInfo = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n    return lines.length > index ? lines[index] : undefined;\n  };\n  /**\r\n   * Adds a line to line info cache.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param line     Line info object\r\n   * @param index    Insert at specified index\r\n   */\n  Label.prototype.addLineInfo = function (line, index) {\n    this.initLineCache();\n    this.getCache(\"lineInfo\")[index] = line;\n  };\n  /**\r\n   * Checks if line cache is initialized and initializes it.\r\n   */\n  Label.prototype.initLineCache = function () {\n    if (!$type.hasValue(this.getCache(\"lineInfo\"))) {\n      this.setCache(\"lineInfo\", [], 0);\n    }\n  };\n  /**\r\n   * Sets a [[DataItem]] to use for populating dynamic sections of the text.\r\n   *\r\n   * Check the description for [[Text]] class, for data binding.\r\n   *\r\n   * @param dataItem Data item\r\n   */\n  Label.prototype.setDataItem = function (dataItem) {\n    if (this._sourceDataItemEvents) {\n      this._sourceDataItemEvents.dispose();\n    }\n    if (dataItem) {\n      this._sourceDataItemEvents = new MultiDisposer([dataItem.events.on(\"valuechanged\", this.invalidate, this, false), dataItem.events.on(\"workingvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"calculatedvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"propertychanged\", this.invalidate, this, false)]);\n    }\n    _super.prototype.setDataItem.call(this, dataItem);\n  };\n  Object.defineProperty(Label.prototype, \"availableWidth\", {\n    /**\r\n     * Returns available horizontal space.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Available width (px)\r\n     */\n    get: function () {\n      return $type.hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"availableHeight\", {\n    /**\r\n     * Returns available vertical space.\r\n     *\r\n     * @return Available height (px)\r\n     */\n    get: function () {\n      return $type.hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  // temp, replacing textFormatter method\n  Label.prototype.getSvgElement = function (text, style, parent) {\n    var element = this.paper.add(\"tspan\");\n    element.textContent = text;\n    if (style) {\n      if (options.nonce && parent) {\n        //element.node.setAttribute(\"nonce\", \"test123\");\n        var classid = \"amcharts_element_style_\" + btoa(style).replace(/[^\\w]*/g, \"\");\n        element.node.setAttribute(\"class\", classid);\n        var defs = document.createElementNS($dom.SVGNS, \"defs\");\n        parent.node.appendChild(defs);\n        var e = document.createElement(\"style\");\n        e.type = \"text/css\";\n        e.innerHTML = \".\" + classid + \" { \" + style + \"}\";\n        e.setAttribute(\"nonce\", options.nonce);\n        defs.appendChild(e);\n      } else {\n        element.node.setAttribute(\"style\", style);\n      }\n    }\n    if (parent) {\n      parent.add(element);\n    }\n    return element;\n  };\n  /**\r\n   * Invalidates the whole element, including layout AND all its child\r\n   * elements.\r\n   */\n  Label.prototype.deepInvalidate = function () {\n    _super.prototype.deepInvalidate.call(this);\n    this.hardInvalidate();\n  };\n  Object.defineProperty(Label.prototype, \"readerTitle\", {\n    /**\r\n     * @return Title\r\n     */\n    get: function () {\n      var title = this.getPropertyValue(\"readerTitle\");\n      if (!title) {\n        title = this.populateString($utils.plainText($utils.isNotEmpty(this.html) ? this.html : this.text));\n      } else if (this.dataItem) {\n        title = this.populateString(title);\n      }\n      return title;\n    },\n    /**\r\n     * Screen reader title of the element.\r\n     *\r\n     * @param value Title\r\n     */\n    set: function (value) {\n      value = $type.toText(value);\n      if (this.setPropertyValue(\"readerTitle\", value)) {\n        this.applyAccessibility();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Label;\n}(Container);\nexport { Label };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"Label\"] = Label;\n/**\r\n * Add default responsive rules\r\n */\n/**\r\n * Hide labels added directly to chart, like titles if chart is short.\r\n */\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.heightXS,\n  state: function (target, stateId) {\n    if (target instanceof Label && target.parent && target.parent.isBaseSprite) {\n      var state = target.states.create(stateId);\n      state.properties.disabled = true;\n      return state;\n    }\n    return null;\n  }\n});","map":{"version":3,"names":["__extends","Container","registry","getTextFormatter","MultiDisposer","InterfaceColorSet","$math","$utils","$type","$dom","defaultRules","ResponsiveBreakpoints","options","Label","_super","_this","call","isOversized","className","fill","getFor","wrap","truncate","fullWords","ellipsis","textAlign","textValign","layout","baseLineRatio","_positionPrecision","events","on","inited","handleMaxSize","once","handleValidate","applyTheme","prototype","afterDraw","validatePosition","setPaper","paper","changed","hardInvalidate","currentText","text","bbox","width","height","availableWidth","availableHeight","invalidate","arrange","updateCurrentText","output","isNotEmpty","html","supportsForeignObject","isObject","toString","hasValue","populateString","dataItem","_adapterO","apply","_currentFormat","_prevStatus","getLineBBox","lineInfo","element","node","parentNode","getBBox","draw","oldW","oldH","topParent","maxWidth","maxHeight","max","pixelPaddingLeft","pixelPaddingRight","pixelPaddingTop","pixelPaddingBottom","status","rtl","_measuredWidth","_measuredHeight","attr","display","lines","split","group","getAttr","removeAttr","textPathElement","removeChildren","resetBBox","currentHeight","currentFormat","i","length","line","tempElement","getSVGLineElement","add","getSvgElement","translateStyleShortcuts","offset","Math","ceil","removeElement","lineInfo_1","getLineInfo","textContent","chunks","chunk","ignoreFormatting","currentLineHeight","firstChunk","skipTextChunks","x","complex","type","style","lineText","avgCharWidth","excessChars","min","addEllipsis","node_1","childNodes","e","node_2","floor","elementText","maxChars","removeChild","truncateWithEllipsis","node_3","lastNode","lastChild","splitLines","splitTextByCharCount","lineText_1","shift","trim","cleanUp","restOfLine","join","replace","c","splice","round","paddingBottom","ltrim","rtrim","addLineInfo","maybeHideOversized","measureFailed","pixelWidth","pixelHeight","alignSVGText","dispatch","hideUnused","setCache","fo","foreignObject","lineElement","getHTMLLineElement","appendChild","clientWidth","clientHeight","_bbox","y","overflow","setStyles","updateCenter","updateBackground","pathElement","appendDef","hideOversized","children","used","setAttribute","removeAttribute","toNumber","getAttribute","addGroup","Object","defineProperty","get","_rtl","_topParent","set","value","toBoolean","enumerable","configurable","div","document","createElement","innerHTML","wordWrap","whiteSpace","direction","color","selectable","draggable","resizable","swipeable","addStyle","removeStyle","index","initLineCache","getCache","getPropertyValue","setPropertyValue","dispose","uid","_disposers","push","attrNS","XLINK","removeChildrenByTag","setFill","divs","getElementsByTagName","measureElement","undefined","setDataItem","_sourceDataItemEvents","parent","nonce","classid","btoa","defs","createElementNS","SVGNS","deepInvalidate","title","plainText","toText","applyAccessibility","registeredClasses","relevant","heightXS","state","target","stateId","isBaseSprite","states","create","properties","disabled"],"sources":["D:/alodelivery test/node_modules/@amcharts/amcharts4/.internal/core/elements/Label.js"],"sourcesContent":["/**\r\n * Text class deals with all text placed on chart.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container } from \"../Container\";\r\nimport { registry } from \"../Registry\";\r\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\r\nimport { MultiDisposer } from \"../utils/Disposer\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\nimport * as $dom from \"../utils/DOM\";\r\nimport { defaultRules, ResponsiveBreakpoints } from \"../utils/Responsive\";\r\nimport { options } from \"../Options\";\r\n;\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Text is used to display highly configurable, data-enabled textual elements.\r\n *\r\n * ## Data Binding\r\n *\r\n * A Text element can dynamically parse and populate its contents with values\r\n * from a [[DataItem]].\r\n *\r\n * To activate such binding, set element's `dataItem` property.\r\n *\r\n * When activated, text contents will be parsed for special tags, e.g.:\r\n *\r\n * ```TypeScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n * ```JavaScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n *\r\n * The above will automatically replace \"{title}\" in the string with the\r\n * actual data value from `myDataItem`.\r\n *\r\n * Note, that most often dataItem is set by the Component.\r\n *\r\n *\r\n * @see {@link ILabelEvents} for a list of available events\r\n * @see {@link ILabelAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding\r\n * @todo Vertical align\r\n * @important\r\n */\r\nvar Label = /** @class */ (function (_super) {\r\n    __extends(Label, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function Label() {\r\n        var _this = \r\n        // Execute super's constructor\r\n        _super.call(this) || this;\r\n        /**\r\n         * Indicates if the whole text does not fit into max dimenstions set for it.\r\n         */\r\n        _this.isOversized = false;\r\n        // Set this class name\r\n        _this.className = \"Label\";\r\n        _this.fill = new InterfaceColorSet().getFor(\"text\");\r\n        // not good to set this, as then these will appear on each label and values set on container won't be applied.\r\n        //this.textDecoration = \"none\";\r\n        //this.fontWeight = \"normal\";\r\n        // Set defaults\r\n        _this.wrap = false;\r\n        _this.truncate = false;\r\n        _this.fullWords = true;\r\n        _this.ellipsis = \"â€¦\";\r\n        _this.textAlign = \"start\";\r\n        _this.textValign = \"top\";\r\n        _this.layout = \"absolute\";\r\n        _this.baseLineRatio = -0.27;\r\n        //this.pixelPerfect = true;\r\n        _this._positionPrecision = 1;\r\n        // Add events to watch for maxWidth/maxHeight changes so that we can\r\n        // invalidate this\r\n        _this.events.on(\"maxsizechanged\", function () {\r\n            if (_this.inited) {\r\n                _this.handleMaxSize();\r\n            }\r\n        }, _this, false);\r\n        // this solves strange bug when text just added to svg is 0x0\r\n        _this.events.once(\"validated\", _this.handleValidate, _this, false);\r\n        // Aply theme\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    /**\r\n     * A placeholder method that is called **after** element finishes drawing\r\n     * itself.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Label.prototype.afterDraw = function () {\r\n        // since we removed validatePosition from sprite, we still need it here to handle rotated text\r\n        _super.prototype.afterDraw.call(this);\r\n        this.validatePosition();\r\n    };\r\n    /**\r\n     * Sets [[Paper]] instance to use to draw elements.\r\n     * @ignore\r\n     * @param paper Paper\r\n     * @return true if paper was changed, false, if it's the same\r\n     */\r\n    Label.prototype.setPaper = function (paper) {\r\n        var changed = _super.prototype.setPaper.call(this, paper);\r\n        if (changed) {\r\n            this.hardInvalidate();\r\n        }\r\n        return changed;\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Label.prototype.handleValidate = function () {\r\n        if ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {\r\n            registry.events.once(\"exitframe\", this.hardInvalidate, this);\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Label.prototype.handleMaxSize = function () {\r\n        if ((this.bbox.width > this.availableWidth)\r\n            || ((this.bbox.width < this.availableWidth) && (this.isOversized || this.truncate))\r\n            || (this.bbox.height > this.availableHeight)\r\n            || ((this.bbox.height < this.availableHeight) && this.isOversized)) {\r\n            this.invalidate();\r\n        }\r\n        else {\r\n            //this.alignSVGText();\r\n        }\r\n    };\r\n    /**\r\n     * [arrange description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\r\n    Label.prototype.arrange = function () {\r\n    };\r\n    /**\r\n     * Updates current text according to data item and supported features.\r\n     * Returns `true` if current text has changed.\r\n     *\r\n     * @return Text changed?\r\n     */\r\n    Label.prototype.updateCurrentText = function () {\r\n        // Determine output format\r\n        var output, text;\r\n        if ($utils.isNotEmpty(this.html) && this.paper.supportsForeignObject()) {\r\n            // We favor HTML text if it's set and browser supports `foreignObject`\r\n            output = \"html\";\r\n            text = this.html;\r\n        }\r\n        else {\r\n            output = \"svg\";\r\n            text = this.text;\r\n        }\r\n        // Need to toString source?\r\n        if ($type.isObject(text)) {\r\n            text = text.toString();\r\n        }\r\n        // Need to format text all the time\r\n        if ($type.hasValue(text) && text !== \"\") {\r\n            text = this.populateString(text, this.dataItem);\r\n        }\r\n        if (output == \"html\") {\r\n            if (this._adapterO) {\r\n                text = this._adapterO.apply(\"htmlOutput\", text);\r\n            }\r\n        }\r\n        else {\r\n            if (this._adapterO) {\r\n                text = this._adapterO.apply(\"textOutput\", text);\r\n            }\r\n        }\r\n        // Update the text\r\n        var changed = text != this.currentText || output != this._currentFormat;\r\n        this.currentText = text;\r\n        this._currentFormat = output;\r\n        return changed;\r\n    };\r\n    /**\r\n     * Hard invalidate means the text will be redrawn even if it hasn't changed.\r\n     * This is used when we change `fontSize`, `fontFamily`, or for some other\r\n     * reasons.\r\n     */\r\n    Label.prototype.hardInvalidate = function () {\r\n        this._prevStatus = \"\";\r\n        this.invalidate();\r\n    };\r\n    /**\r\n     * Gets line bbox, uses caching to save cpu\r\n     * @ignore\r\n     */\r\n    Label.prototype.getLineBBox = function (lineInfo) {\r\n        //let cacheKey = lineInfo.text + lineInfo.style;\r\n        //let lineBBox = this.getCache(cacheKey);\r\n        //if (!lineBBox) {\r\n        //lineBBox = lineInfo.element.getBBox();\r\n        //if (lineBBox.width != 0 && lineBBox.height != 0) {\r\n        //\tthis.setCache(cacheKey, lineBBox, 5000);\r\n        //}\r\n        //}\r\n        var element = lineInfo && lineInfo.element;\r\n        var node = element && element.node;\r\n        // Check for the parent Node to avoid FF from throwing errors\r\n        if (node && node.parentNode) {\r\n            lineInfo.bbox = element.getBBox();\r\n        }\r\n    };\r\n    /**\r\n     * Draws the textual label.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Label.prototype.draw = function () {\r\n        // Draw super\r\n        _super.prototype.draw.call(this);\r\n        var oldW = this.bbox.width;\r\n        var oldH = this.bbox.height;\r\n        var topParent = this.topParent;\r\n        if (topParent) {\r\n            if (!topParent.maxWidth || !topParent.maxHeight) {\r\n                topParent.events.once(\"maxsizechanged\", this.hardInvalidate, this, false);\r\n                return;\r\n            }\r\n        }\r\n        // Calculate max width and height\r\n        var maxWidth = $math.max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);\r\n        var maxHeight = $math.max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0);\r\n        // save\r\n        var status = maxHeight + \",\" + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis;\r\n        // Update text\r\n        if (!this.updateCurrentText() && this.inited && this._prevStatus == status) {\r\n            return;\r\n        }\r\n        this._measuredWidth = 0;\r\n        this._measuredHeight = 0;\r\n        // Reset\r\n        this.isOversized = false;\r\n        // Determine output format\r\n        var output = this._currentFormat;\r\n        var text = this.currentText;\r\n        // Empty string\r\n        if (!$type.hasValue(text) || text == \"\") {\r\n            this.element.attr({ display: \"none\" });\r\n            return;\r\n        }\r\n        // Chop up text into lines\r\n        // We're still processing SVG and HTML in the same way for now\r\n        var lines = text.split(\"\\n\");\r\n        // Do we need to go through the trouble of measuring lines\r\n        //let measure: boolean = true;// (lines.length > 1) || this.wrap;\r\n        this._prevStatus = status;\r\n        this.textAlign = this.textAlign;\r\n        // need this to measure\r\n        var display = this.group.getAttr(\"display\");\r\n        if (display == \"none\") {\r\n            this.group.removeAttr(\"display\");\r\n        }\r\n        if (this.textPathElement) {\r\n            this.textPathElement.removeChildren();\r\n        }\r\n        // SVG or HTML?\r\n        if (output === \"svg\") {\r\n            /**\r\n             * SVG\r\n             */\r\n            this.element.removeAttr(\"display\");\r\n            // Clear the element\r\n            var group = this.element;\r\n            //group.removeChildren();\r\n            this.resetBBox();\r\n            // Init state variables\r\n            var currentHeight = 0;\r\n            var currentFormat = \"\";\r\n            // Process each line\r\n            for (var i = 0; i < lines.length; i++) {\r\n                // Get line\r\n                var line = lines[i];\r\n                // Check if line is empty\r\n                if (line == \"\") {\r\n                    // It is, let's just update currentHeight and go to the next one\r\n                    // If it's the first line, we'll have to use arbirary line height,\r\n                    // since there's nothing to measure. For subsequent lines we can take\r\n                    // previous line's height\r\n                    var tempElement = this.getSVGLineElement(\"\", 0);\r\n                    tempElement.add(this.getSvgElement(\".\", getTextFormatter().translateStyleShortcuts(currentFormat)));\r\n                    group.add(tempElement);\r\n                    var offset = Math.ceil(tempElement.getBBox().height);\r\n                    if (offset > 0) {\r\n                        currentHeight += offset;\r\n                    }\r\n                    group.removeElement(tempElement);\r\n                    // Clear cache if necessary\r\n                    var lineInfo_1 = this.getLineInfo(i);\r\n                    if (lineInfo_1) {\r\n                        lineInfo_1.text = \"\";\r\n                        lineInfo_1.element.textContent = \"\";\r\n                    }\r\n                    continue;\r\n                }\r\n                // Chunk up the line and process each chunk\r\n                var chunks = getTextFormatter().chunk(line, null, this.ignoreFormatting);\r\n                var currentLineHeight = 0;\r\n                var firstChunk = true;\r\n                var skipTextChunks = false;\r\n                // Create line element or grab it from cache\r\n                var lineInfo = this.getLineInfo(i);\r\n                if (lineInfo) {\r\n                    // Empty line\r\n                    lineInfo.text = \"\";\r\n                    lineInfo.element.textContent = \"\";\r\n                }\r\n                else {\r\n                    // Init new line info\r\n                    lineInfo = {\r\n                        \"text\": \"\",\r\n                        \"element\": this.getSVGLineElement(\"\", 0),\r\n                        \"complex\": false\r\n                    };\r\n                    // Create the line element\r\n                    //lineInfo.element = this.getSVGLineElement(\"\", 0);\r\n                    //lineElement = this.getSVGLineElement(\"\", 0);\r\n                    group.add(lineInfo.element);\r\n                }\r\n                lineInfo.element.removeAttr(\"display\");\r\n                lineInfo.element.removeChildren(); // memory leak without this\r\n                if (this.textPathElement) {\r\n                    lineInfo.element.add(this.textPathElement);\r\n                }\r\n                /*// @todo not needed anymore\r\n                if (this.rtl) {\r\n                    chunks.reverse();\r\n                }*/\r\n                // Process each chunk\r\n                for (var x = 0; x < chunks.length; x++) {\r\n                    // If there's more than one chunk, means the line is \"complex\"\r\n                    if (x) {\r\n                        lineInfo.complex = true;\r\n                    }\r\n                    // Get chunk\r\n                    var chunk = chunks[x];\r\n                    // Is this chunk format or text?\r\n                    if (chunk.type === \"format\") {\r\n                        // Log current format, so that we can apply it to multiple lines if\r\n                        // necessary\r\n                        currentFormat = chunk.text;\r\n                    }\r\n                    else {\r\n                        // It's text block\r\n                        // Need to skip?\r\n                        // We do this when truncating. We can't just simply go ahead and\r\n                        // abandon chunk processing as they might have formatting\r\n                        // instructions in them that are relevant for subsequent lines\r\n                        if (skipTextChunks) {\r\n                            continue;\r\n                        }\r\n                        // Add chunk to the current element\r\n                        //lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));\r\n                        lineInfo.text = chunk.text;\r\n                        lineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);\r\n                        if (this.textPathElement) {\r\n                            this.getSvgElement(lineInfo.text, lineInfo.style, this.textPathElement);\r\n                        }\r\n                        else {\r\n                            this.getSvgElement(lineInfo.text, lineInfo.style, lineInfo.element);\r\n                        }\r\n                        this.getLineBBox(lineInfo);\r\n                        lineInfo.bbox.width = Math.ceil(lineInfo.bbox.width);\r\n                        // Updated current line height\r\n                        if (currentLineHeight < lineInfo.bbox.height) {\r\n                            currentLineHeight = lineInfo.bbox.height;\r\n                        }\r\n                        // Wrapping?\r\n                        if ((this.wrap || this.truncate) && (lineInfo.bbox.width > maxWidth)) {\r\n                            // Set oversized\r\n                            this.isOversized = true;\r\n                            // Take temporary measurements\r\n                            var lineText = lineInfo.element.textContent;\r\n                            var avgCharWidth = (lineInfo.bbox.width / lineText.length); // * .9;\r\n                            // Calculate average number of symbols / width\r\n                            var excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\r\n                            // Are we truncating or auto-wrapping text?\r\n                            if (this.truncate) {\r\n                                /**\r\n                                 * Processing line truncation\r\n                                 * With the addition of each text chunk we measure if current\r\n                                 * line does not exceed maxWidth. If it does, we will stop\r\n                                 * addition of further chunks as well as try to truncate\r\n                                 * current or any number of previous chunks with an added\r\n                                 * ellipsis\r\n                                 */\r\n                                // Indicator whether we need to add ellipsis to the current\r\n                                // element, even if it fits. This is needed to indicate\r\n                                // whether we have already removed some subsequent chunks in\r\n                                // which case we need to add ellipsis.\r\n                                var addEllipsis = false;\r\n                                // Process each child in the temporary line, until the whole\r\n                                // line fits, preferably with an ellipsis\r\n                                // TODO use iterator instead\r\n                                var node_1 = lineInfo.element.node;\r\n                                if (node_1 && node_1.childNodes) {\r\n                                    for (var e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {\r\n                                        // Get current element\r\n                                        var node_2 = lineInfo.element.node.childNodes[e];\r\n                                        // Add ellipsis only if previous chunk was removed in full\r\n                                        // and this chunk already fits\r\n                                        //if (addEllipsis && (bbox.width <= maxWidth)) {\r\n                                        if (addEllipsis && (lineInfo.bbox.width <= maxWidth)) {\r\n                                            // Add ellipsis\r\n                                            node_2.textContent += \" \" + this.ellipsis;\r\n                                            // Measure again (we need to make sure ellipsis fits)\r\n                                            lineInfo.bbox = lineInfo.element.getBBox();\r\n                                            lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n                                            // If it fits, we're done here\r\n                                            // If it doesn't we continue rolling\r\n                                            if (lineInfo.bbox.width <= maxWidth) {\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                        addEllipsis = false;\r\n                                        // Get element text\r\n                                        var elementText = node_2.textContent;\r\n                                        // Calculate average number of symbols / width\r\n                                        lineText = lineInfo.element.textContent;\r\n                                        excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\r\n                                        // Do this until we fit\r\n                                        while ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {\r\n                                            // Calculate max available chars\r\n                                            var maxChars = $math.max(lineText.length - excessChars - this.ellipsis.length, 1);\r\n                                            // Is there anything left?\r\n                                            if (maxChars <= 1) {\r\n                                                // Nope, let's jump to the previous item\r\n                                                // Set excess characters to zero so that this loop does\r\n                                                // not repeat when it over\r\n                                                excessChars = 0;\r\n                                                // Add ellipsis to previous item\r\n                                                // Subsequent iterations will check if the ellipsis fits\r\n                                                if (e > 0) {\r\n                                                    // Indicating to add ellipsis to previous item\r\n                                                    addEllipsis = true;\r\n                                                    // Removing this node\r\n                                                    lineInfo.element.node.removeChild(node_2);\r\n                                                }\r\n                                            }\r\n                                            // Truncate the text\r\n                                            elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);\r\n                                            if ((elementText.length > maxChars) && this.fullWords) {\r\n                                                // Still too long?\r\n                                                // Let's try truncating breaking words anyway\r\n                                                elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);\r\n                                            }\r\n                                            // Set truncated text\r\n                                            node_2.textContent = elementText;\r\n                                            // Measure again\r\n                                            lineInfo.bbox = lineInfo.element.getBBox();\r\n                                            lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n                                            // Increase excess characters count, just in case it still\r\n                                            // doesn't fit and we have to go at it again\r\n                                            excessChars = Math.ceil(excessChars * 1.1);\r\n                                        }\r\n                                        // Do not process further chunks\r\n                                        skipTextChunks = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                /**\r\n                                 * Processign auto-wrap\r\n                                 * In this case we're going to be adding text chunks until\r\n                                 * they don't fit into current line. Once that happens we will\r\n                                 * inject the rest of the chunks to the next line\r\n                                 */\r\n                                // Get last node added and measure it\r\n                                var node_3 = lineInfo.element.node;\r\n                                if (node_3) {\r\n                                    var lastNode = lineInfo.element.node.lastChild;\r\n                                    // Init split lines\r\n                                    var splitLines = void 0;\r\n                                    while ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {\r\n                                        // Calculate max available chars\r\n                                        var maxChars = $math.max(chunk.text.length - excessChars, 1);\r\n                                        // Don't split the words mid-word if it's not the first chunk\r\n                                        // in the line\r\n                                        if (firstChunk) {\r\n                                            // Split mid-word if necessary\r\n                                            splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\r\n                                        }\r\n                                        else {\r\n                                            // Don't split mid-word\r\n                                            splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl, false);\r\n                                            // Check if the first word is too long\r\n                                            if ((splitLines[0].length > maxChars) || maxChars === 1) {\r\n                                                // Yes - move the whole chunk to the next line\r\n                                                // Remove the element we just added\r\n                                                lineInfo.element.node.removeChild(lastNode);\r\n                                                // Break out of the while on next cycle\r\n                                                excessChars = 0;\r\n                                            }\r\n                                        }\r\n                                        // Use the first line to update last item\r\n                                        if (excessChars > 0) {\r\n                                            var lineText_1 = splitLines.shift();\r\n                                            if (firstChunk) {\r\n                                                lineText_1 = $utils.trim(lineText_1);\r\n                                            }\r\n                                            lastNode.textContent = getTextFormatter().cleanUp(lineText_1);\r\n                                        }\r\n                                        // Measure again, just in case\r\n                                        lineInfo.bbox = lineInfo.element.getBBox();\r\n                                        lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n                                        // Increase excess characters count, just in case it still\r\n                                        // doesn't fit and we have to go at it again\r\n                                        //excessChars = Math.ceil(excessChars * 1.05);\r\n                                        excessChars++;\r\n                                    }\r\n                                    // Construct the rest of the line\r\n                                    if (splitLines.length > 0) {\r\n                                        var restOfLine = \"\";\r\n                                        // Add leftovers from splitting the current chunk\r\n                                        if ($type.hasValue(splitLines)) {\r\n                                            if (this.rtl) {\r\n                                                restOfLine += splitLines.join(\"\") + currentFormat;\r\n                                            }\r\n                                            else {\r\n                                                restOfLine += currentFormat + splitLines.join(\"\").replace(/([\\[\\]]{1})/g, \"$1$1\");\r\n                                            }\r\n                                        }\r\n                                        // Add the rest of the chunks\r\n                                        for (var c = x + 1; c < chunks.length; c++) {\r\n                                            if (chunks[c].type == \"value\") {\r\n                                                // We're escaping single square brackets that were\r\n                                                // cleaned up by chunk() back to double square brackets\r\n                                                // so that they are not being treated as format on\r\n                                                // next pass.\r\n                                                restOfLine += chunks[c].text.replace(/([\\[\\]]{1})/g, \"$1$1\");\r\n                                            }\r\n                                            else {\r\n                                                restOfLine += chunks[c].text;\r\n                                            }\r\n                                        }\r\n                                        // Inject the rest of the lines as chunks for subsequent\r\n                                        lines.splice(i + 1, 0, restOfLine);\r\n                                    }\r\n                                    // Skip processing the rest of the chunks\r\n                                    skipTextChunks = true;\r\n                                }\r\n                            }\r\n                        }\r\n                        // Let's update the text's bbox with the line's one\r\n                        if (this.bbox.width < lineInfo.bbox.width) {\r\n                            this.bbox.width = lineInfo.bbox.width;\r\n                        }\r\n                        // commented to avoid bug (seen on sankey link) where text is incorrectly aligned\r\n                        //if (this.bbox.x > lineInfo.bbox.x) {\r\n                        //this.bbox.x = lineInfo.bbox.x;\r\n                        //}\r\n                        this.bbox.height = currentHeight + currentLineHeight;\r\n                        // Position current line\r\n                        if (!this.textPathElement) {\r\n                            lineInfo.element.attr({\r\n                                \"x\": \"0\",\r\n                                \"y\": currentHeight + currentLineHeight,\r\n                                \"dy\": $math.round((this.baseLineRatio * currentLineHeight), 3).toString()\r\n                            });\r\n                        }\r\n                        else {\r\n                            lineInfo.element.attr({\r\n                                \"dy\": -this.paddingBottom.toString()\r\n                            });\r\n                        }\r\n                        firstChunk = false;\r\n                    }\r\n                }\r\n                // Trim the last item\r\n                var node = lineInfo.element.node;\r\n                if (node) {\r\n                    var lastNode = node.lastChild;\r\n                    if (lastNode) {\r\n                        lastNode.textContent = this.rtl ?\r\n                            $utils.ltrim(lastNode.textContent) :\r\n                            $utils.rtrim(lastNode.textContent);\r\n                    }\r\n                }\r\n                // Increment collective height\r\n                currentHeight += currentLineHeight;\r\n                // Save line cache\r\n                this.addLineInfo(lineInfo, i);\r\n            }\r\n            // Check if maybe we need to hide the whole label if it doesn't fit\r\n            this.maybeHideOversized();\r\n            this.measureFailed = false;\r\n            if (this.bbox.width == 0 || this.bbox.height == 0) {\r\n                this.measureFailed = true;\r\n            }\r\n            // Updated measured dims\r\n            this._measuredWidth = $math.round($math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));\r\n            this._measuredHeight = $math.round($math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom));\r\n            // Align the lines\r\n            this.alignSVGText();\r\n            this.bbox.width = this._measuredWidth;\r\n            this.bbox.height = this._measuredHeight;\r\n            if (oldH != this._measuredHeight || oldW != this._measuredWidth) {\r\n                this.dispatch(\"transformed\");\r\n            }\r\n            this.hideUnused(lines.length);\r\n        }\r\n        else {\r\n            /**\r\n             * HTML\r\n             */\r\n            this.element.removeAttr(\"display\");\r\n            this.resetBBox();\r\n            // Clear the element\r\n            var group = this.element;\r\n            group.removeChildren();\r\n            this.setCache(\"lineInfo\", [], 0);\r\n            // Create a ForeignObject to use as HTML container\r\n            var fo = this.paper.foreignObject();\r\n            group.add(fo);\r\n            // Set widths on foreignObject so that autosizing measurements work\r\n            // This will bet reset to actual content width/height\r\n            if (this.maxWidth) {\r\n                fo.attr({\r\n                    width: this.maxWidth - this.pixelPaddingLeft - this.pixelPaddingRight\r\n                });\r\n            }\r\n            if (this.maxHeight) {\r\n                fo.attr({\r\n                    height: this.maxHeight - this.pixelPaddingTop - this.pixelPaddingBottom\r\n                });\r\n            }\r\n            // Create line element\r\n            //let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));\r\n            var lineElement = this.getHTMLLineElement(text);\r\n            fo.node.appendChild(lineElement);\r\n            // Temporarily set to inline-block so we can measure real width and height\r\n            lineElement.style.display = \"inline-block\";\r\n            var clientWidth = lineElement.clientWidth;\r\n            var clientHeight = lineElement.clientHeight;\r\n            lineElement.style.display = \"block\";\r\n            this._bbox = {\r\n                x: 0,\r\n                y: 0,\r\n                width: clientWidth,\r\n                height: clientHeight\r\n            };\r\n            // Set exact dimensions of foreignObject so it is sized exactly as\r\n            // the content within (add one pixel to width so it does not wrap)\r\n            fo.attr({\r\n                width: clientWidth + 1,\r\n                height: clientHeight\r\n            });\r\n            // Check if maybe we need to hide the whole label if it doesn't fit\r\n            this.maybeHideOversized();\r\n            // Set measurements and update bbox\r\n            this._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\r\n            this._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);\r\n            this.bbox.width = this._measuredWidth;\r\n            this.bbox.height = this._measuredHeight;\r\n            // Don't let labels bleed out of the alotted area\r\n            if (this.truncate) {\r\n                lineElement.style.overflow = \"hidden\";\r\n            }\r\n            if ((clientWidth > maxWidth) || (clientHeight > maxHeight)) {\r\n                this.isOversized = true;\r\n            }\r\n        }\r\n        // Set applicable styles\r\n        this.setStyles();\r\n        this.updateCenter();\r\n        this.updateBackground();\r\n        if (display == \"none\") {\r\n            this.group.attr({ display: \"none\" });\r\n        }\r\n        if (this.pathElement) {\r\n            this.paper.appendDef(this.pathElement);\r\n        }\r\n    };\r\n    /**\r\n     * Hides element if it does not fit into available space\r\n     */\r\n    Label.prototype.maybeHideOversized = function () {\r\n        if (this.hideOversized) {\r\n            if ((this.availableWidth < this.bbox.width) || (this.availableHeight < this.bbox.height)) {\r\n                this.element.attr({ display: \"none\" });\r\n                this.isOversized = true;\r\n            }\r\n            else {\r\n                this.element.removeAttr(\"display\");\r\n                this.isOversized = false;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Aligns the lines horizontally and vertically, based on properties.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Label.prototype.alignSVGText = function () {\r\n        // Get Group\r\n        var group = this.element;\r\n        var children = group.node.children || group.node.childNodes;\r\n        // Is there anything to align?\r\n        if (!children || (children && children.length == 0)) {\r\n            return;\r\n        }\r\n        var width = this._measuredWidth;\r\n        var height = this._measuredHeight;\r\n        // TODO maybe these aren't needed ?\r\n        $utils.used(this.pixelPaddingLeft);\r\n        $utils.used(this.pixelPaddingRight);\r\n        $utils.used(this.pixelPaddingTop);\r\n        $utils.used(this.pixelPaddingBottom);\r\n        if (this.rtl) {\r\n            group.attr({\r\n                \"direction\": \"rtl\"\r\n            });\r\n        }\r\n        else {\r\n            group.removeAttr(\"direction\");\r\n        }\r\n        // Process each line\r\n        //$iter.each(group.children.backwards().iterator(), (element) => {\r\n        for (var i = children.length - 1; i >= 0; i--) {\r\n            // Align horizontally\r\n            // Since we are using `text-anchor` for horizontal alignment, all we need\r\n            // to do here is move the `x` position\r\n            var node = children[i];\r\n            node.setAttribute(\"text-anchor\", this.textAlign);\r\n            if (this.textPathElement) {\r\n                node.removeAttribute(\"x\");\r\n                node.removeAttribute(\"y\");\r\n            }\r\n            else {\r\n                switch (this.textAlign) {\r\n                    case \"middle\":\r\n                        node.setAttribute(\"x\", (width / 2).toString() + \"px\");\r\n                        break;\r\n                    case \"end\":\r\n                        if (this.rtl) {\r\n                        }\r\n                        else {\r\n                            node.setAttribute(\"x\", width.toString());\r\n                        }\r\n                        break;\r\n                    default:\r\n                        if (this.rtl) {\r\n                            node.setAttribute(\"x\", width.toString());\r\n                        }\r\n                        else {\r\n                            node.removeAttribute(\"text-anchor\");\r\n                        }\r\n                        break;\r\n                }\r\n                var y = $type.toNumber(node.getAttribute(\"y\"));\r\n                switch (this.textValign) {\r\n                    case \"middle\":\r\n                        node.setAttribute(\"y\", ((y || 0) + (height - this.bbox.height) / 2).toString());\r\n                        break;\r\n                    case \"bottom\":\r\n                        node.setAttribute(\"y\", ((y || 0) + height - this.bbox.height).toString());\r\n                        break;\r\n                    default:\r\n                        node.setAttribute(\"y\", (y || 0).toString());\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Produces an SVG line element with formatted text.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param text    Text to wrap into line\r\n     * @param y       Current line vertical position\r\n     * @return A DOM element\r\n     * @todo Implement HTML support\r\n     */\r\n    Label.prototype.getSVGLineElement = function (text, y) {\r\n        // Create a <text> node and set text\r\n        var element = this.paper.addGroup(\"text\");\r\n        element.textContent = text;\r\n        // Set parameters\r\n        element.attr({\r\n            \"x\": \"0\"\r\n            //\"alignment-baseline\": \"hanging\",\r\n            //\"baseline-shift\": \"-20%\",\r\n            //\"text-anchor\": \"center\"\r\n        });\r\n        // Set `y` position\r\n        if ($type.hasValue(y)) {\r\n            element.attr({\r\n                \"y\": y.toString()\r\n            });\r\n        }\r\n        // Don't let labels blled out of the alotted area\r\n        if (this.truncate || this.wrap) {\r\n            element.attr({ \"overflow\": \"hidden\" });\r\n        }\r\n        // Add RTL?\r\n        // This has now been moved to this.alignSVGText()\r\n        // if (this.rtl) {\r\n        // \telement.attr({\r\n        // \t\t\"direction\": \"rtl\",\r\n        // \t\t//\"unicode-bidi\": \"bidi-override\"\r\n        // \t});\r\n        // }\r\n        return element;\r\n    };\r\n    Object.defineProperty(Label.prototype, \"rtl\", {\r\n        /**\r\n         * @return RTL?\r\n         */\r\n        get: function () {\r\n            if ($type.hasValue(this._rtl)) {\r\n                return this._rtl;\r\n            }\r\n            else if (this._topParent) {\r\n                return this._topParent.rtl;\r\n            }\r\n            return false;\r\n        },\r\n        /**\r\n         * An RTL (right-to-left) setting.\r\n         *\r\n         * RTL may affect alignment, text, and other visual properties.\r\n         *\r\n         * If you set this on a top-level chart object, it will be used for all\r\n         * child elements, e.g. labels, unless they have their own `rtl` setting\r\n         * set directly on them.\r\n         *\r\n         * @param value  `true` for to use RTL\r\n         */\r\n        set: function (value) {\r\n            value = $type.toBoolean(value);\r\n            this._rtl = value;\r\n            if (this.element) {\r\n                this.alignSVGText();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Resets cached BBox.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Label.prototype.resetBBox = function () {\r\n        this._bbox = { x: 0, y: 0, width: 0, height: 0 };\r\n    };\r\n    /**\r\n     * Creates and returns an HTML line element (`<div>`).\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param text  Text to add\r\n     * @return `<div>` element reference\r\n     */\r\n    Label.prototype.getHTMLLineElement = function (text) {\r\n        // Create the <div> element\r\n        var div = document.createElement(\"div\");\r\n        div.innerHTML = text;\r\n        // Set text alignment\r\n        switch (this.textAlign) {\r\n            case \"middle\":\r\n                div.style.textAlign = \"center\";\r\n                break;\r\n            case \"end\":\r\n                div.style.textAlign = \"right\";\r\n                break;\r\n        }\r\n        // Disable or enable wrapping\r\n        if (this.wrap) {\r\n            div.style.wordWrap = \"break-word\";\r\n        }\r\n        else {\r\n            div.style.whiteSpace = \"nowrap\";\r\n        }\r\n        // Don't let labels bleed out of the alotted area\r\n        // Moved to `draw()` because setting \"hidden\" kills all measuring\r\n        /*if (this.truncate) {\r\n            div.style.overflow = \"hidden\";\r\n        }*/\r\n        // Set RTL-related styles\r\n        if (this.rtl) {\r\n            div.style.direction = \"rtl\";\r\n            //div.style.unicodeBidi = \"bidi-override\";\r\n        }\r\n        // Translate some of the SVG styles into CSS\r\n        if ($type.hasValue(this.fill)) {\r\n            div.style.color = this.fill.toString();\r\n        }\r\n        return div;\r\n    };\r\n    /**\r\n     * Applies specific styles to text to make it not selectable, unless it is\r\n     * explicitly set as `selectable`.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Set styles via AMElement\r\n     */\r\n    Label.prototype.setStyles = function () {\r\n        var group = this.element;\r\n        if (!this.selectable || this.draggable || this.resizable || this.swipeable) {\r\n            group.addStyle({\r\n                \"webkitUserSelect\": \"none\",\r\n                \"msUserSelect\": \"none\"\r\n            });\r\n        }\r\n        else if (this.selectable) {\r\n            group.removeStyle(\"webkitUserSelect\");\r\n            group.removeStyle(\"msUserSelect\");\r\n        }\r\n    };\r\n    /**\r\n     * Hides unused lines\r\n     */\r\n    Label.prototype.hideUnused = function (index) {\r\n        this.initLineCache();\r\n        var lines = this.getCache(\"lineInfo\");\r\n        if (lines.length >= index) {\r\n            for (var i = index; i < lines.length; i++) {\r\n                var line = lines[i];\r\n                if (line && line.element) {\r\n                    line.element.attr({ \"display\": \"none\" });\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Object.defineProperty(Label.prototype, \"text\", {\r\n        /**\r\n         * @return SVG text\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"text\");\r\n        },\r\n        /**\r\n         * An SVG text.\r\n         *\r\n         * Please note that setting `html` will override this setting if browser\r\n         * supports `foreignObject` in SGV, such as most modern browsers excluding\r\n         * IEs.\r\n         *\r\n         * @param value  SVG Text\r\n         */\r\n        set: function (value) {\r\n            //this.setPropertyValue(\"html\", undefined);\r\n            this.setPropertyValue(\"text\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"path\", {\r\n        /**\r\n         * @return Path\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"path\");\r\n        },\r\n        /**\r\n         * An SVG path string to position text along. If set, the text will follow\r\n         * the curvature of the path.\r\n         *\r\n         * Location along the path can be set using `locationOnPath`.\r\n         *\r\n         * IMPORTANT: Only SVG text can be put on path. If you are using HTML text\r\n         * this setting will be ignored.\r\n         *\r\n         * @since 4.1.2\r\n         * @param  value  Path\r\n         */\r\n        set: function (value) {\r\n            if (this.setPropertyValue(\"path\", value, true)) {\r\n                if (this.pathElement) {\r\n                    this.pathElement.dispose();\r\n                }\r\n                if (this.textPathElement) {\r\n                    this.textPathElement.dispose();\r\n                }\r\n                this.pathElement = this.paper.add(\"path\");\r\n                this.pathElement.attr({ \"d\": value });\r\n                this.pathElement.attr({ \"id\": \"text-path-\" + this.uid });\r\n                this._disposers.push(this.pathElement);\r\n                this.textPathElement = this.paper.addGroup(\"textPath\");\r\n                this.textPathElement.attrNS($dom.XLINK, \"xlink:href\", \"#text-path-\" + this.uid);\r\n                // TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed\r\n                this.textPathElement.attr({ \"path\": value });\r\n                this._disposers.push(this.textPathElement);\r\n                this.hardInvalidate();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"locationOnPath\", {\r\n        /**\r\n         * @return Relatvie location on path\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"locationOnPath\");\r\n        },\r\n        /**\r\n         * Relative label location on `path`. Value range is from 0 (beginning)\r\n         * to 1 (end).\r\n         *\r\n         * Works only if you set `path` setting to an SVG path.\r\n         *\r\n         * @since 4.1.2\r\n         * @default 0\r\n         * @param  value  Relatvie location on path\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"locationOnPath\", value);\r\n            if (this.textPathElement) {\r\n                this.textPathElement.attr({ \"startOffset\": (value * 100) + \"%\" });\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"baseLineRatio\", {\r\n        /**\r\n         * @return Base line ratio\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"baseLineRatio\");\r\n        },\r\n        /**\r\n         * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n         * the label.\r\n         *\r\n         * @since 4.4.2\r\n         * @default -0.27\r\n         * @param  value  Base line ratio\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"baseLineRatio\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"wrap\", {\r\n        /**\r\n         * @return Auto-wrap enabled or not\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"wrap\");\r\n        },\r\n        /**\r\n         * Enables or disables autowrapping of text.\r\n         *\r\n         * @param value  Auto-wrapping enabled\r\n         */\r\n        set: function (value) {\r\n            this.resetBBox();\r\n            this.setPropertyValue(\"wrap\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"truncate\", {\r\n        /**\r\n         * @return Truncate text?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"truncate\");\r\n        },\r\n        /**\r\n         * Indicates if text lines need to be truncated if they do not fit, using\r\n         * configurable `ellipsis` string.\r\n         *\r\n         * `truncate` overrides `wrap` if both are set to `true`.\r\n         *\r\n         * NOTE: For HTML text, this setting **won't** trigger a parser and actual\r\n         * line truncation with ellipsis. It will just hide everything that goes\r\n         * outside the label.\r\n         *\r\n         * @param value  trincate text?\r\n         */\r\n        set: function (value) {\r\n            this.resetBBox();\r\n            this.setPropertyValue(\"truncate\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"fullWords\", {\r\n        /**\r\n         * @return Truncate on full words?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"fullWords\");\r\n        },\r\n        /**\r\n         * If `truncate` is enabled, should Label try to break only on full words\r\n         * (`true`), or whenever needed, including middle of the word. (`false`)\r\n         *\r\n         * @default true\r\n         * @param value  Truncate on full words?\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"fullWords\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"ellipsis\", {\r\n        /**\r\n         * @return Ellipsis string\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"ellipsis\");\r\n        },\r\n        /**\r\n         * Ellipsis character to use if `truncate` is enabled.\r\n         *\r\n         * @param value Ellipsis string\r\n         * @default \"...\"\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"ellipsis\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"selectable\", {\r\n        /**\r\n         * @return Text selectable?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"selectable\");\r\n        },\r\n        /**\r\n         * Forces the text to be selectable. This setting will be ignored if the\r\n         * object has some kind of interaction attached to it, such as it is\r\n         * `draggable`, `swipeable`, `resizable`.\r\n         *\r\n         * @param value  Text selectable?\r\n         * @default false\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"selectable\", value, true);\r\n            this.setStyles();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"textAlign\", {\r\n        /**\r\n         * @return Alignment\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"textAlign\");\r\n        },\r\n        /**\r\n         * Horizontal text alignment.\r\n         *\r\n         * Available choices:\r\n         * * \"start\"\r\n         * * \"middle\"\r\n         * * \"end\"\r\n         *\r\n         * @param value  Alignment\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"textAlign\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"textValign\", {\r\n        /**\r\n         * @ignore Exclude from docs (not used)\r\n         * @return Alignment\r\n         * @deprecated\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"textValign\");\r\n        },\r\n        /**\r\n         * Vertical text alignment.\r\n         *\r\n         * @ignore Exclude from docs (not used)\r\n         * @param value  Alignment\r\n         * @deprecated\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"textValign\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"html\", {\r\n        /**\r\n         * @return HTML content\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"html\");\r\n        },\r\n        /**\r\n         * Raw HTML to be used as text.\r\n         *\r\n         * NOTE: HTML text is subject to browser support. It relies on browsers\r\n         * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not\r\n         * support it. On those browsers, the text will fall back to basic SVG text,\r\n         * striping out all HTML markup and styling that goes with it.\r\n         *\r\n         * For more information about `foreignObject` and its browser compatibility\r\n         * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).\r\n         *\r\n         * @param value HTML text\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"html\", value, true);\r\n            if (!$type.hasValue(value)) {\r\n                var group = this.element;\r\n                group.removeChildrenByTag(\"foreignObject\");\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Label.prototype.setFill = function (value) {\r\n        _super.prototype.setFill.call(this, value);\r\n        if (this.html) {\r\n            var group = this.element;\r\n            var divs = group.node.getElementsByTagName(\"div\");\r\n            for (var i = 0; i < divs.length; i++) {\r\n                var div = divs[i];\r\n                if ($type.hasValue(this.fill)) {\r\n                    div.style.color = this.fill.toString();\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Object.defineProperty(Label.prototype, \"hideOversized\", {\r\n        /**\r\n         * @return Hide if text does not fit?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"hideOversized\");\r\n        },\r\n        /**\r\n         * Indicates whether the whole text should be hidden if it does not fit into\r\n         * its allotted space.\r\n         *\r\n         * @param value  Hide if text does not fit?\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"hideOversized\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"ignoreFormatting\", {\r\n        /**\r\n         * @return Ignore formatting?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"ignoreFormatting\");\r\n        },\r\n        /**\r\n         * If set to `true` square-bracket formatting blocks will be treated as\r\n         * regular text.\r\n         *\r\n         * @default false\r\n         * @param value  Ignore formatting?\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"ignoreFormatting\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Override `mesaureElement` so it does not get measure again, because\r\n     * internal `_bbox` is being updated by measuring routines in Text itself.\r\n     */\r\n    Label.prototype.measureElement = function () { };\r\n    /**\r\n     * Returns information about a line element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param index  Line index\r\n     * @return Line info object\r\n     */\r\n    Label.prototype.getLineInfo = function (index) {\r\n        this.initLineCache();\r\n        var lines = this.getCache(\"lineInfo\");\r\n        return lines.length > index ? lines[index] : undefined;\r\n    };\r\n    /**\r\n     * Adds a line to line info cache.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param line     Line info object\r\n     * @param index    Insert at specified index\r\n     */\r\n    Label.prototype.addLineInfo = function (line, index) {\r\n        this.initLineCache();\r\n        this.getCache(\"lineInfo\")[index] = line;\r\n    };\r\n    /**\r\n     * Checks if line cache is initialized and initializes it.\r\n     */\r\n    Label.prototype.initLineCache = function () {\r\n        if (!$type.hasValue(this.getCache(\"lineInfo\"))) {\r\n            this.setCache(\"lineInfo\", [], 0);\r\n        }\r\n    };\r\n    /**\r\n     * Sets a [[DataItem]] to use for populating dynamic sections of the text.\r\n     *\r\n     * Check the description for [[Text]] class, for data binding.\r\n     *\r\n     * @param dataItem Data item\r\n     */\r\n    Label.prototype.setDataItem = function (dataItem) {\r\n        if (this._sourceDataItemEvents) {\r\n            this._sourceDataItemEvents.dispose();\r\n        }\r\n        if (dataItem) {\r\n            this._sourceDataItemEvents = new MultiDisposer([\r\n                dataItem.events.on(\"valuechanged\", this.invalidate, this, false),\r\n                dataItem.events.on(\"workingvaluechanged\", this.invalidate, this, false),\r\n                dataItem.events.on(\"calculatedvaluechanged\", this.invalidate, this, false),\r\n                dataItem.events.on(\"propertychanged\", this.invalidate, this, false)\r\n            ]);\r\n        }\r\n        _super.prototype.setDataItem.call(this, dataItem);\r\n    };\r\n    Object.defineProperty(Label.prototype, \"availableWidth\", {\r\n        /**\r\n         * Returns available horizontal space.\r\n         *\r\n         * @ignore Exclude from docs\r\n         * @return Available width (px)\r\n         */\r\n        get: function () {\r\n            return $type.hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Label.prototype, \"availableHeight\", {\r\n        /**\r\n         * Returns available vertical space.\r\n         *\r\n         * @return Available height (px)\r\n         */\r\n        get: function () {\r\n            return $type.hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    // temp, replacing textFormatter method\r\n    Label.prototype.getSvgElement = function (text, style, parent) {\r\n        var element = this.paper.add(\"tspan\");\r\n        element.textContent = text;\r\n        if (style) {\r\n            if (options.nonce && parent) {\r\n                //element.node.setAttribute(\"nonce\", \"test123\");\r\n                var classid = \"amcharts_element_style_\" + btoa(style).replace(/[^\\w]*/g, \"\");\r\n                element.node.setAttribute(\"class\", classid);\r\n                var defs = document.createElementNS($dom.SVGNS, \"defs\");\r\n                parent.node.appendChild(defs);\r\n                var e = document.createElement(\"style\");\r\n                e.type = \"text/css\";\r\n                e.innerHTML = \".\" + classid + \" { \" + style + \"}\";\r\n                e.setAttribute(\"nonce\", options.nonce);\r\n                defs.appendChild(e);\r\n            }\r\n            else {\r\n                element.node.setAttribute(\"style\", style);\r\n            }\r\n        }\r\n        if (parent) {\r\n            parent.add(element);\r\n        }\r\n        return element;\r\n    };\r\n    /**\r\n     * Invalidates the whole element, including layout AND all its child\r\n     * elements.\r\n     */\r\n    Label.prototype.deepInvalidate = function () {\r\n        _super.prototype.deepInvalidate.call(this);\r\n        this.hardInvalidate();\r\n    };\r\n    Object.defineProperty(Label.prototype, \"readerTitle\", {\r\n        /**\r\n         * @return Title\r\n         */\r\n        get: function () {\r\n            var title = this.getPropertyValue(\"readerTitle\");\r\n            if (!title) {\r\n                title = this.populateString($utils.plainText($utils.isNotEmpty(this.html)\r\n                    ? this.html\r\n                    : this.text));\r\n            }\r\n            else if (this.dataItem) {\r\n                title = this.populateString(title);\r\n            }\r\n            return title;\r\n        },\r\n        /**\r\n         * Screen reader title of the element.\r\n         *\r\n         * @param value Title\r\n         */\r\n        set: function (value) {\r\n            value = $type.toText(value);\r\n            if (this.setPropertyValue(\"readerTitle\", value)) {\r\n                this.applyAccessibility();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Label;\r\n}(Container));\r\nexport { Label };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Label\"] = Label;\r\n/**\r\n * Add default responsive rules\r\n */\r\n/**\r\n * Hide labels added directly to chart, like titles if chart is short.\r\n */\r\ndefaultRules.push({\r\n    relevant: ResponsiveBreakpoints.heightXS,\r\n    state: function (target, stateId) {\r\n        if (target instanceof Label && target.parent && target.parent.isBaseSprite) {\r\n            var state = target.states.create(stateId);\r\n            state.properties.disabled = true;\r\n            return state;\r\n        }\r\n        return null;\r\n    }\r\n});\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}