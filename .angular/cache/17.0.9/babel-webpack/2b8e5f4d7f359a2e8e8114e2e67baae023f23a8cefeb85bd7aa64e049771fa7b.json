{"ast":null,"code":"/**\r\n * Module, defining Axis Renderer for radial axes.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { AxisRendererY } from \"./AxisRendererY\";\nimport { CategoryAxis } from \"./CategoryAxis\";\nimport { WavedCircle } from \"../../core/elements/WavedCircle\";\nimport { MutableValueDisposer } from \"../../core/utils/Disposer\";\nimport { Percent, percent } from \"../../core/utils/Percent\";\nimport { registry } from \"../../core/Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $path from \"../../core/rendering/Path\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport * as $type from \"../../core/utils/Type\";\nimport { AxisBullet } from \"./AxisBullet\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * A renderer for radial axis.\r\n */\nvar AxisRendererRadial = /** @class */function (_super) {\n  __extends(AxisRendererRadial, _super);\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param axis Related axis\r\n   */\n  function AxisRendererRadial() {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    /**\r\n     * A related chart.\r\n     */\n    _this._chart = new MutableValueDisposer();\n    /**\r\n     * @ignore\r\n     */\n    _this.pixelRadiusReal = 0;\n    _this.className = \"AxisRendererRadial\";\n    _this.isMeasured = false;\n    _this.startAngle = -90;\n    _this.endAngle = 270;\n    _this.minGridDistance = 30;\n    _this.gridType = \"circles\";\n    _this.axisAngle = -90;\n    _this.isMeasured = false;\n    _this.layout = \"none\";\n    _this.radius = percent(100);\n    _this.line.strokeOpacity = 0;\n    _this.labels.template.horizontalCenter = \"middle\";\n    _this._disposers.push(_this._chart);\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * Validates Axis renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  AxisRendererRadial.prototype.validate = function () {\n    // so that radius would be updated\n    if (this.chart && this.chart.invalid) {\n      this.chart.validate();\n    }\n    _super.prototype.validate.call(this);\n  };\n  Object.defineProperty(AxisRendererRadial.prototype, \"axisLength\", {\n    /**\r\n     * Returns actual length of the Axis, in pixels.\r\n     *\r\n     * @return Length (px)\r\n     */\n    get: function () {\n      return this.pixelRadius - this.pixelInnerRadius;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"radius\", {\n    /**\r\n     * @return Outer radius\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"radius\");\n    },\n    /**\r\n     * Outer radius of the axis.\r\n     *\r\n     * Can be absolute (px) or relative ([[Percent]]).\r\n     *\r\n     * @param value  Outer radius\r\n     */\n    set: function (value) {\n      this.setPercentProperty(\"radius\", value, false, false, 10, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"pixelRadius\", {\n    /**\r\n     * Outer radius in pixels.\r\n     *\r\n     * @return Outer radius (px)\r\n     */\n    get: function () {\n      return $utils.relativeRadiusToValue(this.radius, this.pixelRadiusReal) || 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"innerRadius\", {\n    /**\r\n     * @return Inner radius\r\n     */\n    get: function () {\n      var chart = this.chart;\n      var innerRadius = this.getPropertyValue(\"innerRadius\");\n      if (chart) {\n        if (!$type.hasValue(innerRadius)) {\n          innerRadius = chart.innerRadius;\n          if (innerRadius instanceof Percent && chart) {\n            innerRadius = percent(innerRadius.value * chart.innerRadiusModifyer * 100);\n          }\n        } else {\n          if (innerRadius instanceof Percent && chart) {\n            var mr = chart.mr;\n            var value = innerRadius.value;\n            value = Math.max(mr * value, mr - Math.min(chart.plotContainer.innerHeight, chart.plotContainer.innerWidth)) / mr;\n            innerRadius = percent(value * 100);\n          }\n        }\n      }\n      return innerRadius;\n    },\n    /**\r\n     * Inner radius of the axis.\r\n     *\r\n     * Can be absolute (px) or relative ([[Percent]]).\r\n     *\r\n     * @param value  Outer radius\r\n     */\n    set: function (value) {\n      this.setPercentProperty(\"innerRadius\", value, false, false, 10, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"pixelInnerRadius\", {\n    /**\r\n     * Inner radius in pixels.\r\n     *\r\n     * @return Inner radius (px)\r\n     */\n    get: function () {\n      return $utils.relativeRadiusToValue(this.innerRadius, this.pixelRadiusReal) || 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts relative position on axis to point coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @param position2  Position (0-1) Position on the second axis\r\n   * @return Point\r\n   */\n  AxisRendererRadial.prototype.positionToPoint = function (position, position2) {\n    var radius = $math.fitToRange(this.positionToCoordinate(position), 0, Infinity);\n    return {\n      x: radius * $math.cos(this.axisAngle),\n      y: radius * $math.sin(this.axisAngle)\n    };\n  };\n  /**\r\n   * Updates and positions the axis line element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  AxisRendererRadial.prototype.updateAxisLine = function () {\n    this.line.path = $path.moveTo({\n      x: this.pixelInnerRadius * $math.cos(this.axisAngle),\n      y: this.pixelInnerRadius * $math.sin(this.axisAngle)\n    }) + $path.lineTo({\n      x: this.pixelRadius * $math.cos(this.axisAngle),\n      y: this.pixelRadius * $math.sin(this.axisAngle)\n    });\n    var title = this.axis.title;\n    title.valign = \"none\";\n    title.horizontalCenter = \"middle\";\n    title.verticalCenter = \"bottom\";\n    title.y = -this.axisLength / 2;\n    var rotation = 90;\n    if (this.opposite) {\n      if (!this.inside) {\n        rotation = -90;\n      }\n    } else {\n      if (this.inside) {\n        rotation = -90;\n      }\n    }\n    title.rotation = rotation;\n  };\n  /**\r\n   * Updates and positions a grid element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param grid         Grid element\r\n   * @param position     Starting position\r\n   * @param endPosition  End position\r\n   */\n  AxisRendererRadial.prototype.updateGridElement = function (grid, position, endPosition) {\n    position = position + (endPosition - position) * grid.location;\n    var point = this.positionToPoint(position);\n    var path;\n    var radius = $math.getDistance(point);\n    var startAngle = this.startAngle;\n    var endAngle = this.endAngle;\n    var chart = this.chart;\n    if ($type.isNumber(radius) && grid.element && chart) {\n      var xAxis = chart.xAxes.getIndex(0);\n      var count = 0;\n      var series = chart.series.getIndex(0);\n      if (series) {\n        count = series.dataItems.length;\n      }\n      // polygons are only possible if x axis is present\n      // @todo: review this\n      if (this.gridType == \"polygons\" && count > 0 && series && xAxis && xAxis instanceof CategoryAxis) {\n        var gridLocation = xAxis.renderer.grid.template.location;\n        var angle = xAxis.getAngle(series.dataItems.getIndex(0), \"categoryX\", gridLocation);\n        path = $path.moveTo({\n          x: radius * $math.cos(angle),\n          y: radius * $math.sin(angle)\n        });\n        for (var i = 1; i < count; i++) {\n          angle = xAxis.getAngle(series.dataItems.getIndex(i), \"categoryX\", gridLocation);\n          path += $path.lineTo({\n            x: radius * $math.cos(angle),\n            y: radius * $math.sin(angle)\n          });\n        }\n        angle = xAxis.getAngle(series.dataItems.getIndex(count - 1), \"categoryX\", xAxis.renderer.cellEndLocation);\n        path += $path.lineTo({\n          x: radius * $math.cos(angle),\n          y: radius * $math.sin(angle)\n        });\n      } else {\n        path = $path.moveTo({\n          x: radius * $math.cos(startAngle),\n          y: radius * $math.sin(startAngle)\n        }) + $path.arcTo(startAngle, endAngle - startAngle, radius, radius);\n      }\n      grid.path = path;\n    }\n    this.toggleVisibility(grid, position, 0, 1);\n  };\n  /**\r\n   * Updates and positions a label element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param label        Label element\r\n   * @param position     Starting position\r\n   * @param endPosition  Ending position\r\n   */\n  AxisRendererRadial.prototype.updateLabelElement = function (label, position, endPosition, location) {\n    if (!$type.hasValue(location)) {\n      location = label.location;\n    }\n    position = position + (endPosition - position) * location;\n    var point = this.positionToPoint(position);\n    this.positionItem(label, point);\n    this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);\n  };\n  /**\r\n   * Updates and positions the base grid element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  AxisRendererRadial.prototype.updateBaseGridElement = function () {\n    // @todo? zero grid for radar chart, is it needed?\n  };\n  /**\r\n   * Checks if point is within bounds of a container.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param point Point coordinates\r\n   * @return Fits?\r\n   */\n  AxisRendererRadial.prototype.fitsToBounds = function (point) {\n    return true;\n  };\n  Object.defineProperty(AxisRendererRadial.prototype, \"startAngle\", {\n    /**\r\n     * @return Start angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"startAngle\");\n    },\n    /**\r\n     * Start angle of the axis in degrees. (0-360)\r\n     *\r\n     * @param value  Start angle\r\n     */\n    set: function (value) {\n      // do not normalize angle here!\n      if (this.setPropertyValue(\"startAngle\", value)) {\n        this.invalidateAxisItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"endAngle\", {\n    /**\r\n     * @return End angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"endAngle\");\n    },\n    /**\r\n     * End angle of the axis in degrees. (0-360)\r\n     *\r\n     * @param value  End angle\r\n     */\n    set: function (value) {\n      // do not normalize angel here!\n      if (this.setPropertyValue(\"endAngle\", value)) {\n        this.invalidateAxisItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"axisAngle\", {\n    /**\r\n     * @return Axis angle\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"axisAngle\");\n      //return $math.fitToRange(this.getPropertyValue(\"axisAngle\"), this.startAngle, this.endAngle); // no good, as less flexible\n    },\n\n    /**\r\n     * Angle of the radial axis in degrees. (0-360)\r\n     *\r\n     * @param value  Axis angle\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"axisAngle\", $math.normalizeAngle(value));\n      this.invalidateAxisItems();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AxisRendererRadial.prototype, \"gridType\", {\n    /**\r\n     * Grid type\r\n     */\n    get: function () {\n      var axis = this.chart.xAxes.getIndex(0);\n      if (axis instanceof CategoryAxis) {\n        return this.getPropertyValue(\"gridType\");\n      } else {\n        return \"circles\";\n      }\n    },\n    // polygons grid type is only possible under these conditions: xAxis is available and it is CategoryAxis, also at least one series should be added to a chart\n    /**\r\n     * Grid type for radial axis.\r\n     *\r\n     * A grid on radia axis can either be perfect circles (\"circles\"), or\r\n     * straight lines (\"polygons\").\r\n     *\r\n     * @default \"circles\"\r\n     * @param value  Grid type\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"gridType\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * [getPositionRangePath description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param startPosition  Starting position\r\n   * @param endPosition    End position\r\n   * @return SVG path\r\n   */\n  AxisRendererRadial.prototype.getPositionRangePath = function (startPosition, endPosition) {\n    var pixelInnerRadius = this.pixelInnerRadius;\n    var pixelRadius = this.axisLength + pixelInnerRadius;\n    var innerRadius = $math.fitToRange(this.positionToCoordinate(startPosition), pixelInnerRadius, pixelRadius);\n    var radius = $math.fitToRange(this.positionToCoordinate(endPosition), pixelInnerRadius, pixelRadius);\n    //let angleCount: number = this.angleCount;\n    var startAngle = this.startAngle;\n    var endAngle = this.endAngle;\n    var arc = endAngle - startAngle;\n    var path;\n    var chart = this.chart;\n    var xAxis = chart.xAxes.getIndex(0);\n    var series = chart.series.getIndex(0);\n    var count = 0;\n    if (series) {\n      count = series.dataItems.length;\n    }\n    // polygons are only possible if x axis is present\n    // @todo: review this\n    if (this.gridType == \"polygons\" && count > 0 && series && xAxis && xAxis instanceof CategoryAxis) {\n      var gridLocation = xAxis.renderer.grid.template.location;\n      var angle = xAxis.getAngle(series.dataItems.getIndex(0), \"categoryX\", gridLocation);\n      path = $path.moveTo({\n        x: radius * $math.cos(angle),\n        y: radius * $math.sin(angle)\n      });\n      for (var i = 1; i < count; i++) {\n        angle = xAxis.getAngle(series.dataItems.getIndex(i), \"categoryX\", gridLocation);\n        path += $path.lineTo({\n          x: radius * $math.cos(angle),\n          y: radius * $math.sin(angle)\n        });\n      }\n      angle = xAxis.getAngle(series.dataItems.getIndex(count - 1), \"categoryX\", xAxis.renderer.cellEndLocation);\n      path += $path.lineTo({\n        x: radius * $math.cos(angle),\n        y: radius * $math.sin(angle)\n      });\n      path += $path.moveTo({\n        x: innerRadius * $math.cos(angle),\n        y: innerRadius * $math.sin(angle)\n      });\n      for (var i = count - 1; i >= 0; i--) {\n        angle = xAxis.getAngle(series.dataItems.getIndex(i), \"categoryX\", gridLocation);\n        path += $path.lineTo({\n          x: innerRadius * $math.cos(angle),\n          y: innerRadius * $math.sin(angle)\n        });\n      }\n    } else {\n      path = $path.arc(startAngle, arc, radius, innerRadius);\n    }\n    return path;\n  };\n  /**\r\n   * Updates and positions an axis break element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param axisBreak Break element\r\n   */\n  AxisRendererRadial.prototype.updateBreakElement = function (axisBreak) {\n    // @todo: someday we might need axis break when gridType is polygons\n    var startLine = axisBreak.startLine;\n    var endLine = axisBreak.endLine;\n    var fillShape = axisBreak.fillShape;\n    var startPoint = axisBreak.startPoint;\n    var endPoint = axisBreak.endPoint;\n    startLine.radius = Math.abs(startPoint.y);\n    endLine.radius = Math.abs(endPoint.y);\n    fillShape.radius = Math.abs(endPoint.y);\n    fillShape.innerRadius = Math.abs(startPoint.y);\n  };\n  /**\r\n   * Creates visual elements for and axis break.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param axisBreak Axis break\r\n   */\n  AxisRendererRadial.prototype.createBreakSprites = function (axisBreak) {\n    axisBreak.startLine = new WavedCircle();\n    axisBreak.endLine = new WavedCircle();\n    axisBreak.fillShape = new WavedCircle();\n  };\n  /**\r\n   * Updates some of the Axis tooltip's visual properties, related to\r\n   * rendering of the Axis.\r\n   *\r\n   * @todo Description (review)\r\n   * @ignore Exclude from docs\r\n   */\n  AxisRendererRadial.prototype.updateTooltip = function () {\n    var axis = this.axis;\n    if (axis) {\n      var bigNum = 4000;\n      var bbx = -4000;\n      var bby = -4000;\n      var bbw = bigNum * 2;\n      var bbh = bigNum * 2;\n      var axisAngle = this.axisAngle;\n      if (axisAngle < 0) {\n        axisAngle += 360;\n      }\n      var tooltipOrientation = \"vertical\";\n      if (axisAngle > 45 && axisAngle < 135 || axisAngle > 225 && axisAngle < 315) {\n        tooltipOrientation = \"horizontal\";\n      }\n      this.axis.updateTooltip(tooltipOrientation, {\n        x: bbx,\n        y: bby,\n        width: bbw,\n        height: bbh\n      });\n    }\n  };\n  /**\r\n   * Updates and positions a tick element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param tick      Tick element\r\n   * @param position  Position\r\n   */\n  AxisRendererRadial.prototype.updateTickElement = function (tick, position, endPosition) {\n    position = position + (endPosition - position) * tick.location;\n    var point = this.positionToPoint(position);\n    if (tick.element) {\n      var angle = $math.normalizeAngle(this.axisAngle + 90);\n      if (angle / 90 != Math.round(angle / 90)) {\n        tick.pixelPerfect = false;\n      } else {\n        tick.pixelPerfect = true;\n      }\n      var tickLength = -tick.length;\n      if (tick.inside) {\n        tickLength *= -1;\n      }\n      tick.path = $path.moveTo({\n        x: 0,\n        y: 0\n      }) + $path.lineTo({\n        x: tickLength * $math.cos(angle),\n        y: tickLength * $math.sin(angle)\n      });\n    }\n    this.positionItem(tick, point);\n    this.toggleVisibility(tick, position, 0, 1);\n  };\n  /**\r\n   * Updates and positions axis bullet.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param bullet       AxisBullet element\r\n   * @param position     Starting position\r\n   * @param endPosition  End position\r\n   */\n  AxisRendererRadial.prototype.updateBullet = function (bullet, position, endPosition) {\n    var location = 0.5;\n    if (bullet instanceof AxisBullet) {\n      location = bullet.location;\n    }\n    position = position + (endPosition - position) * location;\n    var point = this.positionToPoint(position);\n    this.positionItem(bullet, point);\n    this.toggleVisibility(bullet, position, 0, 1);\n  };\n  /**\r\n   * Converts a position on the axis to a coordinate in pixels.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position (0-1)\r\n   * @return Coordinate (px)\r\n   */\n  AxisRendererRadial.prototype.positionToCoordinate = function (position) {\n    var coordinate;\n    var axis = this.axis;\n    var axisFullLength = axis.axisFullLength;\n    var innerRadius = this.pixelInnerRadius;\n    if (axis.renderer.inversed) {\n      coordinate = (axis.end - position) * axisFullLength + innerRadius;\n    } else {\n      coordinate = (position - axis.start) * axisFullLength + innerRadius;\n    }\n    return $math.round(coordinate, 1);\n  };\n  /**\r\n   * Converts a point at specific coordinates to a relative position (0-1)\r\n   * on the axis.\r\n   *\r\n   * @param point  Point\r\n   * @return Position (0-1)\r\n   */\n  AxisRendererRadial.prototype.pointToPosition = function (point) {\n    var coordinate = $math.getDistance(point) - this.pixelInnerRadius;\n    return this.coordinateToPosition(coordinate);\n  };\n  Object.defineProperty(AxisRendererRadial.prototype, \"chart\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Chart\r\n     */\n    get: function () {\n      return this._chart.get();\n    },\n    /**\r\n     * A chart, associated with the Axis.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value  Chart\r\n     */\n    set: function (value) {\n      this._chart.set(value, null);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return AxisRendererRadial;\n}(AxisRendererY);\nexport { AxisRendererRadial };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"AxisRendererRadial\"] = AxisRendererRadial;","map":{"version":3,"names":["__extends","AxisRendererY","CategoryAxis","WavedCircle","MutableValueDisposer","Percent","percent","registry","$math","$path","$utils","$type","AxisBullet","AxisRendererRadial","_super","_this","call","_chart","pixelRadiusReal","className","isMeasured","startAngle","endAngle","minGridDistance","gridType","axisAngle","layout","radius","line","strokeOpacity","labels","template","horizontalCenter","_disposers","push","applyTheme","prototype","validate","chart","invalid","Object","defineProperty","get","pixelRadius","pixelInnerRadius","enumerable","configurable","getPropertyValue","set","value","setPercentProperty","relativeRadiusToValue","innerRadius","hasValue","innerRadiusModifyer","mr","Math","max","min","plotContainer","innerHeight","innerWidth","positionToPoint","position","position2","fitToRange","positionToCoordinate","Infinity","x","cos","y","sin","updateAxisLine","path","moveTo","lineTo","title","axis","valign","verticalCenter","axisLength","rotation","opposite","inside","updateGridElement","grid","endPosition","location","point","getDistance","isNumber","element","xAxis","xAxes","getIndex","count","series","dataItems","length","gridLocation","renderer","angle","getAngle","i","cellEndLocation","arcTo","toggleVisibility","updateLabelElement","label","positionItem","minLabelPosition","maxLabelPosition","updateBaseGridElement","fitsToBounds","setPropertyValue","invalidateAxisItems","normalizeAngle","getPositionRangePath","startPosition","arc","updateBreakElement","axisBreak","startLine","endLine","fillShape","startPoint","endPoint","abs","createBreakSprites","updateTooltip","bigNum","bbx","bby","bbw","bbh","tooltipOrientation","width","height","updateTickElement","tick","round","pixelPerfect","tickLength","updateBullet","bullet","coordinate","axisFullLength","inversed","end","start","pointToPosition","coordinateToPosition","registeredClasses"],"sources":["D:/alodelivery test/node_modules/@amcharts/amcharts4/.internal/charts/axes/AxisRendererRadial.js"],"sourcesContent":["/**\r\n * Module, defining Axis Renderer for radial axes.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { AxisRendererY } from \"./AxisRendererY\";\r\nimport { CategoryAxis } from \"./CategoryAxis\";\r\nimport { WavedCircle } from \"../../core/elements/WavedCircle\";\r\nimport { MutableValueDisposer } from \"../../core/utils/Disposer\";\r\nimport { Percent, percent } from \"../../core/utils/Percent\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport { AxisBullet } from \"./AxisBullet\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * A renderer for radial axis.\r\n */\r\nvar AxisRendererRadial = /** @class */ (function (_super) {\r\n    __extends(AxisRendererRadial, _super);\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @param axis Related axis\r\n     */\r\n    function AxisRendererRadial() {\r\n        var _this = \r\n        // Init\r\n        _super.call(this) || this;\r\n        /**\r\n         * A related chart.\r\n         */\r\n        _this._chart = new MutableValueDisposer();\r\n        /**\r\n         * @ignore\r\n         */\r\n        _this.pixelRadiusReal = 0;\r\n        _this.className = \"AxisRendererRadial\";\r\n        _this.isMeasured = false;\r\n        _this.startAngle = -90;\r\n        _this.endAngle = 270;\r\n        _this.minGridDistance = 30;\r\n        _this.gridType = \"circles\";\r\n        _this.axisAngle = -90;\r\n        _this.isMeasured = false;\r\n        _this.layout = \"none\";\r\n        _this.radius = percent(100);\r\n        _this.line.strokeOpacity = 0;\r\n        _this.labels.template.horizontalCenter = \"middle\";\r\n        _this._disposers.push(_this._chart);\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    /**\r\n     * Validates Axis renderer.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    AxisRendererRadial.prototype.validate = function () {\r\n        // so that radius would be updated\r\n        if (this.chart && this.chart.invalid) {\r\n            this.chart.validate();\r\n        }\r\n        _super.prototype.validate.call(this);\r\n    };\r\n    Object.defineProperty(AxisRendererRadial.prototype, \"axisLength\", {\r\n        /**\r\n         * Returns actual length of the Axis, in pixels.\r\n         *\r\n         * @return Length (px)\r\n         */\r\n        get: function () {\r\n            return this.pixelRadius - this.pixelInnerRadius;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisRendererRadial.prototype, \"radius\", {\r\n        /**\r\n         * @return Outer radius\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"radius\");\r\n        },\r\n        /**\r\n         * Outer radius of the axis.\r\n         *\r\n         * Can be absolute (px) or relative ([[Percent]]).\r\n         *\r\n         * @param value  Outer radius\r\n         */\r\n        set: function (value) {\r\n            this.setPercentProperty(\"radius\", value, false, false, 10, false);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisRendererRadial.prototype, \"pixelRadius\", {\r\n        /**\r\n         * Outer radius in pixels.\r\n         *\r\n         * @return Outer radius (px)\r\n         */\r\n        get: function () {\r\n            return $utils.relativeRadiusToValue(this.radius, this.pixelRadiusReal) || 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisRendererRadial.prototype, \"innerRadius\", {\r\n        /**\r\n         * @return Inner radius\r\n         */\r\n        get: function () {\r\n            var chart = this.chart;\r\n            var innerRadius = this.getPropertyValue(\"innerRadius\");\r\n            if (chart) {\r\n                if (!$type.hasValue(innerRadius)) {\r\n                    innerRadius = chart.innerRadius;\r\n                    if (innerRadius instanceof Percent && chart) {\r\n                        innerRadius = percent(innerRadius.value * chart.innerRadiusModifyer * 100);\r\n                    }\r\n                }\r\n                else {\r\n                    if (innerRadius instanceof Percent && chart) {\r\n                        var mr = chart.mr;\r\n                        var value = innerRadius.value;\r\n                        value = Math.max(mr * value, mr - Math.min(chart.plotContainer.innerHeight, chart.plotContainer.innerWidth)) / mr;\r\n                        innerRadius = percent(value * 100);\r\n                    }\r\n                }\r\n            }\r\n            return innerRadius;\r\n        },\r\n        /**\r\n         * Inner radius of the axis.\r\n         *\r\n         * Can be absolute (px) or relative ([[Percent]]).\r\n         *\r\n         * @param value  Outer radius\r\n         */\r\n        set: function (value) {\r\n            this.setPercentProperty(\"innerRadius\", value, false, false, 10, false);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisRendererRadial.prototype, \"pixelInnerRadius\", {\r\n        /**\r\n         * Inner radius in pixels.\r\n         *\r\n         * @return Inner radius (px)\r\n         */\r\n        get: function () {\r\n            return $utils.relativeRadiusToValue(this.innerRadius, this.pixelRadiusReal) || 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Converts relative position on axis to point coordinates.\r\n     *\r\n     * @param position  Position (0-1)\r\n     * @param position2  Position (0-1) Position on the second axis\r\n     * @return Point\r\n     */\r\n    AxisRendererRadial.prototype.positionToPoint = function (position, position2) {\r\n        var radius = $math.fitToRange(this.positionToCoordinate(position), 0, Infinity);\r\n        return { x: radius * $math.cos(this.axisAngle), y: radius * $math.sin(this.axisAngle) };\r\n    };\r\n    /**\r\n     * Updates and positions the axis line element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    AxisRendererRadial.prototype.updateAxisLine = function () {\r\n        this.line.path = $path.moveTo({ x: this.pixelInnerRadius * $math.cos(this.axisAngle), y: this.pixelInnerRadius * $math.sin(this.axisAngle) }) + $path.lineTo({ x: this.pixelRadius * $math.cos(this.axisAngle), y: this.pixelRadius * $math.sin(this.axisAngle) });\r\n        var title = this.axis.title;\r\n        title.valign = \"none\";\r\n        title.horizontalCenter = \"middle\";\r\n        title.verticalCenter = \"bottom\";\r\n        title.y = -this.axisLength / 2;\r\n        var rotation = 90;\r\n        if (this.opposite) {\r\n            if (!this.inside) {\r\n                rotation = -90;\r\n            }\r\n        }\r\n        else {\r\n            if (this.inside) {\r\n                rotation = -90;\r\n            }\r\n        }\r\n        title.rotation = rotation;\r\n    };\r\n    /**\r\n     * Updates and positions a grid element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param grid         Grid element\r\n     * @param position     Starting position\r\n     * @param endPosition  End position\r\n     */\r\n    AxisRendererRadial.prototype.updateGridElement = function (grid, position, endPosition) {\r\n        position = position + (endPosition - position) * grid.location;\r\n        var point = this.positionToPoint(position);\r\n        var path;\r\n        var radius = $math.getDistance(point);\r\n        var startAngle = this.startAngle;\r\n        var endAngle = this.endAngle;\r\n        var chart = this.chart;\r\n        if ($type.isNumber(radius) && grid.element && chart) {\r\n            var xAxis = chart.xAxes.getIndex(0);\r\n            var count = 0;\r\n            var series = chart.series.getIndex(0);\r\n            if (series) {\r\n                count = series.dataItems.length;\r\n            }\r\n            // polygons are only possible if x axis is present\r\n            // @todo: review this\r\n            if (this.gridType == \"polygons\" && count > 0 && series && xAxis && xAxis instanceof CategoryAxis) {\r\n                var gridLocation = xAxis.renderer.grid.template.location;\r\n                var angle = xAxis.getAngle(series.dataItems.getIndex(0), \"categoryX\", gridLocation);\r\n                path = $path.moveTo({ x: radius * $math.cos(angle), y: radius * $math.sin(angle) });\r\n                for (var i = 1; i < count; i++) {\r\n                    angle = xAxis.getAngle(series.dataItems.getIndex(i), \"categoryX\", gridLocation);\r\n                    path += $path.lineTo({ x: radius * $math.cos(angle), y: radius * $math.sin(angle) });\r\n                }\r\n                angle = xAxis.getAngle(series.dataItems.getIndex(count - 1), \"categoryX\", xAxis.renderer.cellEndLocation);\r\n                path += $path.lineTo({ x: radius * $math.cos(angle), y: radius * $math.sin(angle) });\r\n            }\r\n            else {\r\n                path = $path.moveTo({ x: radius * $math.cos(startAngle), y: radius * $math.sin(startAngle) }) + $path.arcTo(startAngle, endAngle - startAngle, radius, radius);\r\n            }\r\n            grid.path = path;\r\n        }\r\n        this.toggleVisibility(grid, position, 0, 1);\r\n    };\r\n    /**\r\n     * Updates and positions a label element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param label        Label element\r\n     * @param position     Starting position\r\n     * @param endPosition  Ending position\r\n     */\r\n    AxisRendererRadial.prototype.updateLabelElement = function (label, position, endPosition, location) {\r\n        if (!$type.hasValue(location)) {\r\n            location = label.location;\r\n        }\r\n        position = position + (endPosition - position) * location;\r\n        var point = this.positionToPoint(position);\r\n        this.positionItem(label, point);\r\n        this.toggleVisibility(label, position, this.minLabelPosition, this.maxLabelPosition);\r\n    };\r\n    /**\r\n     * Updates and positions the base grid element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    AxisRendererRadial.prototype.updateBaseGridElement = function () {\r\n        // @todo? zero grid for radar chart, is it needed?\r\n    };\r\n    /**\r\n     * Checks if point is within bounds of a container.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param point Point coordinates\r\n     * @return Fits?\r\n     */\r\n    AxisRendererRadial.prototype.fitsToBounds = function (point) {\r\n        return true;\r\n    };\r\n    Object.defineProperty(AxisRendererRadial.prototype, \"startAngle\", {\r\n        /**\r\n         * @return Start angle\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"startAngle\");\r\n        },\r\n        /**\r\n         * Start angle of the axis in degrees. (0-360)\r\n         *\r\n         * @param value  Start angle\r\n         */\r\n        set: function (value) {\r\n            // do not normalize angle here!\r\n            if (this.setPropertyValue(\"startAngle\", value)) {\r\n                this.invalidateAxisItems();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisRendererRadial.prototype, \"endAngle\", {\r\n        /**\r\n         * @return End angle\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"endAngle\");\r\n        },\r\n        /**\r\n         * End angle of the axis in degrees. (0-360)\r\n         *\r\n         * @param value  End angle\r\n         */\r\n        set: function (value) {\r\n            // do not normalize angel here!\r\n            if (this.setPropertyValue(\"endAngle\", value)) {\r\n                this.invalidateAxisItems();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisRendererRadial.prototype, \"axisAngle\", {\r\n        /**\r\n         * @return Axis angle\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"axisAngle\");\r\n            //return $math.fitToRange(this.getPropertyValue(\"axisAngle\"), this.startAngle, this.endAngle); // no good, as less flexible\r\n        },\r\n        /**\r\n         * Angle of the radial axis in degrees. (0-360)\r\n         *\r\n         * @param value  Axis angle\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"axisAngle\", $math.normalizeAngle(value));\r\n            this.invalidateAxisItems();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(AxisRendererRadial.prototype, \"gridType\", {\r\n        /**\r\n         * Grid type\r\n         */\r\n        get: function () {\r\n            var axis = this.chart.xAxes.getIndex(0);\r\n            if (axis instanceof CategoryAxis) {\r\n                return this.getPropertyValue(\"gridType\");\r\n            }\r\n            else {\r\n                return \"circles\";\r\n            }\r\n        },\r\n        // polygons grid type is only possible under these conditions: xAxis is available and it is CategoryAxis, also at least one series should be added to a chart\r\n        /**\r\n         * Grid type for radial axis.\r\n         *\r\n         * A grid on radia axis can either be perfect circles (\"circles\"), or\r\n         * straight lines (\"polygons\").\r\n         *\r\n         * @default \"circles\"\r\n         * @param value  Grid type\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"gridType\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * [getPositionRangePath description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param startPosition  Starting position\r\n     * @param endPosition    End position\r\n     * @return SVG path\r\n     */\r\n    AxisRendererRadial.prototype.getPositionRangePath = function (startPosition, endPosition) {\r\n        var pixelInnerRadius = this.pixelInnerRadius;\r\n        var pixelRadius = this.axisLength + pixelInnerRadius;\r\n        var innerRadius = $math.fitToRange(this.positionToCoordinate(startPosition), pixelInnerRadius, pixelRadius);\r\n        var radius = $math.fitToRange(this.positionToCoordinate(endPosition), pixelInnerRadius, pixelRadius);\r\n        //let angleCount: number = this.angleCount;\r\n        var startAngle = this.startAngle;\r\n        var endAngle = this.endAngle;\r\n        var arc = endAngle - startAngle;\r\n        var path;\r\n        var chart = this.chart;\r\n        var xAxis = chart.xAxes.getIndex(0);\r\n        var series = chart.series.getIndex(0);\r\n        var count = 0;\r\n        if (series) {\r\n            count = series.dataItems.length;\r\n        }\r\n        // polygons are only possible if x axis is present\r\n        // @todo: review this\r\n        if (this.gridType == \"polygons\" && count > 0 && series && xAxis && xAxis instanceof CategoryAxis) {\r\n            var gridLocation = xAxis.renderer.grid.template.location;\r\n            var angle = xAxis.getAngle(series.dataItems.getIndex(0), \"categoryX\", gridLocation);\r\n            path = $path.moveTo({ x: radius * $math.cos(angle), y: radius * $math.sin(angle) });\r\n            for (var i = 1; i < count; i++) {\r\n                angle = xAxis.getAngle(series.dataItems.getIndex(i), \"categoryX\", gridLocation);\r\n                path += $path.lineTo({ x: radius * $math.cos(angle), y: radius * $math.sin(angle) });\r\n            }\r\n            angle = xAxis.getAngle(series.dataItems.getIndex(count - 1), \"categoryX\", xAxis.renderer.cellEndLocation);\r\n            path += $path.lineTo({ x: radius * $math.cos(angle), y: radius * $math.sin(angle) });\r\n            path += $path.moveTo({ x: innerRadius * $math.cos(angle), y: innerRadius * $math.sin(angle) });\r\n            for (var i = count - 1; i >= 0; i--) {\r\n                angle = xAxis.getAngle(series.dataItems.getIndex(i), \"categoryX\", gridLocation);\r\n                path += $path.lineTo({ x: innerRadius * $math.cos(angle), y: innerRadius * $math.sin(angle) });\r\n            }\r\n        }\r\n        else {\r\n            path = $path.arc(startAngle, arc, radius, innerRadius);\r\n        }\r\n        return path;\r\n    };\r\n    /**\r\n     * Updates and positions an axis break element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param axisBreak Break element\r\n     */\r\n    AxisRendererRadial.prototype.updateBreakElement = function (axisBreak) {\r\n        // @todo: someday we might need axis break when gridType is polygons\r\n        var startLine = axisBreak.startLine;\r\n        var endLine = axisBreak.endLine;\r\n        var fillShape = axisBreak.fillShape;\r\n        var startPoint = axisBreak.startPoint;\r\n        var endPoint = axisBreak.endPoint;\r\n        startLine.radius = Math.abs(startPoint.y);\r\n        endLine.radius = Math.abs(endPoint.y);\r\n        fillShape.radius = Math.abs(endPoint.y);\r\n        fillShape.innerRadius = Math.abs(startPoint.y);\r\n    };\r\n    /**\r\n     * Creates visual elements for and axis break.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param axisBreak Axis break\r\n     */\r\n    AxisRendererRadial.prototype.createBreakSprites = function (axisBreak) {\r\n        axisBreak.startLine = new WavedCircle();\r\n        axisBreak.endLine = new WavedCircle();\r\n        axisBreak.fillShape = new WavedCircle();\r\n    };\r\n    /**\r\n     * Updates some of the Axis tooltip's visual properties, related to\r\n     * rendering of the Axis.\r\n     *\r\n     * @todo Description (review)\r\n     * @ignore Exclude from docs\r\n     */\r\n    AxisRendererRadial.prototype.updateTooltip = function () {\r\n        var axis = this.axis;\r\n        if (axis) {\r\n            var bigNum = 4000;\r\n            var bbx = -4000;\r\n            var bby = -4000;\r\n            var bbw = bigNum * 2;\r\n            var bbh = bigNum * 2;\r\n            var axisAngle = this.axisAngle;\r\n            if (axisAngle < 0) {\r\n                axisAngle += 360;\r\n            }\r\n            var tooltipOrientation = \"vertical\";\r\n            if ((axisAngle > 45 && axisAngle < 135) || (axisAngle > 225 && axisAngle < 315)) {\r\n                tooltipOrientation = \"horizontal\";\r\n            }\r\n            this.axis.updateTooltip(tooltipOrientation, { x: bbx, y: bby, width: bbw, height: bbh });\r\n        }\r\n    };\r\n    /**\r\n     * Updates and positions a tick element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param tick      Tick element\r\n     * @param position  Position\r\n     */\r\n    AxisRendererRadial.prototype.updateTickElement = function (tick, position, endPosition) {\r\n        position = position + (endPosition - position) * tick.location;\r\n        var point = this.positionToPoint(position);\r\n        if (tick.element) {\r\n            var angle = $math.normalizeAngle(this.axisAngle + 90);\r\n            if (angle / 90 != Math.round(angle / 90)) {\r\n                tick.pixelPerfect = false;\r\n            }\r\n            else {\r\n                tick.pixelPerfect = true;\r\n            }\r\n            var tickLength = -tick.length;\r\n            if (tick.inside) {\r\n                tickLength *= -1;\r\n            }\r\n            tick.path = $path.moveTo({ x: 0, y: 0 }) + $path.lineTo({ x: tickLength * $math.cos(angle), y: tickLength * $math.sin(angle) });\r\n        }\r\n        this.positionItem(tick, point);\r\n        this.toggleVisibility(tick, position, 0, 1);\r\n    };\r\n    /**\r\n     * Updates and positions axis bullet.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param bullet       AxisBullet element\r\n     * @param position     Starting position\r\n     * @param endPosition  End position\r\n     */\r\n    AxisRendererRadial.prototype.updateBullet = function (bullet, position, endPosition) {\r\n        var location = 0.5;\r\n        if (bullet instanceof AxisBullet) {\r\n            location = bullet.location;\r\n        }\r\n        position = position + (endPosition - position) * location;\r\n        var point = this.positionToPoint(position);\r\n        this.positionItem(bullet, point);\r\n        this.toggleVisibility(bullet, position, 0, 1);\r\n    };\r\n    /**\r\n     * Converts a position on the axis to a coordinate in pixels.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param position  Position (0-1)\r\n     * @return Coordinate (px)\r\n     */\r\n    AxisRendererRadial.prototype.positionToCoordinate = function (position) {\r\n        var coordinate;\r\n        var axis = this.axis;\r\n        var axisFullLength = axis.axisFullLength;\r\n        var innerRadius = this.pixelInnerRadius;\r\n        if (axis.renderer.inversed) {\r\n            coordinate = (axis.end - position) * axisFullLength + innerRadius;\r\n        }\r\n        else {\r\n            coordinate = (position - axis.start) * axisFullLength + innerRadius;\r\n        }\r\n        return $math.round(coordinate, 1);\r\n    };\r\n    /**\r\n     * Converts a point at specific coordinates to a relative position (0-1)\r\n     * on the axis.\r\n     *\r\n     * @param point  Point\r\n     * @return Position (0-1)\r\n     */\r\n    AxisRendererRadial.prototype.pointToPosition = function (point) {\r\n        var coordinate = ($math.getDistance(point) - this.pixelInnerRadius);\r\n        return this.coordinateToPosition(coordinate);\r\n    };\r\n    Object.defineProperty(AxisRendererRadial.prototype, \"chart\", {\r\n        /**\r\n         * @ignore Exclude from docs\r\n         * @return Chart\r\n         */\r\n        get: function () {\r\n            return this._chart.get();\r\n        },\r\n        /**\r\n         * A chart, associated with the Axis.\r\n         *\r\n         * @ignore Exclude from docs\r\n         * @param value  Chart\r\n         */\r\n        set: function (value) {\r\n            this._chart.set(value, null);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return AxisRendererRadial;\r\n}(AxisRendererY));\r\nexport { AxisRendererRadial };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"AxisRendererRadial\"] = AxisRendererRadial;\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,SAAS,QAAQ,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,YAAY,QAAQ,gBAAgB;AAC7C,SAASC,WAAW,QAAQ,iCAAiC;AAC7D,SAASC,oBAAoB,QAAQ,2BAA2B;AAChE,SAASC,OAAO,EAAEC,OAAO,QAAQ,0BAA0B;AAC3D,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,OAAO,KAAKC,KAAK,MAAM,uBAAuB;AAC9C,OAAO,KAAKC,KAAK,MAAM,2BAA2B;AAClD,OAAO,KAAKC,MAAM,MAAM,wBAAwB;AAChD,OAAO,KAAKC,KAAK,MAAM,uBAAuB;AAC9C,SAASC,UAAU,QAAQ,cAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,kBAAkB,GAAG,aAAe,UAAUC,MAAM,EAAE;EACtDd,SAAS,CAACa,kBAAkB,EAAEC,MAAM,CAAC;EACrC;AACJ;AACA;AACA;AACA;EACI,SAASD,kBAAkBA,CAAA,EAAG;IAC1B,IAAIE,KAAK;IACT;IACAD,MAAM,CAACE,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI;IACzB;AACR;AACA;IACQD,KAAK,CAACE,MAAM,GAAG,IAAIb,oBAAoB,CAAC,CAAC;IACzC;AACR;AACA;IACQW,KAAK,CAACG,eAAe,GAAG,CAAC;IACzBH,KAAK,CAACI,SAAS,GAAG,oBAAoB;IACtCJ,KAAK,CAACK,UAAU,GAAG,KAAK;IACxBL,KAAK,CAACM,UAAU,GAAG,CAAC,EAAE;IACtBN,KAAK,CAACO,QAAQ,GAAG,GAAG;IACpBP,KAAK,CAACQ,eAAe,GAAG,EAAE;IAC1BR,KAAK,CAACS,QAAQ,GAAG,SAAS;IAC1BT,KAAK,CAACU,SAAS,GAAG,CAAC,EAAE;IACrBV,KAAK,CAACK,UAAU,GAAG,KAAK;IACxBL,KAAK,CAACW,MAAM,GAAG,MAAM;IACrBX,KAAK,CAACY,MAAM,GAAGrB,OAAO,CAAC,GAAG,CAAC;IAC3BS,KAAK,CAACa,IAAI,CAACC,aAAa,GAAG,CAAC;IAC5Bd,KAAK,CAACe,MAAM,CAACC,QAAQ,CAACC,gBAAgB,GAAG,QAAQ;IACjDjB,KAAK,CAACkB,UAAU,CAACC,IAAI,CAACnB,KAAK,CAACE,MAAM,CAAC;IACnCF,KAAK,CAACoB,UAAU,CAAC,CAAC;IAClB,OAAOpB,KAAK;EAChB;EACA;AACJ;AACA;AACA;AACA;EACIF,kBAAkB,CAACuB,SAAS,CAACC,QAAQ,GAAG,YAAY;IAChD;IACA,IAAI,IAAI,CAACC,KAAK,IAAI,IAAI,CAACA,KAAK,CAACC,OAAO,EAAE;MAClC,IAAI,CAACD,KAAK,CAACD,QAAQ,CAAC,CAAC;IACzB;IACAvB,MAAM,CAACsB,SAAS,CAACC,QAAQ,CAACrB,IAAI,CAAC,IAAI,CAAC;EACxC,CAAC;EACDwB,MAAM,CAACC,cAAc,CAAC5B,kBAAkB,CAACuB,SAAS,EAAE,YAAY,EAAE;IAC9D;AACR;AACA;AACA;AACA;IACQM,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACC,WAAW,GAAG,IAAI,CAACC,gBAAgB;IACnD,CAAC;IACDC,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFN,MAAM,CAACC,cAAc,CAAC5B,kBAAkB,CAACuB,SAAS,EAAE,QAAQ,EAAE;IAC1D;AACR;AACA;IACQM,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACK,gBAAgB,CAAC,QAAQ,CAAC;IAC1C,CAAC;IACD;AACR;AACA;AACA;AACA;AACA;AACA;IACQC,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MAClB,IAAI,CAACC,kBAAkB,CAAC,QAAQ,EAAED,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,KAAK,CAAC;IACrE,CAAC;IACDJ,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFN,MAAM,CAACC,cAAc,CAAC5B,kBAAkB,CAACuB,SAAS,EAAE,aAAa,EAAE;IAC/D;AACR;AACA;AACA;AACA;IACQM,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAOhC,MAAM,CAACyC,qBAAqB,CAAC,IAAI,CAACxB,MAAM,EAAE,IAAI,CAACT,eAAe,CAAC,IAAI,CAAC;IAC/E,CAAC;IACD2B,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFN,MAAM,CAACC,cAAc,CAAC5B,kBAAkB,CAACuB,SAAS,EAAE,aAAa,EAAE;IAC/D;AACR;AACA;IACQM,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,IAAIJ,KAAK,GAAG,IAAI,CAACA,KAAK;MACtB,IAAIc,WAAW,GAAG,IAAI,CAACL,gBAAgB,CAAC,aAAa,CAAC;MACtD,IAAIT,KAAK,EAAE;QACP,IAAI,CAAC3B,KAAK,CAAC0C,QAAQ,CAACD,WAAW,CAAC,EAAE;UAC9BA,WAAW,GAAGd,KAAK,CAACc,WAAW;UAC/B,IAAIA,WAAW,YAAY/C,OAAO,IAAIiC,KAAK,EAAE;YACzCc,WAAW,GAAG9C,OAAO,CAAC8C,WAAW,CAACH,KAAK,GAAGX,KAAK,CAACgB,mBAAmB,GAAG,GAAG,CAAC;UAC9E;QACJ,CAAC,MACI;UACD,IAAIF,WAAW,YAAY/C,OAAO,IAAIiC,KAAK,EAAE;YACzC,IAAIiB,EAAE,GAAGjB,KAAK,CAACiB,EAAE;YACjB,IAAIN,KAAK,GAAGG,WAAW,CAACH,KAAK;YAC7BA,KAAK,GAAGO,IAAI,CAACC,GAAG,CAACF,EAAE,GAAGN,KAAK,EAAEM,EAAE,GAAGC,IAAI,CAACE,GAAG,CAACpB,KAAK,CAACqB,aAAa,CAACC,WAAW,EAAEtB,KAAK,CAACqB,aAAa,CAACE,UAAU,CAAC,CAAC,GAAGN,EAAE;YACjHH,WAAW,GAAG9C,OAAO,CAAC2C,KAAK,GAAG,GAAG,CAAC;UACtC;QACJ;MACJ;MACA,OAAOG,WAAW;IACtB,CAAC;IACD;AACR;AACA;AACA;AACA;AACA;AACA;IACQJ,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MAClB,IAAI,CAACC,kBAAkB,CAAC,aAAa,EAAED,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,KAAK,CAAC;IAC1E,CAAC;IACDJ,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFN,MAAM,CAACC,cAAc,CAAC5B,kBAAkB,CAACuB,SAAS,EAAE,kBAAkB,EAAE;IACpE;AACR;AACA;AACA;AACA;IACQM,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAOhC,MAAM,CAACyC,qBAAqB,CAAC,IAAI,CAACC,WAAW,EAAE,IAAI,CAAClC,eAAe,CAAC,IAAI,CAAC;IACpF,CAAC;IACD2B,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF;AACJ;AACA;AACA;AACA;AACA;AACA;EACIjC,kBAAkB,CAACuB,SAAS,CAAC0B,eAAe,GAAG,UAAUC,QAAQ,EAAEC,SAAS,EAAE;IAC1E,IAAIrC,MAAM,GAAGnB,KAAK,CAACyD,UAAU,CAAC,IAAI,CAACC,oBAAoB,CAACH,QAAQ,CAAC,EAAE,CAAC,EAAEI,QAAQ,CAAC;IAC/E,OAAO;MAAEC,CAAC,EAAEzC,MAAM,GAAGnB,KAAK,CAAC6D,GAAG,CAAC,IAAI,CAAC5C,SAAS,CAAC;MAAE6C,CAAC,EAAE3C,MAAM,GAAGnB,KAAK,CAAC+D,GAAG,CAAC,IAAI,CAAC9C,SAAS;IAAE,CAAC;EAC3F,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIZ,kBAAkB,CAACuB,SAAS,CAACoC,cAAc,GAAG,YAAY;IACtD,IAAI,CAAC5C,IAAI,CAAC6C,IAAI,GAAGhE,KAAK,CAACiE,MAAM,CAAC;MAAEN,CAAC,EAAE,IAAI,CAACxB,gBAAgB,GAAGpC,KAAK,CAAC6D,GAAG,CAAC,IAAI,CAAC5C,SAAS,CAAC;MAAE6C,CAAC,EAAE,IAAI,CAAC1B,gBAAgB,GAAGpC,KAAK,CAAC+D,GAAG,CAAC,IAAI,CAAC9C,SAAS;IAAE,CAAC,CAAC,GAAGhB,KAAK,CAACkE,MAAM,CAAC;MAAEP,CAAC,EAAE,IAAI,CAACzB,WAAW,GAAGnC,KAAK,CAAC6D,GAAG,CAAC,IAAI,CAAC5C,SAAS,CAAC;MAAE6C,CAAC,EAAE,IAAI,CAAC3B,WAAW,GAAGnC,KAAK,CAAC+D,GAAG,CAAC,IAAI,CAAC9C,SAAS;IAAE,CAAC,CAAC;IAClQ,IAAImD,KAAK,GAAG,IAAI,CAACC,IAAI,CAACD,KAAK;IAC3BA,KAAK,CAACE,MAAM,GAAG,MAAM;IACrBF,KAAK,CAAC5C,gBAAgB,GAAG,QAAQ;IACjC4C,KAAK,CAACG,cAAc,GAAG,QAAQ;IAC/BH,KAAK,CAACN,CAAC,GAAG,CAAC,IAAI,CAACU,UAAU,GAAG,CAAC;IAC9B,IAAIC,QAAQ,GAAG,EAAE;IACjB,IAAI,IAAI,CAACC,QAAQ,EAAE;MACf,IAAI,CAAC,IAAI,CAACC,MAAM,EAAE;QACdF,QAAQ,GAAG,CAAC,EAAE;MAClB;IACJ,CAAC,MACI;MACD,IAAI,IAAI,CAACE,MAAM,EAAE;QACbF,QAAQ,GAAG,CAAC,EAAE;MAClB;IACJ;IACAL,KAAK,CAACK,QAAQ,GAAGA,QAAQ;EAC7B,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIpE,kBAAkB,CAACuB,SAAS,CAACgD,iBAAiB,GAAG,UAAUC,IAAI,EAAEtB,QAAQ,EAAEuB,WAAW,EAAE;IACpFvB,QAAQ,GAAGA,QAAQ,GAAG,CAACuB,WAAW,GAAGvB,QAAQ,IAAIsB,IAAI,CAACE,QAAQ;IAC9D,IAAIC,KAAK,GAAG,IAAI,CAAC1B,eAAe,CAACC,QAAQ,CAAC;IAC1C,IAAIU,IAAI;IACR,IAAI9C,MAAM,GAAGnB,KAAK,CAACiF,WAAW,CAACD,KAAK,CAAC;IACrC,IAAInE,UAAU,GAAG,IAAI,CAACA,UAAU;IAChC,IAAIC,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC5B,IAAIgB,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAI3B,KAAK,CAAC+E,QAAQ,CAAC/D,MAAM,CAAC,IAAI0D,IAAI,CAACM,OAAO,IAAIrD,KAAK,EAAE;MACjD,IAAIsD,KAAK,GAAGtD,KAAK,CAACuD,KAAK,CAACC,QAAQ,CAAC,CAAC,CAAC;MACnC,IAAIC,KAAK,GAAG,CAAC;MACb,IAAIC,MAAM,GAAG1D,KAAK,CAAC0D,MAAM,CAACF,QAAQ,CAAC,CAAC,CAAC;MACrC,IAAIE,MAAM,EAAE;QACRD,KAAK,GAAGC,MAAM,CAACC,SAAS,CAACC,MAAM;MACnC;MACA;MACA;MACA,IAAI,IAAI,CAAC1E,QAAQ,IAAI,UAAU,IAAIuE,KAAK,GAAG,CAAC,IAAIC,MAAM,IAAIJ,KAAK,IAAIA,KAAK,YAAY1F,YAAY,EAAE;QAC9F,IAAIiG,YAAY,GAAGP,KAAK,CAACQ,QAAQ,CAACf,IAAI,CAACtD,QAAQ,CAACwD,QAAQ;QACxD,IAAIc,KAAK,GAAGT,KAAK,CAACU,QAAQ,CAACN,MAAM,CAACC,SAAS,CAACH,QAAQ,CAAC,CAAC,CAAC,EAAE,WAAW,EAAEK,YAAY,CAAC;QACnF1B,IAAI,GAAGhE,KAAK,CAACiE,MAAM,CAAC;UAAEN,CAAC,EAAEzC,MAAM,GAAGnB,KAAK,CAAC6D,GAAG,CAACgC,KAAK,CAAC;UAAE/B,CAAC,EAAE3C,MAAM,GAAGnB,KAAK,CAAC+D,GAAG,CAAC8B,KAAK;QAAE,CAAC,CAAC;QACnF,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,KAAK,EAAEQ,CAAC,EAAE,EAAE;UAC5BF,KAAK,GAAGT,KAAK,CAACU,QAAQ,CAACN,MAAM,CAACC,SAAS,CAACH,QAAQ,CAACS,CAAC,CAAC,EAAE,WAAW,EAAEJ,YAAY,CAAC;UAC/E1B,IAAI,IAAIhE,KAAK,CAACkE,MAAM,CAAC;YAAEP,CAAC,EAAEzC,MAAM,GAAGnB,KAAK,CAAC6D,GAAG,CAACgC,KAAK,CAAC;YAAE/B,CAAC,EAAE3C,MAAM,GAAGnB,KAAK,CAAC+D,GAAG,CAAC8B,KAAK;UAAE,CAAC,CAAC;QACxF;QACAA,KAAK,GAAGT,KAAK,CAACU,QAAQ,CAACN,MAAM,CAACC,SAAS,CAACH,QAAQ,CAACC,KAAK,GAAG,CAAC,CAAC,EAAE,WAAW,EAAEH,KAAK,CAACQ,QAAQ,CAACI,eAAe,CAAC;QACzG/B,IAAI,IAAIhE,KAAK,CAACkE,MAAM,CAAC;UAAEP,CAAC,EAAEzC,MAAM,GAAGnB,KAAK,CAAC6D,GAAG,CAACgC,KAAK,CAAC;UAAE/B,CAAC,EAAE3C,MAAM,GAAGnB,KAAK,CAAC+D,GAAG,CAAC8B,KAAK;QAAE,CAAC,CAAC;MACxF,CAAC,MACI;QACD5B,IAAI,GAAGhE,KAAK,CAACiE,MAAM,CAAC;UAAEN,CAAC,EAAEzC,MAAM,GAAGnB,KAAK,CAAC6D,GAAG,CAAChD,UAAU,CAAC;UAAEiD,CAAC,EAAE3C,MAAM,GAAGnB,KAAK,CAAC+D,GAAG,CAAClD,UAAU;QAAE,CAAC,CAAC,GAAGZ,KAAK,CAACgG,KAAK,CAACpF,UAAU,EAAEC,QAAQ,GAAGD,UAAU,EAAEM,MAAM,EAAEA,MAAM,CAAC;MAClK;MACA0D,IAAI,CAACZ,IAAI,GAAGA,IAAI;IACpB;IACA,IAAI,CAACiC,gBAAgB,CAACrB,IAAI,EAAEtB,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;EAC/C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIlD,kBAAkB,CAACuB,SAAS,CAACuE,kBAAkB,GAAG,UAAUC,KAAK,EAAE7C,QAAQ,EAAEuB,WAAW,EAAEC,QAAQ,EAAE;IAChG,IAAI,CAAC5E,KAAK,CAAC0C,QAAQ,CAACkC,QAAQ,CAAC,EAAE;MAC3BA,QAAQ,GAAGqB,KAAK,CAACrB,QAAQ;IAC7B;IACAxB,QAAQ,GAAGA,QAAQ,GAAG,CAACuB,WAAW,GAAGvB,QAAQ,IAAIwB,QAAQ;IACzD,IAAIC,KAAK,GAAG,IAAI,CAAC1B,eAAe,CAACC,QAAQ,CAAC;IAC1C,IAAI,CAAC8C,YAAY,CAACD,KAAK,EAAEpB,KAAK,CAAC;IAC/B,IAAI,CAACkB,gBAAgB,CAACE,KAAK,EAAE7C,QAAQ,EAAE,IAAI,CAAC+C,gBAAgB,EAAE,IAAI,CAACC,gBAAgB,CAAC;EACxF,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIlG,kBAAkB,CAACuB,SAAS,CAAC4E,qBAAqB,GAAG,YAAY;IAC7D;EAAA,CACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACInG,kBAAkB,CAACuB,SAAS,CAAC6E,YAAY,GAAG,UAAUzB,KAAK,EAAE;IACzD,OAAO,IAAI;EACf,CAAC;EACDhD,MAAM,CAACC,cAAc,CAAC5B,kBAAkB,CAACuB,SAAS,EAAE,YAAY,EAAE;IAC9D;AACR;AACA;IACQM,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACK,gBAAgB,CAAC,YAAY,CAAC;IAC9C,CAAC;IACD;AACR;AACA;AACA;AACA;IACQC,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MAClB;MACA,IAAI,IAAI,CAACiE,gBAAgB,CAAC,YAAY,EAAEjE,KAAK,CAAC,EAAE;QAC5C,IAAI,CAACkE,mBAAmB,CAAC,CAAC;MAC9B;IACJ,CAAC;IACDtE,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFN,MAAM,CAACC,cAAc,CAAC5B,kBAAkB,CAACuB,SAAS,EAAE,UAAU,EAAE;IAC5D;AACR;AACA;IACQM,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACK,gBAAgB,CAAC,UAAU,CAAC;IAC5C,CAAC;IACD;AACR;AACA;AACA;AACA;IACQC,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MAClB;MACA,IAAI,IAAI,CAACiE,gBAAgB,CAAC,UAAU,EAAEjE,KAAK,CAAC,EAAE;QAC1C,IAAI,CAACkE,mBAAmB,CAAC,CAAC;MAC9B;IACJ,CAAC;IACDtE,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFN,MAAM,CAACC,cAAc,CAAC5B,kBAAkB,CAACuB,SAAS,EAAE,WAAW,EAAE;IAC7D;AACR;AACA;IACQM,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACK,gBAAgB,CAAC,WAAW,CAAC;MACzC;IACJ,CAAC;;IACD;AACR;AACA;AACA;AACA;IACQC,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MAClB,IAAI,CAACiE,gBAAgB,CAAC,WAAW,EAAE1G,KAAK,CAAC4G,cAAc,CAACnE,KAAK,CAAC,CAAC;MAC/D,IAAI,CAACkE,mBAAmB,CAAC,CAAC;IAC9B,CAAC;IACDtE,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFN,MAAM,CAACC,cAAc,CAAC5B,kBAAkB,CAACuB,SAAS,EAAE,UAAU,EAAE;IAC5D;AACR;AACA;IACQM,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,IAAImC,IAAI,GAAG,IAAI,CAACvC,KAAK,CAACuD,KAAK,CAACC,QAAQ,CAAC,CAAC,CAAC;MACvC,IAAIjB,IAAI,YAAY3E,YAAY,EAAE;QAC9B,OAAO,IAAI,CAAC6C,gBAAgB,CAAC,UAAU,CAAC;MAC5C,CAAC,MACI;QACD,OAAO,SAAS;MACpB;IACJ,CAAC;IACD;IACA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MAClB,IAAI,CAACiE,gBAAgB,CAAC,UAAU,EAAEjE,KAAK,EAAE,IAAI,CAAC;IAClD,CAAC;IACDJ,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIjC,kBAAkB,CAACuB,SAAS,CAACiF,oBAAoB,GAAG,UAAUC,aAAa,EAAEhC,WAAW,EAAE;IACtF,IAAI1C,gBAAgB,GAAG,IAAI,CAACA,gBAAgB;IAC5C,IAAID,WAAW,GAAG,IAAI,CAACqC,UAAU,GAAGpC,gBAAgB;IACpD,IAAIQ,WAAW,GAAG5C,KAAK,CAACyD,UAAU,CAAC,IAAI,CAACC,oBAAoB,CAACoD,aAAa,CAAC,EAAE1E,gBAAgB,EAAED,WAAW,CAAC;IAC3G,IAAIhB,MAAM,GAAGnB,KAAK,CAACyD,UAAU,CAAC,IAAI,CAACC,oBAAoB,CAACoB,WAAW,CAAC,EAAE1C,gBAAgB,EAAED,WAAW,CAAC;IACpG;IACA,IAAItB,UAAU,GAAG,IAAI,CAACA,UAAU;IAChC,IAAIC,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC5B,IAAIiG,GAAG,GAAGjG,QAAQ,GAAGD,UAAU;IAC/B,IAAIoD,IAAI;IACR,IAAInC,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIsD,KAAK,GAAGtD,KAAK,CAACuD,KAAK,CAACC,QAAQ,CAAC,CAAC,CAAC;IACnC,IAAIE,MAAM,GAAG1D,KAAK,CAAC0D,MAAM,CAACF,QAAQ,CAAC,CAAC,CAAC;IACrC,IAAIC,KAAK,GAAG,CAAC;IACb,IAAIC,MAAM,EAAE;MACRD,KAAK,GAAGC,MAAM,CAACC,SAAS,CAACC,MAAM;IACnC;IACA;IACA;IACA,IAAI,IAAI,CAAC1E,QAAQ,IAAI,UAAU,IAAIuE,KAAK,GAAG,CAAC,IAAIC,MAAM,IAAIJ,KAAK,IAAIA,KAAK,YAAY1F,YAAY,EAAE;MAC9F,IAAIiG,YAAY,GAAGP,KAAK,CAACQ,QAAQ,CAACf,IAAI,CAACtD,QAAQ,CAACwD,QAAQ;MACxD,IAAIc,KAAK,GAAGT,KAAK,CAACU,QAAQ,CAACN,MAAM,CAACC,SAAS,CAACH,QAAQ,CAAC,CAAC,CAAC,EAAE,WAAW,EAAEK,YAAY,CAAC;MACnF1B,IAAI,GAAGhE,KAAK,CAACiE,MAAM,CAAC;QAAEN,CAAC,EAAEzC,MAAM,GAAGnB,KAAK,CAAC6D,GAAG,CAACgC,KAAK,CAAC;QAAE/B,CAAC,EAAE3C,MAAM,GAAGnB,KAAK,CAAC+D,GAAG,CAAC8B,KAAK;MAAE,CAAC,CAAC;MACnF,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,KAAK,EAAEQ,CAAC,EAAE,EAAE;QAC5BF,KAAK,GAAGT,KAAK,CAACU,QAAQ,CAACN,MAAM,CAACC,SAAS,CAACH,QAAQ,CAACS,CAAC,CAAC,EAAE,WAAW,EAAEJ,YAAY,CAAC;QAC/E1B,IAAI,IAAIhE,KAAK,CAACkE,MAAM,CAAC;UAAEP,CAAC,EAAEzC,MAAM,GAAGnB,KAAK,CAAC6D,GAAG,CAACgC,KAAK,CAAC;UAAE/B,CAAC,EAAE3C,MAAM,GAAGnB,KAAK,CAAC+D,GAAG,CAAC8B,KAAK;QAAE,CAAC,CAAC;MACxF;MACAA,KAAK,GAAGT,KAAK,CAACU,QAAQ,CAACN,MAAM,CAACC,SAAS,CAACH,QAAQ,CAACC,KAAK,GAAG,CAAC,CAAC,EAAE,WAAW,EAAEH,KAAK,CAACQ,QAAQ,CAACI,eAAe,CAAC;MACzG/B,IAAI,IAAIhE,KAAK,CAACkE,MAAM,CAAC;QAAEP,CAAC,EAAEzC,MAAM,GAAGnB,KAAK,CAAC6D,GAAG,CAACgC,KAAK,CAAC;QAAE/B,CAAC,EAAE3C,MAAM,GAAGnB,KAAK,CAAC+D,GAAG,CAAC8B,KAAK;MAAE,CAAC,CAAC;MACpF5B,IAAI,IAAIhE,KAAK,CAACiE,MAAM,CAAC;QAAEN,CAAC,EAAEhB,WAAW,GAAG5C,KAAK,CAAC6D,GAAG,CAACgC,KAAK,CAAC;QAAE/B,CAAC,EAAElB,WAAW,GAAG5C,KAAK,CAAC+D,GAAG,CAAC8B,KAAK;MAAE,CAAC,CAAC;MAC9F,KAAK,IAAIE,CAAC,GAAGR,KAAK,GAAG,CAAC,EAAEQ,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QACjCF,KAAK,GAAGT,KAAK,CAACU,QAAQ,CAACN,MAAM,CAACC,SAAS,CAACH,QAAQ,CAACS,CAAC,CAAC,EAAE,WAAW,EAAEJ,YAAY,CAAC;QAC/E1B,IAAI,IAAIhE,KAAK,CAACkE,MAAM,CAAC;UAAEP,CAAC,EAAEhB,WAAW,GAAG5C,KAAK,CAAC6D,GAAG,CAACgC,KAAK,CAAC;UAAE/B,CAAC,EAAElB,WAAW,GAAG5C,KAAK,CAAC+D,GAAG,CAAC8B,KAAK;QAAE,CAAC,CAAC;MAClG;IACJ,CAAC,MACI;MACD5B,IAAI,GAAGhE,KAAK,CAAC8G,GAAG,CAAClG,UAAU,EAAEkG,GAAG,EAAE5F,MAAM,EAAEyB,WAAW,CAAC;IAC1D;IACA,OAAOqB,IAAI;EACf,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI5D,kBAAkB,CAACuB,SAAS,CAACoF,kBAAkB,GAAG,UAAUC,SAAS,EAAE;IACnE;IACA,IAAIC,SAAS,GAAGD,SAAS,CAACC,SAAS;IACnC,IAAIC,OAAO,GAAGF,SAAS,CAACE,OAAO;IAC/B,IAAIC,SAAS,GAAGH,SAAS,CAACG,SAAS;IACnC,IAAIC,UAAU,GAAGJ,SAAS,CAACI,UAAU;IACrC,IAAIC,QAAQ,GAAGL,SAAS,CAACK,QAAQ;IACjCJ,SAAS,CAAC/F,MAAM,GAAG6B,IAAI,CAACuE,GAAG,CAACF,UAAU,CAACvD,CAAC,CAAC;IACzCqD,OAAO,CAAChG,MAAM,GAAG6B,IAAI,CAACuE,GAAG,CAACD,QAAQ,CAACxD,CAAC,CAAC;IACrCsD,SAAS,CAACjG,MAAM,GAAG6B,IAAI,CAACuE,GAAG,CAACD,QAAQ,CAACxD,CAAC,CAAC;IACvCsD,SAAS,CAACxE,WAAW,GAAGI,IAAI,CAACuE,GAAG,CAACF,UAAU,CAACvD,CAAC,CAAC;EAClD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACIzD,kBAAkB,CAACuB,SAAS,CAAC4F,kBAAkB,GAAG,UAAUP,SAAS,EAAE;IACnEA,SAAS,CAACC,SAAS,GAAG,IAAIvH,WAAW,CAAC,CAAC;IACvCsH,SAAS,CAACE,OAAO,GAAG,IAAIxH,WAAW,CAAC,CAAC;IACrCsH,SAAS,CAACG,SAAS,GAAG,IAAIzH,WAAW,CAAC,CAAC;EAC3C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIU,kBAAkB,CAACuB,SAAS,CAAC6F,aAAa,GAAG,YAAY;IACrD,IAAIpD,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAIA,IAAI,EAAE;MACN,IAAIqD,MAAM,GAAG,IAAI;MACjB,IAAIC,GAAG,GAAG,CAAC,IAAI;MACf,IAAIC,GAAG,GAAG,CAAC,IAAI;MACf,IAAIC,GAAG,GAAGH,MAAM,GAAG,CAAC;MACpB,IAAII,GAAG,GAAGJ,MAAM,GAAG,CAAC;MACpB,IAAIzG,SAAS,GAAG,IAAI,CAACA,SAAS;MAC9B,IAAIA,SAAS,GAAG,CAAC,EAAE;QACfA,SAAS,IAAI,GAAG;MACpB;MACA,IAAI8G,kBAAkB,GAAG,UAAU;MACnC,IAAK9G,SAAS,GAAG,EAAE,IAAIA,SAAS,GAAG,GAAG,IAAMA,SAAS,GAAG,GAAG,IAAIA,SAAS,GAAG,GAAI,EAAE;QAC7E8G,kBAAkB,GAAG,YAAY;MACrC;MACA,IAAI,CAAC1D,IAAI,CAACoD,aAAa,CAACM,kBAAkB,EAAE;QAAEnE,CAAC,EAAE+D,GAAG;QAAE7D,CAAC,EAAE8D,GAAG;QAAEI,KAAK,EAAEH,GAAG;QAAEI,MAAM,EAAEH;MAAI,CAAC,CAAC;IAC5F;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIzH,kBAAkB,CAACuB,SAAS,CAACsG,iBAAiB,GAAG,UAAUC,IAAI,EAAE5E,QAAQ,EAAEuB,WAAW,EAAE;IACpFvB,QAAQ,GAAGA,QAAQ,GAAG,CAACuB,WAAW,GAAGvB,QAAQ,IAAI4E,IAAI,CAACpD,QAAQ;IAC9D,IAAIC,KAAK,GAAG,IAAI,CAAC1B,eAAe,CAACC,QAAQ,CAAC;IAC1C,IAAI4E,IAAI,CAAChD,OAAO,EAAE;MACd,IAAIU,KAAK,GAAG7F,KAAK,CAAC4G,cAAc,CAAC,IAAI,CAAC3F,SAAS,GAAG,EAAE,CAAC;MACrD,IAAI4E,KAAK,GAAG,EAAE,IAAI7C,IAAI,CAACoF,KAAK,CAACvC,KAAK,GAAG,EAAE,CAAC,EAAE;QACtCsC,IAAI,CAACE,YAAY,GAAG,KAAK;MAC7B,CAAC,MACI;QACDF,IAAI,CAACE,YAAY,GAAG,IAAI;MAC5B;MACA,IAAIC,UAAU,GAAG,CAACH,IAAI,CAACzC,MAAM;MAC7B,IAAIyC,IAAI,CAACxD,MAAM,EAAE;QACb2D,UAAU,IAAI,CAAC,CAAC;MACpB;MACAH,IAAI,CAAClE,IAAI,GAAGhE,KAAK,CAACiE,MAAM,CAAC;QAAEN,CAAC,EAAE,CAAC;QAAEE,CAAC,EAAE;MAAE,CAAC,CAAC,GAAG7D,KAAK,CAACkE,MAAM,CAAC;QAAEP,CAAC,EAAE0E,UAAU,GAAGtI,KAAK,CAAC6D,GAAG,CAACgC,KAAK,CAAC;QAAE/B,CAAC,EAAEwE,UAAU,GAAGtI,KAAK,CAAC+D,GAAG,CAAC8B,KAAK;MAAE,CAAC,CAAC;IACnI;IACA,IAAI,CAACQ,YAAY,CAAC8B,IAAI,EAAEnD,KAAK,CAAC;IAC9B,IAAI,CAACkB,gBAAgB,CAACiC,IAAI,EAAE5E,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;EAC/C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIlD,kBAAkB,CAACuB,SAAS,CAAC2G,YAAY,GAAG,UAAUC,MAAM,EAAEjF,QAAQ,EAAEuB,WAAW,EAAE;IACjF,IAAIC,QAAQ,GAAG,GAAG;IAClB,IAAIyD,MAAM,YAAYpI,UAAU,EAAE;MAC9B2E,QAAQ,GAAGyD,MAAM,CAACzD,QAAQ;IAC9B;IACAxB,QAAQ,GAAGA,QAAQ,GAAG,CAACuB,WAAW,GAAGvB,QAAQ,IAAIwB,QAAQ;IACzD,IAAIC,KAAK,GAAG,IAAI,CAAC1B,eAAe,CAACC,QAAQ,CAAC;IAC1C,IAAI,CAAC8C,YAAY,CAACmC,MAAM,EAAExD,KAAK,CAAC;IAChC,IAAI,CAACkB,gBAAgB,CAACsC,MAAM,EAAEjF,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;EACjD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIlD,kBAAkB,CAACuB,SAAS,CAAC8B,oBAAoB,GAAG,UAAUH,QAAQ,EAAE;IACpE,IAAIkF,UAAU;IACd,IAAIpE,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAIqE,cAAc,GAAGrE,IAAI,CAACqE,cAAc;IACxC,IAAI9F,WAAW,GAAG,IAAI,CAACR,gBAAgB;IACvC,IAAIiC,IAAI,CAACuB,QAAQ,CAAC+C,QAAQ,EAAE;MACxBF,UAAU,GAAG,CAACpE,IAAI,CAACuE,GAAG,GAAGrF,QAAQ,IAAImF,cAAc,GAAG9F,WAAW;IACrE,CAAC,MACI;MACD6F,UAAU,GAAG,CAAClF,QAAQ,GAAGc,IAAI,CAACwE,KAAK,IAAIH,cAAc,GAAG9F,WAAW;IACvE;IACA,OAAO5C,KAAK,CAACoI,KAAK,CAACK,UAAU,EAAE,CAAC,CAAC;EACrC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIpI,kBAAkB,CAACuB,SAAS,CAACkH,eAAe,GAAG,UAAU9D,KAAK,EAAE;IAC5D,IAAIyD,UAAU,GAAIzI,KAAK,CAACiF,WAAW,CAACD,KAAK,CAAC,GAAG,IAAI,CAAC5C,gBAAiB;IACnE,OAAO,IAAI,CAAC2G,oBAAoB,CAACN,UAAU,CAAC;EAChD,CAAC;EACDzG,MAAM,CAACC,cAAc,CAAC5B,kBAAkB,CAACuB,SAAS,EAAE,OAAO,EAAE;IACzD;AACR;AACA;AACA;IACQM,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACzB,MAAM,CAACyB,GAAG,CAAC,CAAC;IAC5B,CAAC;IACD;AACR;AACA;AACA;AACA;AACA;IACQM,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MAClB,IAAI,CAAChC,MAAM,CAAC+B,GAAG,CAACC,KAAK,EAAE,IAAI,CAAC;IAChC,CAAC;IACDJ,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF,OAAOjC,kBAAkB;AAC7B,CAAC,CAACZ,aAAa,CAAE;AACjB,SAASY,kBAAkB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACAN,QAAQ,CAACiJ,iBAAiB,CAAC,oBAAoB,CAAC,GAAG3I,kBAAkB"},"metadata":{},"sourceType":"module","externalDependencies":[]}