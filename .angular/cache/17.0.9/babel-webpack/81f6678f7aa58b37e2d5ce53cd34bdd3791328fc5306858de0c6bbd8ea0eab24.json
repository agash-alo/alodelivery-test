{"ast":null,"code":"/**\r\n * Polygon module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Sprite } from \"../Sprite\";\nimport { Morpher } from \"../utils/Morpher\";\nimport { registry } from \"../Registry\";\nimport * as $path from \"../rendering/Path\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link IPolygonEvents} for a list of available events\r\n * @see {@link IPolygonAdapters} for a list of available Adapters\r\n */\nvar Polygon = /** @class */function (_super) {\n  __extends(Polygon, _super);\n  /**\r\n   * Constructor\r\n   */\n  function Polygon() {\n    var _this = _super.call(this) || this;\n    _this.className = \"Polygon\";\n    _this.element = _this.paper.add(\"path\");\n    _this.shapeRendering = \"auto\";\n    _this._currentPoints = [];\n    _this.applyTheme();\n    return _this;\n  }\n  Object.defineProperty(Polygon.prototype, \"points\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function () {\n      var points = this.getPropertyValue(\"points\");\n      var path = this.path;\n      if (path && (!points || points.length == 0)) {\n        var valueStr = path.slice(1, path.length - 1);\n        var segments = valueStr.split(\"ZM\");\n        for (var s = 0; s < segments.length; s++) {\n          var segment = segments[s];\n          if (segment.length > 0) {\n            var areaHole = segment.split(\"M\");\n            var areaArr = areaHole[0];\n            var holeArr = areaHole[1];\n            if (areaArr && areaArr.length > 0) {\n              var pointsArr = areaArr.split(\"L\");\n              if (pointsArr.length > 0) {\n                var area = [];\n                var areaAndHole = [area];\n                points.push(areaAndHole);\n                for (var p = 0; p < pointsArr.length; p++) {\n                  var coords = pointsArr[p].split(\",\");\n                  area.push({\n                    x: +coords[0],\n                    y: +coords[1]\n                  });\n                }\n                if (holeArr && holeArr.length > 0) {\n                  var pointsArr_1 = holeArr.split(\"L\");\n                  if (pointsArr_1.length > 0) {\n                    var hole = [];\n                    areaAndHole.push(hole);\n                    for (var p = pointsArr_1.length - 1; p >= 0; p--) {\n                      var coords = pointsArr_1[p].split(\",\");\n                      hole.push({\n                        x: +coords[0],\n                        y: +coords[1]\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        this.setPropertyValue(\"points\", points);\n        this._currentPoints = points;\n      }\n      return points;\n    },\n    /**\r\n     * An array of X/Y coordinates for each elbow of the polygon.\r\n     *\r\n     * @todo Example\r\n     * @param points  Polygon points\r\n     */\n    set: function (points) {\n      this.setPropertyValue(\"points\", points, true);\n      this._currentPoints = points;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"currentPoints\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function () {\n      if ((!this._currentPoints || this._currentPoints.length == 0) && this.path) {\n        this._currentPoints = this.points;\n      }\n      return this._currentPoints;\n    },\n    /**\r\n     * Current points. Used when morphing the element, so that original `points`\r\n     * are not overwritten.\r\n     *\r\n     * @param points  Polygon points\r\n     */\n    set: function (points) {\n      if (this._currentPoints != points) {\n        this._currentPoints = points;\n        this.draw();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Draws the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Polygon.prototype.draw = function () {\n    var path = \"\";\n    var points = this._currentPoints;\n    var left;\n    var right;\n    var top;\n    var bottom;\n    if (points.length > 0) {\n      // separate areas\n      for (var i = 0, len = points.length; i < len; i++) {\n        // surface\n        var surface = points[i][0];\n        var hole = points[i][1];\n        if (surface && surface.length > 0) {\n          var point = surface[0];\n          path += $path.moveTo(point);\n          for (var s = 0; s < surface.length; s++) {\n            point = surface[s];\n            path += $path.lineTo(point);\n            if (!$type.isNumber(right) || right < point.x) {\n              right = point.x;\n            }\n            if (!$type.isNumber(left) || left > point.x) {\n              left = point.x;\n            }\n            if (!$type.isNumber(top) || top > point.y) {\n              top = point.y;\n            }\n            if (!$type.isNumber(bottom) || bottom < point.y) {\n              bottom = point.y;\n            }\n          }\n        }\n        // hole\n        if (hole && hole.length > 0) {\n          var point = hole[0];\n          path += $path.moveTo(point);\n          for (var h = 0, hlen = hole.length; h < hlen; h++) {\n            point = hole[h];\n            path += $path.lineTo(point);\n          }\n        }\n      }\n      if (path) {\n        path += $path.closePath();\n      }\n      this.bbox.x = left;\n      this.bbox.y = top;\n      this.bbox.width = right - left;\n      this.bbox.height = bottom - top;\n      _super.prototype.setPath.call(this, path);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n  Polygon.prototype.setPath = function (value) {\n    if (_super.prototype.setPath.call(this, value)) {\n      this.points = [];\n      this._bbox = this.group.getBBox();\n      return true;\n    }\n    return false;\n  };\n  /**\r\n   * Measures element\r\n   */\n  Polygon.prototype.measureElement = function () {\n    // Overriding to avoid extra measurement.\n  };\n  Object.defineProperty(Polygon.prototype, \"centerPoint\", {\n    /**\r\n     * A calculated center point for the shape.\r\n     *\r\n     * @readonly\r\n     * @return Center\r\n     */\n    get: function () {\n      return {\n        x: this.bbox.x + this.bbox.width / 2,\n        y: this.bbox.y + this.bbox.height / 2\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"morpher\", {\n    /**\r\n     * A [[Morpher]] instance that is used to morph polygon into some other\r\n     * shape.\r\n     *\r\n     * @readonly\r\n     * @return Morpher instance\r\n     */\n    get: function () {\n      if (!this._morpher) {\n        this._morpher = new Morpher(this);\n        this._disposers.push(this._morpher);\n      }\n      return this._morpher;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Polygon;\n}(Sprite);\nexport { Polygon };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"Polygon\"] = Polygon;","map":{"version":3,"names":["__extends","Sprite","Morpher","registry","$path","$type","Polygon","_super","_this","call","className","element","paper","add","shapeRendering","_currentPoints","applyTheme","Object","defineProperty","prototype","get","points","getPropertyValue","path","length","valueStr","slice","segments","split","s","segment","areaHole","areaArr","holeArr","pointsArr","area","areaAndHole","push","p","coords","x","y","pointsArr_1","hole","setPropertyValue","set","enumerable","configurable","draw","left","right","top","bottom","i","len","surface","point","moveTo","lineTo","isNumber","h","hlen","closePath","bbox","width","height","setPath","value","_bbox","group","getBBox","measureElement","_morpher","_disposers","registeredClasses"],"sources":["D:/alodelivery test/node_modules/@amcharts/amcharts4/.internal/core/elements/Polygon.js"],"sourcesContent":["/**\r\n * Polygon module.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Sprite } from \"../Sprite\";\r\nimport { Morpher } from \"../utils/Morpher\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $path from \"../rendering/Path\";\r\nimport * as $type from \"../utils/Type\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link IPolygonEvents} for a list of available events\r\n * @see {@link IPolygonAdapters} for a list of available Adapters\r\n */\r\nvar Polygon = /** @class */ (function (_super) {\r\n    __extends(Polygon, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function Polygon() {\r\n        var _this = _super.call(this) || this;\r\n        _this.className = \"Polygon\";\r\n        _this.element = _this.paper.add(\"path\");\r\n        _this.shapeRendering = \"auto\";\r\n        _this._currentPoints = [];\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Polygon.prototype, \"points\", {\r\n        /**\r\n         * @return Polygon points\r\n         */\r\n        get: function () {\r\n            var points = this.getPropertyValue(\"points\");\r\n            var path = this.path;\r\n            if (path && (!points || points.length == 0)) {\r\n                var valueStr = path.slice(1, path.length - 1);\r\n                var segments = valueStr.split(\"ZM\");\r\n                for (var s = 0; s < segments.length; s++) {\r\n                    var segment = segments[s];\r\n                    if (segment.length > 0) {\r\n                        var areaHole = segment.split(\"M\");\r\n                        var areaArr = areaHole[0];\r\n                        var holeArr = areaHole[1];\r\n                        if (areaArr && areaArr.length > 0) {\r\n                            var pointsArr = areaArr.split(\"L\");\r\n                            if (pointsArr.length > 0) {\r\n                                var area = [];\r\n                                var areaAndHole = [area];\r\n                                points.push(areaAndHole);\r\n                                for (var p = 0; p < pointsArr.length; p++) {\r\n                                    var coords = pointsArr[p].split(\",\");\r\n                                    area.push({ x: +coords[0], y: +coords[1] });\r\n                                }\r\n                                if (holeArr && holeArr.length > 0) {\r\n                                    var pointsArr_1 = holeArr.split(\"L\");\r\n                                    if (pointsArr_1.length > 0) {\r\n                                        var hole = [];\r\n                                        areaAndHole.push(hole);\r\n                                        for (var p = pointsArr_1.length - 1; p >= 0; p--) {\r\n                                            var coords = pointsArr_1[p].split(\",\");\r\n                                            hole.push({ x: +coords[0], y: +coords[1] });\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                this.setPropertyValue(\"points\", points);\r\n                this._currentPoints = points;\r\n            }\r\n            return points;\r\n        },\r\n        /**\r\n         * An array of X/Y coordinates for each elbow of the polygon.\r\n         *\r\n         * @todo Example\r\n         * @param points  Polygon points\r\n         */\r\n        set: function (points) {\r\n            this.setPropertyValue(\"points\", points, true);\r\n            this._currentPoints = points;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Polygon.prototype, \"currentPoints\", {\r\n        /**\r\n         * @return Polygon points\r\n         */\r\n        get: function () {\r\n            if ((!this._currentPoints || this._currentPoints.length == 0) && this.path) {\r\n                this._currentPoints = this.points;\r\n            }\r\n            return this._currentPoints;\r\n        },\r\n        /**\r\n         * Current points. Used when morphing the element, so that original `points`\r\n         * are not overwritten.\r\n         *\r\n         * @param points  Polygon points\r\n         */\r\n        set: function (points) {\r\n            if (this._currentPoints != points) {\r\n                this._currentPoints = points;\r\n                this.draw();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Draws the element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Polygon.prototype.draw = function () {\r\n        var path = \"\";\r\n        var points = this._currentPoints;\r\n        var left;\r\n        var right;\r\n        var top;\r\n        var bottom;\r\n        if (points.length > 0) {\r\n            // separate areas\r\n            for (var i = 0, len = points.length; i < len; i++) {\r\n                // surface\r\n                var surface = points[i][0];\r\n                var hole = points[i][1];\r\n                if (surface && surface.length > 0) {\r\n                    var point = surface[0];\r\n                    path += $path.moveTo(point);\r\n                    for (var s = 0; s < surface.length; s++) {\r\n                        point = surface[s];\r\n                        path += $path.lineTo(point);\r\n                        if (!$type.isNumber(right) || (right < point.x)) {\r\n                            right = point.x;\r\n                        }\r\n                        if (!$type.isNumber(left) || (left > point.x)) {\r\n                            left = point.x;\r\n                        }\r\n                        if (!$type.isNumber(top) || (top > point.y)) {\r\n                            top = point.y;\r\n                        }\r\n                        if (!$type.isNumber(bottom) || (bottom < point.y)) {\r\n                            bottom = point.y;\r\n                        }\r\n                    }\r\n                }\r\n                // hole\r\n                if (hole && hole.length > 0) {\r\n                    var point = hole[0];\r\n                    path += $path.moveTo(point);\r\n                    for (var h = 0, hlen = hole.length; h < hlen; h++) {\r\n                        point = hole[h];\r\n                        path += $path.lineTo(point);\r\n                    }\r\n                }\r\n            }\r\n            if (path) {\r\n                path += $path.closePath();\r\n            }\r\n            this.bbox.x = left;\r\n            this.bbox.y = top;\r\n            this.bbox.width = right - left;\r\n            this.bbox.height = bottom - top;\r\n            _super.prototype.setPath.call(this, path);\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    Polygon.prototype.setPath = function (value) {\r\n        if (_super.prototype.setPath.call(this, value)) {\r\n            this.points = [];\r\n            this._bbox = this.group.getBBox();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Measures element\r\n     */\r\n    Polygon.prototype.measureElement = function () {\r\n        // Overriding to avoid extra measurement.\r\n    };\r\n    Object.defineProperty(Polygon.prototype, \"centerPoint\", {\r\n        /**\r\n         * A calculated center point for the shape.\r\n         *\r\n         * @readonly\r\n         * @return Center\r\n         */\r\n        get: function () {\r\n            return { x: this.bbox.x + this.bbox.width / 2, y: this.bbox.y + this.bbox.height / 2 };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Polygon.prototype, \"morpher\", {\r\n        /**\r\n         * A [[Morpher]] instance that is used to morph polygon into some other\r\n         * shape.\r\n         *\r\n         * @readonly\r\n         * @return Morpher instance\r\n         */\r\n        get: function () {\r\n            if (!this._morpher) {\r\n                this._morpher = new Morpher(this);\r\n                this._disposers.push(this._morpher);\r\n            }\r\n            return this._morpher;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Polygon;\r\n}(Sprite));\r\nexport { Polygon };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Polygon\"] = Polygon;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}