{"ast":null,"code":"/**\r\n * Polyspline (smoothed line) module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Polyline } from \"./Polyline\";\nimport { registry } from \"../Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $path from \"../../core/rendering/Path\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Draws a polysline. (smoothed multi-sigment line)\r\n *\r\n * @see {@link IPolysplineEvents} for a list of available events\r\n * @see {@link IPolysplineAdapters} for a list of available Adapters\r\n */\nvar Polyspline = /** @class */function (_super) {\n  __extends(Polyspline, _super);\n  /**\r\n   * Constructor\r\n   */\n  function Polyspline() {\n    var _this = _super.call(this) || this;\n    _this.className = \"Polyspline\";\n    _this.tensionX = 0.5;\n    _this.tensionY = 0.5;\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * Creats and adds an SVG path for the arc.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Polyspline.prototype.makePath = function () {\n    this._distance = 0;\n    var segments = this.segments;\n    var tensionX = this.tensionX;\n    var tensionY = this.tensionY;\n    this.allPoints = [];\n    if (segments && segments.length > 0) {\n      var path = \"\";\n      this._realSegments = [];\n      for (var i = 0, len = segments.length; i < len; i++) {\n        var points = segments[i];\n        var realPoints = [];\n        this._realSegments.push(realPoints);\n        if (points.length > 0) {\n          var first = points[0];\n          var last = points[points.length - 1];\n          var closed_1 = false;\n          if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n            closed_1 = true;\n          }\n          path += $path.moveTo(points[0]);\n          for (var p = 0; p < points.length - 1; p++) {\n            var p0 = points[p - 1];\n            var p1 = points[p];\n            var p2 = points[p + 1];\n            var p3 = points[p + 2];\n            if (p === 0) {\n              p0 = points[p];\n            } else if (p == points.length - 2) {\n              p3 = points[p + 1];\n            }\n            if (!p3) {\n              p3 = p2;\n            }\n            if (p === 0) {\n              if (closed_1) {\n                p0 = points[points.length - 2];\n              } else {\n                p0 = points[i];\n              }\n            } else if (p == points.length - 2) {\n              if (closed_1) {\n                p3 = points[1];\n              } else {\n                p3 = points[p + 1];\n              }\n            }\n            var controlPointA = $math.getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);\n            var controlPointB = $math.getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);\n            path += $path.cubicCurveTo(p2, controlPointA, controlPointB);\n            // now split to small segments so that we could have positionToPoint later\n            var stepCount = Math.ceil($math.getCubicCurveDistance(p1, p2, controlPointA, controlPointB, 20)) * 1.2;\n            var prevPoint = p1;\n            if (stepCount > 0) {\n              // not good for curved charts\n              //this.allPoints[0] = { x: points[0].x, y: points[0].y, angle: $math.getAngle(points[0], points[1]) };\n              //realPoints.push(this.allPoints[0]);\n              for (var s = 0; s <= stepCount; s++) {\n                var point = $math.getPointOnCubicCurve(p1, p2, controlPointA, controlPointB, s / stepCount);\n                if (point.x == prevPoint.x && point.y == prevPoint.y) {\n                  continue;\n                }\n                realPoints.push(point);\n                var angle = $math.round($math.getAngle(prevPoint, point), 5);\n                //this.allPoints.push({ x: point.x, y: point.y, angle: angle });\n                this._distance += $math.getDistance(prevPoint, point);\n                this.allPoints[Math.floor(this._distance)] = {\n                  x: point.x,\n                  y: point.y,\n                  angle: angle\n                };\n                prevPoint = point;\n              }\n            } else {\n              realPoints.push(p0);\n            }\n          }\n        }\n        var allPoints = this.allPoints;\n        if (allPoints.length > 1) {\n          for (var i_1 = 0; i_1 < allPoints.length; i_1++) {\n            if (!allPoints[i_1]) {\n              if (i_1 > 1) {\n                allPoints[i_1] = allPoints[i_1 - 1];\n              } else {\n                for (var k = 1; k < allPoints.length; k++) {\n                  if (allPoints[k]) {\n                    allPoints[i_1] = allPoints[k];\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      this.path = path;\n    }\n  };\n  /**\r\n   * Returns an index of the point that is closest to specified coordinates.\r\n   *\r\n   * @param   point  Reference point\r\n   * @return         Index\r\n   */\n  Polyspline.prototype.getClosestPointIndex = function (point) {\n    var points = this.allPoints;\n    var index;\n    var closest = Infinity;\n    if (points.length > 1) {\n      for (var p = 1; p < points.length; p++) {\n        var distance = $math.getDistance(point, points[p]);\n        if (distance < closest) {\n          index = p;\n          closest = distance;\n        }\n      }\n    }\n    return index;\n  };\n  Object.defineProperty(Polyspline.prototype, \"tensionX\", {\n    /**\r\n     * @return Tension\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"tensionX\");\n    },\n    /**\r\n     * Horizontal tension for the spline.\r\n     *\r\n     * Used by the line smoothing algorithm.\r\n     *\r\n     * @default 0.5\r\n     * @param value  Tension\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"tensionX\", value);\n      this.makePath();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polyspline.prototype, \"tensionY\", {\n    /**\r\n     * @return Tension\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"tensionY\");\n    },\n    /**\r\n     * Vertical tension for the spline.\r\n     *\r\n     * Used by the line smoothing algorithm.\r\n     *\r\n     * @default 0.5\r\n     * @param value  Tensions\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"tensionY\", value, true);\n      this.makePath();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts relative position along the line (0-1) into pixel coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Coordinates\r\n   */\n  Polyspline.prototype.positionToPoint = function (position, extend) {\n    var deltaAngle = 0;\n    var allPoints = this.allPoints;\n    var len = allPoints.length;\n    if (!$type.isNumber(position)) {\n      position = 0;\n    }\n    if (len > 1) {\n      if (extend && len > 3) {\n        if (position < 0) {\n          if (position < -0.01) {\n            position = -0.01;\n          }\n          var f0 = allPoints[0];\n          var f1 = allPoints[1];\n          var x = f0.x - (f0.x - f1.x) * len * position;\n          var y = f0.y - (f0.y - f1.y) * len * position;\n          return {\n            x: x,\n            y: y,\n            angle: $math.getAngle(f0, f1)\n          };\n        } else if (position > 1) {\n          if (position > 1.01) {\n            position = 1.01;\n          }\n          var f0 = allPoints[allPoints.length - 2];\n          var f1 = allPoints[allPoints.length - 3];\n          var x = f0.x + (f0.x - f1.x) * len * (position - 1);\n          var y = f0.y + (f0.y - f1.y) * len * (position - 1);\n          return {\n            x: x,\n            y: y,\n            angle: $math.getAngle(f0, {\n              x: x,\n              y: y\n            })\n          };\n        } else if (position == 1) {\n          var point_1 = allPoints[allPoints.length - 1];\n          return {\n            x: point_1.x,\n            y: point_1.y,\n            angle: point_1.angle\n          };\n        }\n      } else {\n        if (position < 0) {\n          position = Math.abs(position);\n          deltaAngle = 180;\n        }\n        if (position >= 1) {\n          position = 0.9999999999999;\n        }\n      }\n      var point = allPoints[Math.floor(position * len)];\n      return {\n        x: point.x,\n        y: point.y,\n        angle: point.angle + deltaAngle\n      };\n    } else if (len == 1) {\n      var point = allPoints[0];\n      return {\n        x: point.x,\n        y: point.y,\n        angle: point.angle\n      };\n    } else {\n      return {\n        x: 0,\n        y: 0,\n        angle: 0\n      };\n    }\n  };\n  return Polyspline;\n}(Polyline);\nexport { Polyspline };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"Polyspline\"] = Polyspline;","map":{"version":3,"names":["__extends","Polyline","registry","$math","$type","$path","Polyspline","_super","_this","call","className","tensionX","tensionY","applyTheme","prototype","makePath","_distance","segments","allPoints","length","path","_realSegments","i","len","points","realPoints","push","first","last","closed_1","round","x","y","moveTo","p","p0","p1","p2","p3","controlPointA","getCubicControlPointA","controlPointB","getCubicControlPointB","cubicCurveTo","stepCount","Math","ceil","getCubicCurveDistance","prevPoint","s","point","getPointOnCubicCurve","angle","getAngle","getDistance","floor","i_1","k","getClosestPointIndex","index","closest","Infinity","distance","Object","defineProperty","get","getPropertyValue","set","value","setPropertyValue","enumerable","configurable","positionToPoint","position","extend","deltaAngle","isNumber","f0","f1","point_1","abs","registeredClasses"],"sources":["D:/alodelivery test/node_modules/@amcharts/amcharts4/.internal/core/elements/Polyspline.js"],"sourcesContent":["/**\r\n * Polyspline (smoothed line) module.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Polyline } from \"./Polyline\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Draws a polysline. (smoothed multi-sigment line)\r\n *\r\n * @see {@link IPolysplineEvents} for a list of available events\r\n * @see {@link IPolysplineAdapters} for a list of available Adapters\r\n */\r\nvar Polyspline = /** @class */ (function (_super) {\r\n    __extends(Polyspline, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function Polyspline() {\r\n        var _this = _super.call(this) || this;\r\n        _this.className = \"Polyspline\";\r\n        _this.tensionX = 0.5;\r\n        _this.tensionY = 0.5;\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    /**\r\n     * Creats and adds an SVG path for the arc.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Polyspline.prototype.makePath = function () {\r\n        this._distance = 0;\r\n        var segments = this.segments;\r\n        var tensionX = this.tensionX;\r\n        var tensionY = this.tensionY;\r\n        this.allPoints = [];\r\n        if (segments && segments.length > 0) {\r\n            var path = \"\";\r\n            this._realSegments = [];\r\n            for (var i = 0, len = segments.length; i < len; i++) {\r\n                var points = segments[i];\r\n                var realPoints = [];\r\n                this._realSegments.push(realPoints);\r\n                if (points.length > 0) {\r\n                    var first = points[0];\r\n                    var last = points[points.length - 1];\r\n                    var closed_1 = false;\r\n                    if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\r\n                        closed_1 = true;\r\n                    }\r\n                    path += $path.moveTo(points[0]);\r\n                    for (var p = 0; p < points.length - 1; p++) {\r\n                        var p0 = points[p - 1];\r\n                        var p1 = points[p];\r\n                        var p2 = points[p + 1];\r\n                        var p3 = points[p + 2];\r\n                        if (p === 0) {\r\n                            p0 = points[p];\r\n                        }\r\n                        else if (p == points.length - 2) {\r\n                            p3 = points[p + 1];\r\n                        }\r\n                        if (!p3) {\r\n                            p3 = p2;\r\n                        }\r\n                        if (p === 0) {\r\n                            if (closed_1) {\r\n                                p0 = points[points.length - 2];\r\n                            }\r\n                            else {\r\n                                p0 = points[i];\r\n                            }\r\n                        }\r\n                        else if (p == points.length - 2) {\r\n                            if (closed_1) {\r\n                                p3 = points[1];\r\n                            }\r\n                            else {\r\n                                p3 = points[p + 1];\r\n                            }\r\n                        }\r\n                        var controlPointA = $math.getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);\r\n                        var controlPointB = $math.getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);\r\n                        path += $path.cubicCurveTo(p2, controlPointA, controlPointB);\r\n                        // now split to small segments so that we could have positionToPoint later\r\n                        var stepCount = Math.ceil($math.getCubicCurveDistance(p1, p2, controlPointA, controlPointB, 20)) * 1.2;\r\n                        var prevPoint = p1;\r\n                        if (stepCount > 0) {\r\n                            // not good for curved charts\r\n                            //this.allPoints[0] = { x: points[0].x, y: points[0].y, angle: $math.getAngle(points[0], points[1]) };\r\n                            //realPoints.push(this.allPoints[0]);\r\n                            for (var s = 0; s <= stepCount; s++) {\r\n                                var point = $math.getPointOnCubicCurve(p1, p2, controlPointA, controlPointB, s / stepCount);\r\n                                if (point.x == prevPoint.x && point.y == prevPoint.y) {\r\n                                    continue;\r\n                                }\r\n                                realPoints.push(point);\r\n                                var angle = $math.round($math.getAngle(prevPoint, point), 5);\r\n                                //this.allPoints.push({ x: point.x, y: point.y, angle: angle });\r\n                                this._distance += $math.getDistance(prevPoint, point);\r\n                                this.allPoints[Math.floor(this._distance)] = { x: point.x, y: point.y, angle: angle };\r\n                                prevPoint = point;\r\n                            }\r\n                        }\r\n                        else {\r\n                            realPoints.push(p0);\r\n                        }\r\n                    }\r\n                }\r\n                var allPoints = this.allPoints;\r\n                if (allPoints.length > 1) {\r\n                    for (var i_1 = 0; i_1 < allPoints.length; i_1++) {\r\n                        if (!allPoints[i_1]) {\r\n                            if (i_1 > 1) {\r\n                                allPoints[i_1] = allPoints[i_1 - 1];\r\n                            }\r\n                            else {\r\n                                for (var k = 1; k < allPoints.length; k++) {\r\n                                    if (allPoints[k]) {\r\n                                        allPoints[i_1] = allPoints[k];\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.path = path;\r\n        }\r\n    };\r\n    /**\r\n     * Returns an index of the point that is closest to specified coordinates.\r\n     *\r\n     * @param   point  Reference point\r\n     * @return         Index\r\n     */\r\n    Polyspline.prototype.getClosestPointIndex = function (point) {\r\n        var points = this.allPoints;\r\n        var index;\r\n        var closest = Infinity;\r\n        if (points.length > 1) {\r\n            for (var p = 1; p < points.length; p++) {\r\n                var distance = $math.getDistance(point, points[p]);\r\n                if (distance < closest) {\r\n                    index = p;\r\n                    closest = distance;\r\n                }\r\n            }\r\n        }\r\n        return index;\r\n    };\r\n    Object.defineProperty(Polyspline.prototype, \"tensionX\", {\r\n        /**\r\n         * @return Tension\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"tensionX\");\r\n        },\r\n        /**\r\n         * Horizontal tension for the spline.\r\n         *\r\n         * Used by the line smoothing algorithm.\r\n         *\r\n         * @default 0.5\r\n         * @param value  Tension\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"tensionX\", value);\r\n            this.makePath();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Polyspline.prototype, \"tensionY\", {\r\n        /**\r\n         * @return Tension\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"tensionY\");\r\n        },\r\n        /**\r\n         * Vertical tension for the spline.\r\n         *\r\n         * Used by the line smoothing algorithm.\r\n         *\r\n         * @default 0.5\r\n         * @param value  Tensions\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"tensionY\", value, true);\r\n            this.makePath();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Converts relative position along the line (0-1) into pixel coordinates.\r\n     *\r\n     * @param position  Position (0-1)\r\n     * @return Coordinates\r\n     */\r\n    Polyspline.prototype.positionToPoint = function (position, extend) {\r\n        var deltaAngle = 0;\r\n        var allPoints = this.allPoints;\r\n        var len = allPoints.length;\r\n        if (!$type.isNumber(position)) {\r\n            position = 0;\r\n        }\r\n        if (len > 1) {\r\n            if (extend && len > 3) {\r\n                if (position < 0) {\r\n                    if (position < -0.01) {\r\n                        position = -0.01;\r\n                    }\r\n                    var f0 = allPoints[0];\r\n                    var f1 = allPoints[1];\r\n                    var x = f0.x - (f0.x - f1.x) * len * position;\r\n                    var y = f0.y - (f0.y - f1.y) * len * position;\r\n                    return { x: x, y: y, angle: $math.getAngle(f0, f1) };\r\n                }\r\n                else if (position > 1) {\r\n                    if (position > 1.01) {\r\n                        position = 1.01;\r\n                    }\r\n                    var f0 = allPoints[allPoints.length - 2];\r\n                    var f1 = allPoints[allPoints.length - 3];\r\n                    var x = f0.x + (f0.x - f1.x) * len * (position - 1);\r\n                    var y = f0.y + (f0.y - f1.y) * len * (position - 1);\r\n                    return { x: x, y: y, angle: $math.getAngle(f0, { x: x, y: y }) };\r\n                }\r\n                else if (position == 1) {\r\n                    var point_1 = allPoints[allPoints.length - 1];\r\n                    return { x: point_1.x, y: point_1.y, angle: point_1.angle };\r\n                }\r\n            }\r\n            else {\r\n                if (position < 0) {\r\n                    position = Math.abs(position);\r\n                    deltaAngle = 180;\r\n                }\r\n                if (position >= 1) {\r\n                    position = 0.9999999999999;\r\n                }\r\n            }\r\n            var point = allPoints[Math.floor(position * len)];\r\n            return { x: point.x, y: point.y, angle: point.angle + deltaAngle };\r\n        }\r\n        else if (len == 1) {\r\n            var point = allPoints[0];\r\n            return { x: point.x, y: point.y, angle: point.angle };\r\n        }\r\n        else {\r\n            return { x: 0, y: 0, angle: 0 };\r\n        }\r\n    };\r\n    return Polyspline;\r\n}(Polyline));\r\nexport { Polyspline };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Polyspline\"] = Polyspline;\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,SAAS,QAAQ,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,QAAQ,QAAQ,YAAY;AACrC,SAASC,QAAQ,QAAQ,aAAa;AACtC,OAAO,KAAKC,KAAK,MAAM,uBAAuB;AAC9C,OAAO,KAAKC,KAAK,MAAM,uBAAuB;AAC9C,OAAO,KAAKC,KAAK,MAAM,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,UAAU,GAAG,aAAe,UAAUC,MAAM,EAAE;EAC9CP,SAAS,CAACM,UAAU,EAAEC,MAAM,CAAC;EAC7B;AACJ;AACA;EACI,SAASD,UAAUA,CAAA,EAAG;IAClB,IAAIE,KAAK,GAAGD,MAAM,CAACE,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI;IACrCD,KAAK,CAACE,SAAS,GAAG,YAAY;IAC9BF,KAAK,CAACG,QAAQ,GAAG,GAAG;IACpBH,KAAK,CAACI,QAAQ,GAAG,GAAG;IACpBJ,KAAK,CAACK,UAAU,CAAC,CAAC;IAClB,OAAOL,KAAK;EAChB;EACA;AACJ;AACA;AACA;AACA;EACIF,UAAU,CAACQ,SAAS,CAACC,QAAQ,GAAG,YAAY;IACxC,IAAI,CAACC,SAAS,GAAG,CAAC;IAClB,IAAIC,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC5B,IAAIN,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC5B,IAAIC,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC5B,IAAI,CAACM,SAAS,GAAG,EAAE;IACnB,IAAID,QAAQ,IAAIA,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;MACjC,IAAIC,IAAI,GAAG,EAAE;MACb,IAAI,CAACC,aAAa,GAAG,EAAE;MACvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGN,QAAQ,CAACE,MAAM,EAAEG,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QACjD,IAAIE,MAAM,GAAGP,QAAQ,CAACK,CAAC,CAAC;QACxB,IAAIG,UAAU,GAAG,EAAE;QACnB,IAAI,CAACJ,aAAa,CAACK,IAAI,CAACD,UAAU,CAAC;QACnC,IAAID,MAAM,CAACL,MAAM,GAAG,CAAC,EAAE;UACnB,IAAIQ,KAAK,GAAGH,MAAM,CAAC,CAAC,CAAC;UACrB,IAAII,IAAI,GAAGJ,MAAM,CAACA,MAAM,CAACL,MAAM,GAAG,CAAC,CAAC;UACpC,IAAIU,QAAQ,GAAG,KAAK;UACpB,IAAI1B,KAAK,CAAC2B,KAAK,CAACH,KAAK,CAACI,CAAC,EAAE,CAAC,CAAC,IAAI5B,KAAK,CAAC2B,KAAK,CAACF,IAAI,CAACG,CAAC,CAAC,IAAI5B,KAAK,CAAC2B,KAAK,CAACH,KAAK,CAACK,CAAC,CAAC,IAAI7B,KAAK,CAAC2B,KAAK,CAACF,IAAI,CAACI,CAAC,CAAC,EAAE;YAC/FH,QAAQ,GAAG,IAAI;UACnB;UACAT,IAAI,IAAIf,KAAK,CAAC4B,MAAM,CAACT,MAAM,CAAC,CAAC,CAAC,CAAC;UAC/B,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,MAAM,CAACL,MAAM,GAAG,CAAC,EAAEe,CAAC,EAAE,EAAE;YACxC,IAAIC,EAAE,GAAGX,MAAM,CAACU,CAAC,GAAG,CAAC,CAAC;YACtB,IAAIE,EAAE,GAAGZ,MAAM,CAACU,CAAC,CAAC;YAClB,IAAIG,EAAE,GAAGb,MAAM,CAACU,CAAC,GAAG,CAAC,CAAC;YACtB,IAAII,EAAE,GAAGd,MAAM,CAACU,CAAC,GAAG,CAAC,CAAC;YACtB,IAAIA,CAAC,KAAK,CAAC,EAAE;cACTC,EAAE,GAAGX,MAAM,CAACU,CAAC,CAAC;YAClB,CAAC,MACI,IAAIA,CAAC,IAAIV,MAAM,CAACL,MAAM,GAAG,CAAC,EAAE;cAC7BmB,EAAE,GAAGd,MAAM,CAACU,CAAC,GAAG,CAAC,CAAC;YACtB;YACA,IAAI,CAACI,EAAE,EAAE;cACLA,EAAE,GAAGD,EAAE;YACX;YACA,IAAIH,CAAC,KAAK,CAAC,EAAE;cACT,IAAIL,QAAQ,EAAE;gBACVM,EAAE,GAAGX,MAAM,CAACA,MAAM,CAACL,MAAM,GAAG,CAAC,CAAC;cAClC,CAAC,MACI;gBACDgB,EAAE,GAAGX,MAAM,CAACF,CAAC,CAAC;cAClB;YACJ,CAAC,MACI,IAAIY,CAAC,IAAIV,MAAM,CAACL,MAAM,GAAG,CAAC,EAAE;cAC7B,IAAIU,QAAQ,EAAE;gBACVS,EAAE,GAAGd,MAAM,CAAC,CAAC,CAAC;cAClB,CAAC,MACI;gBACDc,EAAE,GAAGd,MAAM,CAACU,CAAC,GAAG,CAAC,CAAC;cACtB;YACJ;YACA,IAAIK,aAAa,GAAGpC,KAAK,CAACqC,qBAAqB,CAACL,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE3B,QAAQ,EAAEC,QAAQ,CAAC;YACnF,IAAI6B,aAAa,GAAGtC,KAAK,CAACuC,qBAAqB,CAACP,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE3B,QAAQ,EAAEC,QAAQ,CAAC;YACnFQ,IAAI,IAAIf,KAAK,CAACsC,YAAY,CAACN,EAAE,EAAEE,aAAa,EAAEE,aAAa,CAAC;YAC5D;YACA,IAAIG,SAAS,GAAGC,IAAI,CAACC,IAAI,CAAC3C,KAAK,CAAC4C,qBAAqB,CAACX,EAAE,EAAEC,EAAE,EAAEE,aAAa,EAAEE,aAAa,EAAE,EAAE,CAAC,CAAC,GAAG,GAAG;YACtG,IAAIO,SAAS,GAAGZ,EAAE;YAClB,IAAIQ,SAAS,GAAG,CAAC,EAAE;cACf;cACA;cACA;cACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIL,SAAS,EAAEK,CAAC,EAAE,EAAE;gBACjC,IAAIC,KAAK,GAAG/C,KAAK,CAACgD,oBAAoB,CAACf,EAAE,EAAEC,EAAE,EAAEE,aAAa,EAAEE,aAAa,EAAEQ,CAAC,GAAGL,SAAS,CAAC;gBAC3F,IAAIM,KAAK,CAACnB,CAAC,IAAIiB,SAAS,CAACjB,CAAC,IAAImB,KAAK,CAAClB,CAAC,IAAIgB,SAAS,CAAChB,CAAC,EAAE;kBAClD;gBACJ;gBACAP,UAAU,CAACC,IAAI,CAACwB,KAAK,CAAC;gBACtB,IAAIE,KAAK,GAAGjD,KAAK,CAAC2B,KAAK,CAAC3B,KAAK,CAACkD,QAAQ,CAACL,SAAS,EAAEE,KAAK,CAAC,EAAE,CAAC,CAAC;gBAC5D;gBACA,IAAI,CAAClC,SAAS,IAAIb,KAAK,CAACmD,WAAW,CAACN,SAAS,EAAEE,KAAK,CAAC;gBACrD,IAAI,CAAChC,SAAS,CAAC2B,IAAI,CAACU,KAAK,CAAC,IAAI,CAACvC,SAAS,CAAC,CAAC,GAAG;kBAAEe,CAAC,EAAEmB,KAAK,CAACnB,CAAC;kBAAEC,CAAC,EAAEkB,KAAK,CAAClB,CAAC;kBAAEoB,KAAK,EAAEA;gBAAM,CAAC;gBACrFJ,SAAS,GAAGE,KAAK;cACrB;YACJ,CAAC,MACI;cACDzB,UAAU,CAACC,IAAI,CAACS,EAAE,CAAC;YACvB;UACJ;QACJ;QACA,IAAIjB,SAAS,GAAG,IAAI,CAACA,SAAS;QAC9B,IAAIA,SAAS,CAACC,MAAM,GAAG,CAAC,EAAE;UACtB,KAAK,IAAIqC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGtC,SAAS,CAACC,MAAM,EAAEqC,GAAG,EAAE,EAAE;YAC7C,IAAI,CAACtC,SAAS,CAACsC,GAAG,CAAC,EAAE;cACjB,IAAIA,GAAG,GAAG,CAAC,EAAE;gBACTtC,SAAS,CAACsC,GAAG,CAAC,GAAGtC,SAAS,CAACsC,GAAG,GAAG,CAAC,CAAC;cACvC,CAAC,MACI;gBACD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvC,SAAS,CAACC,MAAM,EAAEsC,CAAC,EAAE,EAAE;kBACvC,IAAIvC,SAAS,CAACuC,CAAC,CAAC,EAAE;oBACdvC,SAAS,CAACsC,GAAG,CAAC,GAAGtC,SAAS,CAACuC,CAAC,CAAC;oBAC7B;kBACJ;gBACJ;cACJ;YACJ;UACJ;QACJ;MACJ;MACA,IAAI,CAACrC,IAAI,GAAGA,IAAI;IACpB;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACId,UAAU,CAACQ,SAAS,CAAC4C,oBAAoB,GAAG,UAAUR,KAAK,EAAE;IACzD,IAAI1B,MAAM,GAAG,IAAI,CAACN,SAAS;IAC3B,IAAIyC,KAAK;IACT,IAAIC,OAAO,GAAGC,QAAQ;IACtB,IAAIrC,MAAM,CAACL,MAAM,GAAG,CAAC,EAAE;MACnB,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,MAAM,CAACL,MAAM,EAAEe,CAAC,EAAE,EAAE;QACpC,IAAI4B,QAAQ,GAAG3D,KAAK,CAACmD,WAAW,CAACJ,KAAK,EAAE1B,MAAM,CAACU,CAAC,CAAC,CAAC;QAClD,IAAI4B,QAAQ,GAAGF,OAAO,EAAE;UACpBD,KAAK,GAAGzB,CAAC;UACT0B,OAAO,GAAGE,QAAQ;QACtB;MACJ;IACJ;IACA,OAAOH,KAAK;EAChB,CAAC;EACDI,MAAM,CAACC,cAAc,CAAC1D,UAAU,CAACQ,SAAS,EAAE,UAAU,EAAE;IACpD;AACR;AACA;IACQmD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACC,gBAAgB,CAAC,UAAU,CAAC;IAC5C,CAAC;IACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MAClB,IAAI,CAACC,gBAAgB,CAAC,UAAU,EAAED,KAAK,CAAC;MACxC,IAAI,CAACrD,QAAQ,CAAC,CAAC;IACnB,CAAC;IACDuD,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFR,MAAM,CAACC,cAAc,CAAC1D,UAAU,CAACQ,SAAS,EAAE,UAAU,EAAE;IACpD;AACR;AACA;IACQmD,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACC,gBAAgB,CAAC,UAAU,CAAC;IAC5C,CAAC;IACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,GAAG,EAAE,SAAAA,CAAUC,KAAK,EAAE;MAClB,IAAI,CAACC,gBAAgB,CAAC,UAAU,EAAED,KAAK,EAAE,IAAI,CAAC;MAC9C,IAAI,CAACrD,QAAQ,CAAC,CAAC;IACnB,CAAC;IACDuD,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF;AACJ;AACA;AACA;AACA;AACA;EACIjE,UAAU,CAACQ,SAAS,CAAC0D,eAAe,GAAG,UAAUC,QAAQ,EAAEC,MAAM,EAAE;IAC/D,IAAIC,UAAU,GAAG,CAAC;IAClB,IAAIzD,SAAS,GAAG,IAAI,CAACA,SAAS;IAC9B,IAAIK,GAAG,GAAGL,SAAS,CAACC,MAAM;IAC1B,IAAI,CAACf,KAAK,CAACwE,QAAQ,CAACH,QAAQ,CAAC,EAAE;MAC3BA,QAAQ,GAAG,CAAC;IAChB;IACA,IAAIlD,GAAG,GAAG,CAAC,EAAE;MACT,IAAImD,MAAM,IAAInD,GAAG,GAAG,CAAC,EAAE;QACnB,IAAIkD,QAAQ,GAAG,CAAC,EAAE;UACd,IAAIA,QAAQ,GAAG,CAAC,IAAI,EAAE;YAClBA,QAAQ,GAAG,CAAC,IAAI;UACpB;UACA,IAAII,EAAE,GAAG3D,SAAS,CAAC,CAAC,CAAC;UACrB,IAAI4D,EAAE,GAAG5D,SAAS,CAAC,CAAC,CAAC;UACrB,IAAIa,CAAC,GAAG8C,EAAE,CAAC9C,CAAC,GAAG,CAAC8C,EAAE,CAAC9C,CAAC,GAAG+C,EAAE,CAAC/C,CAAC,IAAIR,GAAG,GAAGkD,QAAQ;UAC7C,IAAIzC,CAAC,GAAG6C,EAAE,CAAC7C,CAAC,GAAG,CAAC6C,EAAE,CAAC7C,CAAC,GAAG8C,EAAE,CAAC9C,CAAC,IAAIT,GAAG,GAAGkD,QAAQ;UAC7C,OAAO;YAAE1C,CAAC,EAAEA,CAAC;YAAEC,CAAC,EAAEA,CAAC;YAAEoB,KAAK,EAAEjD,KAAK,CAACkD,QAAQ,CAACwB,EAAE,EAAEC,EAAE;UAAE,CAAC;QACxD,CAAC,MACI,IAAIL,QAAQ,GAAG,CAAC,EAAE;UACnB,IAAIA,QAAQ,GAAG,IAAI,EAAE;YACjBA,QAAQ,GAAG,IAAI;UACnB;UACA,IAAII,EAAE,GAAG3D,SAAS,CAACA,SAAS,CAACC,MAAM,GAAG,CAAC,CAAC;UACxC,IAAI2D,EAAE,GAAG5D,SAAS,CAACA,SAAS,CAACC,MAAM,GAAG,CAAC,CAAC;UACxC,IAAIY,CAAC,GAAG8C,EAAE,CAAC9C,CAAC,GAAG,CAAC8C,EAAE,CAAC9C,CAAC,GAAG+C,EAAE,CAAC/C,CAAC,IAAIR,GAAG,IAAIkD,QAAQ,GAAG,CAAC,CAAC;UACnD,IAAIzC,CAAC,GAAG6C,EAAE,CAAC7C,CAAC,GAAG,CAAC6C,EAAE,CAAC7C,CAAC,GAAG8C,EAAE,CAAC9C,CAAC,IAAIT,GAAG,IAAIkD,QAAQ,GAAG,CAAC,CAAC;UACnD,OAAO;YAAE1C,CAAC,EAAEA,CAAC;YAAEC,CAAC,EAAEA,CAAC;YAAEoB,KAAK,EAAEjD,KAAK,CAACkD,QAAQ,CAACwB,EAAE,EAAE;cAAE9C,CAAC,EAAEA,CAAC;cAAEC,CAAC,EAAEA;YAAE,CAAC;UAAE,CAAC;QACpE,CAAC,MACI,IAAIyC,QAAQ,IAAI,CAAC,EAAE;UACpB,IAAIM,OAAO,GAAG7D,SAAS,CAACA,SAAS,CAACC,MAAM,GAAG,CAAC,CAAC;UAC7C,OAAO;YAAEY,CAAC,EAAEgD,OAAO,CAAChD,CAAC;YAAEC,CAAC,EAAE+C,OAAO,CAAC/C,CAAC;YAAEoB,KAAK,EAAE2B,OAAO,CAAC3B;UAAM,CAAC;QAC/D;MACJ,CAAC,MACI;QACD,IAAIqB,QAAQ,GAAG,CAAC,EAAE;UACdA,QAAQ,GAAG5B,IAAI,CAACmC,GAAG,CAACP,QAAQ,CAAC;UAC7BE,UAAU,GAAG,GAAG;QACpB;QACA,IAAIF,QAAQ,IAAI,CAAC,EAAE;UACfA,QAAQ,GAAG,eAAe;QAC9B;MACJ;MACA,IAAIvB,KAAK,GAAGhC,SAAS,CAAC2B,IAAI,CAACU,KAAK,CAACkB,QAAQ,GAAGlD,GAAG,CAAC,CAAC;MACjD,OAAO;QAAEQ,CAAC,EAAEmB,KAAK,CAACnB,CAAC;QAAEC,CAAC,EAAEkB,KAAK,CAAClB,CAAC;QAAEoB,KAAK,EAAEF,KAAK,CAACE,KAAK,GAAGuB;MAAW,CAAC;IACtE,CAAC,MACI,IAAIpD,GAAG,IAAI,CAAC,EAAE;MACf,IAAI2B,KAAK,GAAGhC,SAAS,CAAC,CAAC,CAAC;MACxB,OAAO;QAAEa,CAAC,EAAEmB,KAAK,CAACnB,CAAC;QAAEC,CAAC,EAAEkB,KAAK,CAAClB,CAAC;QAAEoB,KAAK,EAAEF,KAAK,CAACE;MAAM,CAAC;IACzD,CAAC,MACI;MACD,OAAO;QAAErB,CAAC,EAAE,CAAC;QAAEC,CAAC,EAAE,CAAC;QAAEoB,KAAK,EAAE;MAAE,CAAC;IACnC;EACJ,CAAC;EACD,OAAO9C,UAAU;AACrB,CAAC,CAACL,QAAQ,CAAE;AACZ,SAASK,UAAU;AACnB;AACA;AACA;AACA;AACA;AACA;AACAJ,QAAQ,CAAC+E,iBAAiB,CAAC,YAAY,CAAC,GAAG3E,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}