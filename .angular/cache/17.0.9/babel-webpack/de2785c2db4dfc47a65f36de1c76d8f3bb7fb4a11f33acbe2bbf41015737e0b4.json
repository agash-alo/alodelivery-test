{"ast":null,"code":"/**\r\n * 3D slice module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Slice } from \"../Slice\";\nimport { Sprite } from \"../../Sprite\";\nimport * as $math from \"../../utils/Math\";\nimport * as $path from \"../../rendering/Path\";\nimport * as $type from \"../../utils/Type\";\nimport { Color, color } from \"../../utils/Color\";\nimport { RadialGradient } from \"../../rendering/fills/RadialGradient\";\nimport { LinearGradient } from \"../../rendering/fills/LinearGradient\";\nimport { LightenFilter } from \"../../rendering/filters/LightenFilter\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Used to draw a 3D slice of a Pie chart.\r\n *\r\n * @see {@link ISlice3DEvents} for a list of available events\r\n * @see {@link ISlice3DAdapters} for a list of available Adapters\r\n */\nvar Slice3D = /** @class */function (_super) {\n  __extends(Slice3D, _super);\n  /**\r\n   * Constructor\r\n   */\n  function Slice3D() {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    _this.className = \"Slice3D\";\n    _this.layout = \"none\";\n    // Create edge container\n    var edge = _this.createChild(Sprite);\n    _this.edge = edge;\n    edge.shouldClone = false;\n    edge.isMeasured = false;\n    edge.toBack();\n    // Set defaults\n    _this.angle = 30;\n    _this.depth = 20;\n    // Create side A element\n    var sideA = _this.createChild(Sprite);\n    _this.sideA = sideA;\n    sideA.shouldClone = false;\n    sideA.isMeasured = false;\n    //sideA.setElement(this.paper.add(\"path\"));\n    //sideA.strokeOpacity = 0;\n    // Crate side B element\n    var sideB = _this.createChild(Sprite);\n    _this.sideB = sideB;\n    sideB.shouldClone = false;\n    sideB.isMeasured = false;\n    //sideB.setElement(this.paper.add(\"path\"));\n    //sideB.strokeOpacity = 0;\n    // Apply theme\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * Sets actual `fill` property on the SVG element, including applicable color\r\n   * modifiers.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param value  Fill\r\n   */\n  Slice3D.prototype.setFill = function (value) {\n    _super.prototype.setFill.call(this, value);\n    var colorStr;\n    if (value instanceof Color) {\n      colorStr = value.hex;\n    } else if (value instanceof LinearGradient || value instanceof RadialGradient) {\n      colorStr = value.stops.getIndex(0).color.hex;\n    } else {\n      var filter = new LightenFilter();\n      filter.lightness = -0.25;\n      this.edge.filters.push(filter);\n      this.sideA.filters.push(filter.clone());\n      this.sideB.filters.push(filter.clone());\n    }\n    if (colorStr) {\n      var edgeFill = color(colorStr).lighten(-0.25);\n      this.edge.fill = edgeFill;\n      this.sideA.fill = edgeFill;\n      this.sideB.fill = edgeFill;\n      this.edge.stroke = edgeFill;\n      this.sideA.stroke = edgeFill;\n      this.sideB.stroke = edgeFill;\n    }\n  };\n  /**\r\n   * Draws the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Slice3D.prototype.draw = function () {\n    this.cornerRadius = 0;\n    this.innerCornerRadius = 0;\n    _super.prototype.draw.call(this);\n    if (this.arc !== 0 && this.radius > 0 && this.depth > 0) {\n      this.sideB.show(0);\n      this.sideA.show(0);\n      this.edge.show(0);\n      var startAngle = this.startAngle;\n      var arc = this.arc;\n      var innerRadius = this.pixelInnerRadius || 0;\n      var radiusY = this.radiusY || 0;\n      //let cornerRadius = this.cornerRadius || 0;\n      //let innerCornerRadius = this.innerCornerRadius;\n      var radius = this.radius;\n      // this is code duplicate with $path.arc. @todo to think how to avoid it\n      var endAngle = startAngle + arc;\n      //let crSin = $math.sin($math.min(arc, 45) / 2);\n      //innerCornerRadius = innerCornerRadius || cornerRadius;\n      var innerRadiusY = radiusY / radius * innerRadius;\n      //let cornerRadiusY = (radiusY / radius) * cornerRadius;\n      //let innerCornerRadiusY = (radiusY / radius) * innerCornerRadius;\n      //cornerRadius = $math.fitToRange(cornerRadius, 0, (radius - innerRadius) / 2);\n      //cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\n      //innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, (radius - innerRadius) / 2);\n      //innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\n      //cornerRadius = $math.fitToRange(cornerRadius, 0, radius * crSin);\n      //cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, radiusY * crSin);\n      //innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, innerRadius * crSin);\n      //innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, innerRadiusY * crSin);\n      //let crAngle: number = Math.asin(cornerRadius / radius / 2) * $math.DEGREES * 2;\n      //let crAngleY: number = Math.asin(cornerRadiusY / radiusY / 2) * $math.DEGREES * 2;\n      //if (innerRadius < innerCornerRadius) {\n      //\tinnerRadius = innerCornerRadius;\n      //}\n      //if (innerRadiusY < innerCornerRadiusY) {\n      //\tinnerRadiusY = innerCornerRadiusY;\n      //}\n      //let crInnerAngle: number = Math.asin(innerCornerRadius / innerRadius / 2) * $math.DEGREES * 2;\n      //let crInnerAngleY: number = Math.asin(innerCornerRadiusY / innerRadiusY / 2) * $math.DEGREES * 2;\n      //if (!$type.isNumber(crInnerAngle)) {\n      //\tcrInnerAngle = 0;\n      //}\n      //if (!$type.isNumber(crInnerAngleY)) {\n      //\tcrInnerAngleY = 0;\n      //}\n      //let middleAngle = startAngle + arc / 2;\n      //let mPoint = { x: $math.round($math.cos(middleAngle) * innerRadius, 4), y: $math.round($math.sin(middleAngle) * innerRadiusY, 4) };\n      var a0 = {\n        x: $math.cos(startAngle) * innerRadius,\n        y: $math.sin(startAngle) * innerRadiusY\n      };\n      var b0 = {\n        x: $math.cos(startAngle) * radius,\n        y: $math.sin(startAngle) * radiusY\n      };\n      var c0 = {\n        x: $math.cos(endAngle) * radius,\n        y: $math.sin(endAngle) * radiusY\n      };\n      var d0 = {\n        x: $math.cos(endAngle) * innerRadius,\n        y: $math.sin(endAngle) * innerRadiusY\n      };\n      // end of duplicate\n      var h = this.depth;\n      var ah = {\n        x: a0.x,\n        y: a0.y - h\n      };\n      var bh = {\n        x: b0.x,\n        y: b0.y - h\n      };\n      var ch = {\n        x: c0.x,\n        y: c0.y - h\n      };\n      var dh = {\n        x: d0.x,\n        y: d0.y - h\n      };\n      var edgePath = \"\";\n      var count = Math.ceil(arc / 5);\n      var step = arc / count;\n      var mangle = startAngle;\n      var prevPoint = bh;\n      for (var i = 0; i < count; i++) {\n        mangle += step;\n        if (mangle > 0 && mangle < 180) {\n          edgePath += $path.moveTo(prevPoint);\n          var pp = {\n            x: $math.cos(mangle) * radius,\n            y: $math.sin(mangle) * radiusY - h\n          };\n          edgePath += $path.lineTo({\n            x: prevPoint.x,\n            y: prevPoint.y + h\n          });\n          edgePath += $path.arcToPoint({\n            x: pp.x,\n            y: pp.y + h\n          }, radius, radiusY, true);\n          edgePath += $path.lineTo(pp);\n          edgePath += $path.arcToPoint(prevPoint, radius, radiusY);\n          edgePath += \"z\";\n          prevPoint = pp;\n        } else {\n          edgePath += $path.moveTo(prevPoint);\n          var pp = {\n            x: $math.cos(mangle) * radius,\n            y: $math.sin(mangle) * radiusY - h\n          };\n          edgePath += $path.arcToPoint(pp, radius, radiusY, true);\n          edgePath += $path.lineTo({\n            x: pp.x,\n            y: pp.y + h\n          });\n          edgePath += $path.arcToPoint({\n            x: prevPoint.x,\n            y: prevPoint.y + h\n          }, radius, radiusY);\n          edgePath += $path.lineTo(prevPoint);\n          edgePath += \"z\";\n          prevPoint = pp;\n        }\n      }\n      prevPoint = ah;\n      mangle = startAngle;\n      for (var i = 0; i < count; i++) {\n        mangle += step;\n        if (mangle > 0 && mangle < 180) {\n          edgePath += $path.moveTo(prevPoint);\n          var pp = {\n            x: $math.cos(mangle) * innerRadius,\n            y: $math.sin(mangle) * innerRadiusY - h\n          };\n          edgePath += $path.lineTo({\n            x: prevPoint.x,\n            y: prevPoint.y + h\n          });\n          edgePath += $path.arcToPoint({\n            x: pp.x,\n            y: pp.y + h\n          }, innerRadius, innerRadiusY, true);\n          edgePath += $path.lineTo(pp);\n          edgePath += $path.arcToPoint(prevPoint, innerRadius, innerRadiusY);\n          edgePath += \"z\";\n          prevPoint = pp;\n        } else {\n          edgePath += $path.moveTo(prevPoint);\n          var pp = {\n            x: $math.cos(mangle) * innerRadius,\n            y: $math.sin(mangle) * innerRadiusY - h\n          };\n          edgePath += $path.arcToPoint(pp, innerRadius, innerRadiusY, true);\n          edgePath += $path.lineTo({\n            x: pp.x,\n            y: pp.y + h\n          });\n          edgePath += $path.arcToPoint({\n            x: prevPoint.x,\n            y: prevPoint.y + h\n          }, innerRadius, innerRadiusY);\n          edgePath += $path.lineTo(prevPoint);\n          edgePath += \"z\";\n          prevPoint = pp;\n        }\n      }\n      this.edge.path = edgePath;\n      /*\r\n                  a0 = { x: $math.cos(startAngle) * (innerRadius + innerCornerRadius), y: $math.sin(startAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n                  b0 = { x: $math.cos(startAngle) * (radius - cornerRadius), y: $math.sin(startAngle) * (radiusY - cornerRadiusY) };\r\n                  c0 = { x: $math.cos(endAngle) * (radius - cornerRadius), y: $math.sin(endAngle) * (radiusY - cornerRadiusY) };\r\n                  d0 = { x: $math.cos(endAngle) * (innerRadius + innerCornerRadius), y: $math.sin(endAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n                  // end of duplicate\r\n      \r\n                  ah = { x: a0.x, y: a0.y - h };\r\n                  bh = { x: b0.x, y: b0.y - h };\r\n                  ch = { x: c0.x, y: c0.y - h };\r\n                  dh = { x: d0.x, y: d0.y - h };\r\n      */\n      this.sideA.path = $path.moveTo(a0) + $path.lineTo(b0) + $path.lineTo(bh) + $path.lineTo(ah) + $path.closePath();\n      this.sideB.path = $path.moveTo(c0) + $path.lineTo(d0) + $path.lineTo(dh) + $path.lineTo(ch) + $path.closePath();\n      if (this.startAngle < 90) {\n        this.sideA.toBack();\n      } else {\n        this.sideA.toFront();\n      }\n      if (this.startAngle + this.arc > 90) {\n        this.sideB.toBack();\n      } else {\n        this.sideB.toFront();\n      }\n      this.slice.dy = -h;\n    } else {\n      this.sideA.hide(0);\n      this.sideB.hide(0);\n      this.edge.hide(0);\n    }\n  };\n  Object.defineProperty(Slice3D.prototype, \"depth\", {\n    /**\r\n     * @return Depth (px)\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"depth\");\n    },\n    /**\r\n     * Depth (height) of the 3D slice in pixels.\r\n     *\r\n     * @default 20\r\n     * @param depth  Depth (px)\r\n     */\n    set: function (depth) {\n      this.setPropertyValue(\"depth\", depth, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Slice3D.prototype, \"angle\", {\n    /**\r\n     * @return Angle\r\n     */\n    get: function () {\n      var angle = this.getPropertyValue(\"angle\");\n      if (!$type.isNumber(angle)) {\n        angle = 0;\n      }\n      return angle;\n    },\n    /**\r\n     * Angle of the point of view to the 3D element. (0-360)\r\n     *\r\n     * @default 30\r\n     * @param value  Angle\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"angle\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Slice3D.prototype, \"radiusY\", {\n    /**\r\n     * @return Vertical radius (0-1)\r\n     */\n    get: function () {\n      var radiusY = this.getPropertyValue(\"radiusY\");\n      if (!$type.isNumber(radiusY)) {\n        radiusY = this.radius - this.radius * this.angle / 90;\n      }\n      return radiusY;\n    },\n    /**\r\n     * Vertical radius for creating skewed slices.\r\n     *\r\n     * This is relevant to `radius`, e.g. 0.5 will set vertical radius to half\r\n     * the `radius`.\r\n     *\r\n     * @param value Vertical radius (0-1)\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"radiusY\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies all properties and related data from a different instance of Axis.\r\n   *\r\n   * @param source Source Axis\r\n   */\n  Slice3D.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n    this.edge.copyFrom(source.edge);\n    this.sideA.copyFrom(source.sideA);\n    this.sideB.copyFrom(source.sideB);\n  };\n  return Slice3D;\n}(Slice);\nexport { Slice3D };","map":{"version":3,"names":["__extends","Slice","Sprite","$math","$path","$type","Color","color","RadialGradient","LinearGradient","LightenFilter","Slice3D","_super","_this","call","className","layout","edge","createChild","shouldClone","isMeasured","toBack","angle","depth","sideA","sideB","applyTheme","prototype","setFill","value","colorStr","hex","stops","getIndex","filter","lightness","filters","push","clone","edgeFill","lighten","fill","stroke","draw","cornerRadius","innerCornerRadius","arc","radius","show","startAngle","innerRadius","pixelInnerRadius","radiusY","endAngle","innerRadiusY","a0","x","cos","y","sin","b0","c0","d0","h","ah","bh","ch","dh","edgePath","count","Math","ceil","step","mangle","prevPoint","i","moveTo","pp","lineTo","arcToPoint","path","closePath","toFront","slice","dy","hide","Object","defineProperty","get","getPropertyValue","set","setPropertyValue","enumerable","configurable","isNumber","copyFrom","source"],"sources":["D:/alodelivery test/node_modules/@amcharts/amcharts4/.internal/core/elements/3d/Slice3D.js"],"sourcesContent":["/**\r\n * 3D slice module\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Slice } from \"../Slice\";\r\nimport { Sprite } from \"../../Sprite\";\r\nimport * as $math from \"../../utils/Math\";\r\nimport * as $path from \"../../rendering/Path\";\r\nimport * as $type from \"../../utils/Type\";\r\nimport { Color, color } from \"../../utils/Color\";\r\nimport { RadialGradient } from \"../../rendering/fills/RadialGradient\";\r\nimport { LinearGradient } from \"../../rendering/fills/LinearGradient\";\r\nimport { LightenFilter } from \"../../rendering/filters/LightenFilter\";\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Used to draw a 3D slice of a Pie chart.\r\n *\r\n * @see {@link ISlice3DEvents} for a list of available events\r\n * @see {@link ISlice3DAdapters} for a list of available Adapters\r\n */\r\nvar Slice3D = /** @class */ (function (_super) {\r\n    __extends(Slice3D, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function Slice3D() {\r\n        var _this = \r\n        // Init\r\n        _super.call(this) || this;\r\n        _this.className = \"Slice3D\";\r\n        _this.layout = \"none\";\r\n        // Create edge container\r\n        var edge = _this.createChild(Sprite);\r\n        _this.edge = edge;\r\n        edge.shouldClone = false;\r\n        edge.isMeasured = false;\r\n        edge.toBack();\r\n        // Set defaults\r\n        _this.angle = 30;\r\n        _this.depth = 20;\r\n        // Create side A element\r\n        var sideA = _this.createChild(Sprite);\r\n        _this.sideA = sideA;\r\n        sideA.shouldClone = false;\r\n        sideA.isMeasured = false;\r\n        //sideA.setElement(this.paper.add(\"path\"));\r\n        //sideA.strokeOpacity = 0;\r\n        // Crate side B element\r\n        var sideB = _this.createChild(Sprite);\r\n        _this.sideB = sideB;\r\n        sideB.shouldClone = false;\r\n        sideB.isMeasured = false;\r\n        //sideB.setElement(this.paper.add(\"path\"));\r\n        //sideB.strokeOpacity = 0;\r\n        // Apply theme\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    /**\r\n     * Sets actual `fill` property on the SVG element, including applicable color\r\n     * modifiers.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value  Fill\r\n     */\r\n    Slice3D.prototype.setFill = function (value) {\r\n        _super.prototype.setFill.call(this, value);\r\n        var colorStr;\r\n        if (value instanceof Color) {\r\n            colorStr = value.hex;\r\n        }\r\n        else if (value instanceof LinearGradient || value instanceof RadialGradient) {\r\n            colorStr = value.stops.getIndex(0).color.hex;\r\n        }\r\n        else {\r\n            var filter = new LightenFilter();\r\n            filter.lightness = -0.25;\r\n            this.edge.filters.push(filter);\r\n            this.sideA.filters.push(filter.clone());\r\n            this.sideB.filters.push(filter.clone());\r\n        }\r\n        if (colorStr) {\r\n            var edgeFill = color(colorStr).lighten(-0.25);\r\n            this.edge.fill = edgeFill;\r\n            this.sideA.fill = edgeFill;\r\n            this.sideB.fill = edgeFill;\r\n            this.edge.stroke = edgeFill;\r\n            this.sideA.stroke = edgeFill;\r\n            this.sideB.stroke = edgeFill;\r\n        }\r\n    };\r\n    /**\r\n     * Draws the element.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    Slice3D.prototype.draw = function () {\r\n        this.cornerRadius = 0;\r\n        this.innerCornerRadius = 0;\r\n        _super.prototype.draw.call(this);\r\n        if (this.arc !== 0 && this.radius > 0 && this.depth > 0) {\r\n            this.sideB.show(0);\r\n            this.sideA.show(0);\r\n            this.edge.show(0);\r\n            var startAngle = this.startAngle;\r\n            var arc = this.arc;\r\n            var innerRadius = this.pixelInnerRadius || 0;\r\n            var radiusY = this.radiusY || 0;\r\n            //let cornerRadius = this.cornerRadius || 0;\r\n            //let innerCornerRadius = this.innerCornerRadius;\r\n            var radius = this.radius;\r\n            // this is code duplicate with $path.arc. @todo to think how to avoid it\r\n            var endAngle = startAngle + arc;\r\n            //let crSin = $math.sin($math.min(arc, 45) / 2);\r\n            //innerCornerRadius = innerCornerRadius || cornerRadius;\r\n            var innerRadiusY = (radiusY / radius) * innerRadius;\r\n            //let cornerRadiusY = (radiusY / radius) * cornerRadius;\r\n            //let innerCornerRadiusY = (radiusY / radius) * innerCornerRadius;\r\n            //cornerRadius = $math.fitToRange(cornerRadius, 0, (radius - innerRadius) / 2);\r\n            //cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\r\n            //innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, (radius - innerRadius) / 2);\r\n            //innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\r\n            //cornerRadius = $math.fitToRange(cornerRadius, 0, radius * crSin);\r\n            //cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, radiusY * crSin);\r\n            //innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, innerRadius * crSin);\r\n            //innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, innerRadiusY * crSin);\r\n            //let crAngle: number = Math.asin(cornerRadius / radius / 2) * $math.DEGREES * 2;\r\n            //let crAngleY: number = Math.asin(cornerRadiusY / radiusY / 2) * $math.DEGREES * 2;\r\n            //if (innerRadius < innerCornerRadius) {\r\n            //\tinnerRadius = innerCornerRadius;\r\n            //}\r\n            //if (innerRadiusY < innerCornerRadiusY) {\r\n            //\tinnerRadiusY = innerCornerRadiusY;\r\n            //}\r\n            //let crInnerAngle: number = Math.asin(innerCornerRadius / innerRadius / 2) * $math.DEGREES * 2;\r\n            //let crInnerAngleY: number = Math.asin(innerCornerRadiusY / innerRadiusY / 2) * $math.DEGREES * 2;\r\n            //if (!$type.isNumber(crInnerAngle)) {\r\n            //\tcrInnerAngle = 0;\r\n            //}\r\n            //if (!$type.isNumber(crInnerAngleY)) {\r\n            //\tcrInnerAngleY = 0;\r\n            //}\r\n            //let middleAngle = startAngle + arc / 2;\r\n            //let mPoint = { x: $math.round($math.cos(middleAngle) * innerRadius, 4), y: $math.round($math.sin(middleAngle) * innerRadiusY, 4) };\r\n            var a0 = { x: $math.cos(startAngle) * (innerRadius), y: $math.sin(startAngle) * (innerRadiusY) };\r\n            var b0 = { x: $math.cos(startAngle) * (radius), y: $math.sin(startAngle) * (radiusY) };\r\n            var c0 = { x: $math.cos(endAngle) * (radius), y: $math.sin(endAngle) * (radiusY) };\r\n            var d0 = { x: $math.cos(endAngle) * (innerRadius), y: $math.sin(endAngle) * (innerRadiusY) };\r\n            // end of duplicate\r\n            var h = this.depth;\r\n            var ah = { x: a0.x, y: a0.y - h };\r\n            var bh = { x: b0.x, y: b0.y - h };\r\n            var ch = { x: c0.x, y: c0.y - h };\r\n            var dh = { x: d0.x, y: d0.y - h };\r\n            var edgePath = \"\";\r\n            var count = Math.ceil(arc / 5);\r\n            var step = arc / count;\r\n            var mangle = startAngle;\r\n            var prevPoint = bh;\r\n            for (var i = 0; i < count; i++) {\r\n                mangle += step;\r\n                if (mangle > 0 && mangle < 180) {\r\n                    edgePath += $path.moveTo(prevPoint);\r\n                    var pp = { x: $math.cos(mangle) * (radius), y: $math.sin(mangle) * (radiusY) - h };\r\n                    edgePath += $path.lineTo({ x: prevPoint.x, y: prevPoint.y + h });\r\n                    edgePath += $path.arcToPoint({ x: pp.x, y: pp.y + h }, radius, radiusY, true);\r\n                    edgePath += $path.lineTo(pp);\r\n                    edgePath += $path.arcToPoint(prevPoint, radius, radiusY);\r\n                    edgePath += \"z\";\r\n                    prevPoint = pp;\r\n                }\r\n                else {\r\n                    edgePath += $path.moveTo(prevPoint);\r\n                    var pp = { x: $math.cos(mangle) * (radius), y: $math.sin(mangle) * (radiusY) - h };\r\n                    edgePath += $path.arcToPoint(pp, radius, radiusY, true);\r\n                    edgePath += $path.lineTo({ x: pp.x, y: pp.y + h });\r\n                    edgePath += $path.arcToPoint({ x: prevPoint.x, y: prevPoint.y + h }, radius, radiusY);\r\n                    edgePath += $path.lineTo(prevPoint);\r\n                    edgePath += \"z\";\r\n                    prevPoint = pp;\r\n                }\r\n            }\r\n            prevPoint = ah;\r\n            mangle = startAngle;\r\n            for (var i = 0; i < count; i++) {\r\n                mangle += step;\r\n                if (mangle > 0 && mangle < 180) {\r\n                    edgePath += $path.moveTo(prevPoint);\r\n                    var pp = { x: $math.cos(mangle) * (innerRadius), y: $math.sin(mangle) * (innerRadiusY) - h };\r\n                    edgePath += $path.lineTo({ x: prevPoint.x, y: prevPoint.y + h });\r\n                    edgePath += $path.arcToPoint({ x: pp.x, y: pp.y + h }, innerRadius, innerRadiusY, true);\r\n                    edgePath += $path.lineTo(pp);\r\n                    edgePath += $path.arcToPoint(prevPoint, innerRadius, innerRadiusY);\r\n                    edgePath += \"z\";\r\n                    prevPoint = pp;\r\n                }\r\n                else {\r\n                    edgePath += $path.moveTo(prevPoint);\r\n                    var pp = { x: $math.cos(mangle) * (innerRadius), y: $math.sin(mangle) * (innerRadiusY) - h };\r\n                    edgePath += $path.arcToPoint(pp, innerRadius, innerRadiusY, true);\r\n                    edgePath += $path.lineTo({ x: pp.x, y: pp.y + h });\r\n                    edgePath += $path.arcToPoint({ x: prevPoint.x, y: prevPoint.y + h }, innerRadius, innerRadiusY);\r\n                    edgePath += $path.lineTo(prevPoint);\r\n                    edgePath += \"z\";\r\n                    prevPoint = pp;\r\n                }\r\n            }\r\n            this.edge.path = edgePath;\r\n            /*\r\n                        a0 = { x: $math.cos(startAngle) * (innerRadius + innerCornerRadius), y: $math.sin(startAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n                        b0 = { x: $math.cos(startAngle) * (radius - cornerRadius), y: $math.sin(startAngle) * (radiusY - cornerRadiusY) };\r\n                        c0 = { x: $math.cos(endAngle) * (radius - cornerRadius), y: $math.sin(endAngle) * (radiusY - cornerRadiusY) };\r\n                        d0 = { x: $math.cos(endAngle) * (innerRadius + innerCornerRadius), y: $math.sin(endAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n                        // end of duplicate\r\n            \r\n                        ah = { x: a0.x, y: a0.y - h };\r\n                        bh = { x: b0.x, y: b0.y - h };\r\n                        ch = { x: c0.x, y: c0.y - h };\r\n                        dh = { x: d0.x, y: d0.y - h };\r\n            */\r\n            this.sideA.path = $path.moveTo(a0) + $path.lineTo(b0) + $path.lineTo(bh) + $path.lineTo(ah) + $path.closePath();\r\n            this.sideB.path = $path.moveTo(c0) + $path.lineTo(d0) + $path.lineTo(dh) + $path.lineTo(ch) + $path.closePath();\r\n            if (this.startAngle < 90) {\r\n                this.sideA.toBack();\r\n            }\r\n            else {\r\n                this.sideA.toFront();\r\n            }\r\n            if (this.startAngle + this.arc > 90) {\r\n                this.sideB.toBack();\r\n            }\r\n            else {\r\n                this.sideB.toFront();\r\n            }\r\n            this.slice.dy = -h;\r\n        }\r\n        else {\r\n            this.sideA.hide(0);\r\n            this.sideB.hide(0);\r\n            this.edge.hide(0);\r\n        }\r\n    };\r\n    Object.defineProperty(Slice3D.prototype, \"depth\", {\r\n        /**\r\n         * @return Depth (px)\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"depth\");\r\n        },\r\n        /**\r\n         * Depth (height) of the 3D slice in pixels.\r\n         *\r\n         * @default 20\r\n         * @param depth  Depth (px)\r\n         */\r\n        set: function (depth) {\r\n            this.setPropertyValue(\"depth\", depth, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Slice3D.prototype, \"angle\", {\r\n        /**\r\n         * @return Angle\r\n         */\r\n        get: function () {\r\n            var angle = this.getPropertyValue(\"angle\");\r\n            if (!$type.isNumber(angle)) {\r\n                angle = 0;\r\n            }\r\n            return angle;\r\n        },\r\n        /**\r\n         * Angle of the point of view to the 3D element. (0-360)\r\n         *\r\n         * @default 30\r\n         * @param value  Angle\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"angle\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Slice3D.prototype, \"radiusY\", {\r\n        /**\r\n         * @return Vertical radius (0-1)\r\n         */\r\n        get: function () {\r\n            var radiusY = this.getPropertyValue(\"radiusY\");\r\n            if (!$type.isNumber(radiusY)) {\r\n                radiusY = this.radius - this.radius * this.angle / 90;\r\n            }\r\n            return radiusY;\r\n        },\r\n        /**\r\n         * Vertical radius for creating skewed slices.\r\n         *\r\n         * This is relevant to `radius`, e.g. 0.5 will set vertical radius to half\r\n         * the `radius`.\r\n         *\r\n         * @param value Vertical radius (0-1)\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"radiusY\", value, true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Copies all properties and related data from a different instance of Axis.\r\n     *\r\n     * @param source Source Axis\r\n     */\r\n    Slice3D.prototype.copyFrom = function (source) {\r\n        _super.prototype.copyFrom.call(this, source);\r\n        this.edge.copyFrom(source.edge);\r\n        this.sideA.copyFrom(source.sideA);\r\n        this.sideB.copyFrom(source.sideB);\r\n    };\r\n    return Slice3D;\r\n}(Slice));\r\nexport { Slice3D };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}