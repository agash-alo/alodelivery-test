{"ast":null,"code":"/**\r\n * CSV parser.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { DataParser } from \"./DataParser\";\nimport * as $type from \"../utils/Type\";\nimport * as $array from \"../utils/Array\";\n/**\r\n * Define possible separators.\r\n */\nvar separators = [\",\", \";\", \"\\t\"];\n/**\r\n * A parser for CSV format.\r\n *\r\n * @important\r\n */\nvar CSVParser = /** @class */function (_super) {\n  __extends(CSVParser, _super);\n  function CSVParser() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Content-type suitable for CSV format.\r\n     */\n    _this.contentType = \"text/csv\";\n    /**\r\n     * Parser options.\r\n     *\r\n     * @see {@link ICSVOptions} for description of each option\r\n     */\n    _this.options = {\n      delimiter: \"\",\n      reverse: false,\n      skipRows: 0,\n      skipEmpty: true,\n      useColumnNames: false\n    };\n    return _this;\n  }\n  /**\r\n   * Tests if the format is CSV.\r\n   *\r\n   * @param data  Source data\r\n   * @return Is it CSV?\r\n   */\n  CSVParser.isCSV = function (data) {\n    return CSVParser.getDelimiterFromData(data) ? true : false;\n  };\n  /**\r\n   * Tries to determine a column separator.\r\n   *\r\n   * @param data  Source data\r\n   * @return Separator\r\n   */\n  CSVParser.getDelimiterFromData = function (data) {\n    // We're going to take first few lines of the CSV with different\n    // possible separators and check if it results in same number of columns.\n    // If it does, we're going to assume it's a CSV\n    var lines = data.split(\"\\n\");\n    var len = lines.length;\n    var separator;\n    $array.each(separators, function (sep) {\n      var columns = 0,\n        lineColums = 0;\n      // TODO replace with iterators\n      for (var i = 0; i < len; ++i) {\n        // Get number of columns in a line\n        columns = lines[i].split(sep).length;\n        if (columns > 1) {\n          // More than one column - possible candidate\n          if (lineColums === 0) {\n            // First line\n            lineColums = columns;\n          } else if (columns != lineColums) {\n            // Incorrect number of columns, give up on this separator\n            lineColums = 0;\n            break;\n          }\n        } else {\n          // Not this separator\n          // Not point in continuing\n          lineColums = 0;\n          break;\n        }\n      }\n      // Check if we have a winner\n      if (lineColums) {\n        separator = sep;\n      }\n    });\n    return separator;\n  };\n  /**\r\n   * Parses and returns data.\r\n   *\r\n   * @param data  Unparsed data\r\n   * @return Parsed data\r\n   */\n  CSVParser.prototype.parse = function (csv) {\n    // Check if we have delimiter set\n    if (!this.options.delimiter) {\n      this.options.delimiter = CSVParser.getDelimiterFromData(csv);\n    }\n    // Get CSV data as array\n    var data = this.CSVToArray(csv, this.options.delimiter);\n    // Do we need to cast some fields to numbers?\n    var empty = $type.hasValue(this.options.emptyAs);\n    var numbers = this.parsableNumbers;\n    var dates = this.parsableDates;\n    // Init resuling array\n    var res = [],\n      cols = [],\n      col,\n      i;\n    // Skip rows\n    for (i = 0; i < this.options.skipRows; i++) {\n      data.shift();\n    }\n    // First row holds column names?\n    if (this.options.useColumnNames) {\n      cols = data.shift();\n      // Normalize column names\n      for (var x = 0; x < cols.length; x++) {\n        // trim\n        col = $type.hasValue(cols[x]) ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\";\n        // Check for empty\n        if (\"\" === col) {\n          col = \"col\" + x;\n        }\n        cols[x] = col;\n      }\n    }\n    // Iterate through the result set\n    var row;\n    while (true) {\n      row = this.options.reverse ? data.pop() : data.shift();\n      if (!row) {\n        break;\n      }\n      if (this.options.skipEmpty && row.length === 1 && row[0] === \"\") {\n        continue;\n      }\n      var dataPoint = {};\n      for (i = 0; i < row.length; i++) {\n        col = undefined === cols[i] ? \"col\" + i : cols[i];\n        dataPoint[col] = row[i] === \"\" ? this.options.emptyAs : row[i];\n        // Convert\n        if (empty) {\n          dataPoint[col] = this.maybeToEmpty(dataPoint[col]);\n        }\n        if (numbers) {\n          dataPoint[col] = this.maybeToNumber(col, dataPoint[col]);\n        }\n        if (dates) {\n          dataPoint[col] = this.maybeToDate(col, dataPoint[col]);\n        }\n      }\n      res.push(dataPoint);\n    }\n    return res;\n  };\n  /**\r\n   * Converts CSV into array.\r\n   *\r\n   * The functionality of this function is taken from here:\r\n   * http://www.bennadel.com/blog/1504-ask-ben-parsing-csv-strings-with-javascript-exec-regular-expression-command.htm\r\n   *\r\n   * @param data       Source data\r\n   * @param delimiter  Column delimiter\r\n   * @return Parsed array\r\n   */\n  CSVParser.prototype.CSVToArray = function (data, delimiter) {\n    // Check to see if the delimiter is defined. If not,\n    // then default to comma.\n    delimiter = delimiter || ',';\n    // Create a regular expression to parse the CSV values.\n    var objPattern = new RegExp(\n    // Delimiters.\n    \"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n    // Quoted fields.\n    \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n    // Standard fields.\n    \"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\", \"gi\");\n    // Create an array to hold our data. Give the array\n    // a default empty first row.\n    var arrData = [[]];\n    // Create an array to hold our individual pattern\n    // matching groups.\n    var arrMatches = null;\n    // Keep looping over the regular expression matches\n    // until we can no longer find a match.\n    while (true) {\n      arrMatches = objPattern.exec(data);\n      if (!arrMatches) {\n        break;\n      }\n      // Get the delimiter that was found.\n      var strMatchedDelimiter = arrMatches[1];\n      // Check to see if the given delimiter has a length\n      // (is not the start of string) and if it matches\n      // field delimiter. If id does not, then we know\n      // that this delimiter is a row delimiter.\n      if (strMatchedDelimiter.length && strMatchedDelimiter !== delimiter) {\n        // Since we have reached a new row of data,\n        // add an empty row to our data array.\n        arrData.push([]);\n      }\n      // Now that we have our delimiter out of the way,\n      // let's check to see which kind of value we\n      // captured (quoted or unquoted).\n      var strMatchedValue = void 0;\n      if (arrMatches[2]) {\n        // We found a quoted value. When we capture\n        // this value, unescape any double quotes.\n        strMatchedValue = arrMatches[2].replace(new RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\n      } else {\n        // We found a non-quoted value.\n        strMatchedValue = arrMatches[3];\n      }\n      // Now that we have our value string, let's add\n      // it to the data array.\n      arrData[arrData.length - 1].push(strMatchedValue);\n    }\n    // Return the parsed data.\n    return arrData;\n  };\n  return CSVParser;\n}(DataParser);\nexport { CSVParser };","map":{"version":3,"names":["__extends","DataParser","$type","$array","separators","CSVParser","_super","_this","apply","arguments","contentType","options","delimiter","reverse","skipRows","skipEmpty","useColumnNames","isCSV","data","getDelimiterFromData","lines","split","len","length","separator","each","sep","columns","lineColums","i","prototype","parse","csv","CSVToArray","empty","hasValue","emptyAs","numbers","parsableNumbers","dates","parsableDates","res","cols","col","shift","x","replace","row","pop","dataPoint","undefined","maybeToEmpty","maybeToNumber","maybeToDate","push","objPattern","RegExp","arrData","arrMatches","exec","strMatchedDelimiter","strMatchedValue"],"sources":["D:/alodelivery test/node_modules/@amcharts/amcharts4/.internal/core/data/CSVParser.js"],"sourcesContent":["/**\r\n * CSV parser.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { DataParser } from \"./DataParser\";\r\nimport * as $type from \"../utils/Type\";\r\nimport * as $array from \"../utils/Array\";\r\n/**\r\n * Define possible separators.\r\n */\r\nvar separators = [\",\", \";\", \"\\t\"];\r\n/**\r\n * A parser for CSV format.\r\n *\r\n * @important\r\n */\r\nvar CSVParser = /** @class */ (function (_super) {\r\n    __extends(CSVParser, _super);\r\n    function CSVParser() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /**\r\n         * Content-type suitable for CSV format.\r\n         */\r\n        _this.contentType = \"text/csv\";\r\n        /**\r\n         * Parser options.\r\n         *\r\n         * @see {@link ICSVOptions} for description of each option\r\n         */\r\n        _this.options = {\r\n            delimiter: \"\",\r\n            reverse: false,\r\n            skipRows: 0,\r\n            skipEmpty: true,\r\n            useColumnNames: false\r\n        };\r\n        return _this;\r\n    }\r\n    /**\r\n     * Tests if the format is CSV.\r\n     *\r\n     * @param data  Source data\r\n     * @return Is it CSV?\r\n     */\r\n    CSVParser.isCSV = function (data) {\r\n        return CSVParser.getDelimiterFromData(data) ? true : false;\r\n    };\r\n    /**\r\n     * Tries to determine a column separator.\r\n     *\r\n     * @param data  Source data\r\n     * @return Separator\r\n     */\r\n    CSVParser.getDelimiterFromData = function (data) {\r\n        // We're going to take first few lines of the CSV with different\r\n        // possible separators and check if it results in same number of columns.\r\n        // If it does, we're going to assume it's a CSV\r\n        var lines = data.split(\"\\n\");\r\n        var len = lines.length;\r\n        var separator;\r\n        $array.each(separators, function (sep) {\r\n            var columns = 0, lineColums = 0;\r\n            // TODO replace with iterators\r\n            for (var i = 0; i < len; ++i) {\r\n                // Get number of columns in a line\r\n                columns = lines[i].split(sep).length;\r\n                if (columns > 1) {\r\n                    // More than one column - possible candidate\r\n                    if (lineColums === 0) {\r\n                        // First line\r\n                        lineColums = columns;\r\n                    }\r\n                    else if (columns != lineColums) {\r\n                        // Incorrect number of columns, give up on this separator\r\n                        lineColums = 0;\r\n                        break;\r\n                    }\r\n                }\r\n                else {\r\n                    // Not this separator\r\n                    // Not point in continuing\r\n                    lineColums = 0;\r\n                    break;\r\n                }\r\n            }\r\n            // Check if we have a winner\r\n            if (lineColums) {\r\n                separator = sep;\r\n            }\r\n        });\r\n        return separator;\r\n    };\r\n    /**\r\n     * Parses and returns data.\r\n     *\r\n     * @param data  Unparsed data\r\n     * @return Parsed data\r\n     */\r\n    CSVParser.prototype.parse = function (csv) {\r\n        // Check if we have delimiter set\r\n        if (!this.options.delimiter) {\r\n            this.options.delimiter = CSVParser.getDelimiterFromData(csv);\r\n        }\r\n        // Get CSV data as array\r\n        var data = this.CSVToArray(csv, this.options.delimiter);\r\n        // Do we need to cast some fields to numbers?\r\n        var empty = $type.hasValue(this.options.emptyAs);\r\n        var numbers = this.parsableNumbers;\r\n        var dates = this.parsableDates;\r\n        // Init resuling array\r\n        var res = [], cols = [], col, i;\r\n        // Skip rows\r\n        for (i = 0; i < this.options.skipRows; i++) {\r\n            data.shift();\r\n        }\r\n        // First row holds column names?\r\n        if (this.options.useColumnNames) {\r\n            cols = data.shift();\r\n            // Normalize column names\r\n            for (var x = 0; x < cols.length; x++) {\r\n                // trim\r\n                col = $type.hasValue(cols[x]) ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\";\r\n                // Check for empty\r\n                if (\"\" === col) {\r\n                    col = \"col\" + x;\r\n                }\r\n                cols[x] = col;\r\n            }\r\n        }\r\n        // Iterate through the result set\r\n        var row;\r\n        while (true) {\r\n            row = this.options.reverse ? data.pop() : data.shift();\r\n            if (!row) {\r\n                break;\r\n            }\r\n            if (this.options.skipEmpty && row.length === 1 && row[0] === \"\") {\r\n                continue;\r\n            }\r\n            var dataPoint = {};\r\n            for (i = 0; i < row.length; i++) {\r\n                col = undefined === cols[i] ? \"col\" + i : cols[i];\r\n                dataPoint[col] = row[i] === \"\" ? this.options.emptyAs : row[i];\r\n                // Convert\r\n                if (empty) {\r\n                    dataPoint[col] = this.maybeToEmpty(dataPoint[col]);\r\n                }\r\n                if (numbers) {\r\n                    dataPoint[col] = this.maybeToNumber(col, dataPoint[col]);\r\n                }\r\n                if (dates) {\r\n                    dataPoint[col] = this.maybeToDate(col, dataPoint[col]);\r\n                }\r\n            }\r\n            res.push(dataPoint);\r\n        }\r\n        return res;\r\n    };\r\n    /**\r\n     * Converts CSV into array.\r\n     *\r\n     * The functionality of this function is taken from here:\r\n     * http://www.bennadel.com/blog/1504-ask-ben-parsing-csv-strings-with-javascript-exec-regular-expression-command.htm\r\n     *\r\n     * @param data       Source data\r\n     * @param delimiter  Column delimiter\r\n     * @return Parsed array\r\n     */\r\n    CSVParser.prototype.CSVToArray = function (data, delimiter) {\r\n        // Check to see if the delimiter is defined. If not,\r\n        // then default to comma.\r\n        delimiter = (delimiter || ',');\r\n        // Create a regular expression to parse the CSV values.\r\n        var objPattern = new RegExp((\r\n        // Delimiters.\r\n        \"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\r\n            // Quoted fields.\r\n            \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\r\n            // Standard fields.\r\n            \"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\"), \"gi\");\r\n        // Create an array to hold our data. Give the array\r\n        // a default empty first row.\r\n        var arrData = [\r\n            []\r\n        ];\r\n        // Create an array to hold our individual pattern\r\n        // matching groups.\r\n        var arrMatches = null;\r\n        // Keep looping over the regular expression matches\r\n        // until we can no longer find a match.\r\n        while (true) {\r\n            arrMatches = objPattern.exec(data);\r\n            if (!arrMatches) {\r\n                break;\r\n            }\r\n            // Get the delimiter that was found.\r\n            var strMatchedDelimiter = arrMatches[1];\r\n            // Check to see if the given delimiter has a length\r\n            // (is not the start of string) and if it matches\r\n            // field delimiter. If id does not, then we know\r\n            // that this delimiter is a row delimiter.\r\n            if (strMatchedDelimiter.length &&\r\n                (strMatchedDelimiter !== delimiter)) {\r\n                // Since we have reached a new row of data,\r\n                // add an empty row to our data array.\r\n                arrData.push([]);\r\n            }\r\n            // Now that we have our delimiter out of the way,\r\n            // let's check to see which kind of value we\r\n            // captured (quoted or unquoted).\r\n            var strMatchedValue = void 0;\r\n            if (arrMatches[2]) {\r\n                // We found a quoted value. When we capture\r\n                // this value, unescape any double quotes.\r\n                strMatchedValue = arrMatches[2].replace(new RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\r\n            }\r\n            else {\r\n                // We found a non-quoted value.\r\n                strMatchedValue = arrMatches[3];\r\n            }\r\n            // Now that we have our value string, let's add\r\n            // it to the data array.\r\n            arrData[arrData.length - 1].push(strMatchedValue);\r\n        }\r\n        // Return the parsed data.\r\n        return (arrData);\r\n    };\r\n    return CSVParser;\r\n}(DataParser));\r\nexport { CSVParser };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}