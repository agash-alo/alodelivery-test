{"ast":null,"code":"/**\r\n * DateAxis module\r\n */\nimport { __assign, __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { ValueAxis, ValueAxisDataItem } from \"./ValueAxis\";\nimport { List } from \"../../core/utils/List\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { DateAxisBreak } from \"./DateAxisBreak\";\nimport { registry } from \"../../core/Registry\";\nimport * as $time from \"../../core/utils/Time\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $array from \"../../core/utils/Array\";\nimport * as $object from \"../../core/utils/Object\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport { OrderedListTemplate } from \"../../core/utils/SortedList\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Defines data item for [[DateAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\nvar DateAxisDataItem = /** @class */function (_super) {\n  __extends(DateAxisDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n  function DateAxisDataItem() {\n    var _this = _super.call(this) || this;\n    _this.className = \"DateAxisDataItem\";\n    _this.applyTheme();\n    _this.values.date = {};\n    _this.values.endDate = {};\n    return _this;\n  }\n  Object.defineProperty(DateAxisDataItem.prototype, \"date\", {\n    /**\r\n     * @return Date\r\n     */\n    get: function () {\n      return this.dates[\"date\"];\n    },\n    /**\r\n     * Date position of the data item.\r\n     *\r\n     * @param date  Date\r\n     */\n    set: function (date) {\n      this.setDate(\"date\", date);\n      this.value = date.getTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxisDataItem.prototype, \"endDate\", {\n    /**\r\n     * @return End date\r\n     */\n    get: function () {\n      return this.dates[\"endDate\"];\n    },\n    /**\r\n     * End date for data item.\r\n     *\r\n     * @param date End date\r\n     */\n    set: function (date) {\n      this.setDate(\"endDate\", date);\n      this.endValue = date.getTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DateAxisDataItem;\n}(ValueAxisDataItem);\nexport { DateAxisDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Used to create a date/time-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Time\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Time\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"DateAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Time\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link IDateAxisEvents} for a list of available Events\r\n * @see {@link IDateAxisAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/} got `DateAxis` documention\r\n * @important\r\n */\nvar DateAxis = /** @class */function (_super) {\n  __extends(DateAxis, _super);\n  /**\r\n   * Constructor\r\n   */\n  function DateAxis() {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    _this._gapBreaks = false;\n    /**\r\n     * A list of date/time intervals for Date axis.\r\n     *\r\n     * This define various granularities available for the axis. For example\r\n     * if you have an axis spanning an hour, and space for 6 grid lines / labels\r\n     * the axis will choose the granularity of 10 minutes, displaying a label\r\n     * every 10 minutes.\r\n     *\r\n     * Default intervals:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *  { timeUnit: \"millisecond\", count: 1 },\r\n     *  { timeUnit: \"millisecond\", count: 5 },\r\n     *  { timeUnit: \"millisecond\", count: 10 },\r\n     *  { timeUnit: \"millisecond\", count: 50 },\r\n     *  { timeUnit: \"millisecond\", count: 100 },\r\n     *  { timeUnit: \"millisecond\", count: 500 },\r\n     *  { timeUnit: \"second\", count: 1 },\r\n     *  { timeUnit: \"second\", count: 5 },\r\n     *  { timeUnit: \"second\", count: 10 },\r\n     *  { timeUnit: \"second\", count: 30 },\r\n     *  { timeUnit: \"minute\", count: 1 },\r\n     *  { timeUnit: \"minute\", count: 5 },\r\n     *  { timeUnit: \"minute\", count: 10 },\r\n     *  { timeUnit: \"minute\", count: 30 },\r\n     *  { timeUnit: \"hour\", count: 1 },\r\n     *  { timeUnit: \"hour\", count: 3 },\r\n     *  { timeUnit: \"hour\", count: 6 },\r\n     *  { timeUnit: \"hour\", count: 12 },\r\n     *  { timeUnit: \"day\", count: 1 },\r\n     *  { timeUnit: \"day\", count: 2 },\r\n     *  { timeUnit: \"day\", count: 3 },\r\n     *  { timeUnit: \"day\", count: 4 },\r\n     *  { timeUnit: \"day\", count: 5 },\r\n     *  { timeUnit: \"week\", count: 1 },\r\n     *  { timeUnit: \"month\", count: 1 },\r\n     *  { timeUnit: \"month\", count: 2 },\r\n     *  { timeUnit: \"month\", count: 3 },\r\n     *  { timeUnit: \"month\", count: 6 },\r\n     *  { timeUnit: \"year\", count: 1 },\r\n     *  { timeUnit: \"year\", count: 2 },\r\n     *  { timeUnit: \"year\", count: 5 },\r\n     *  { timeUnit: \"year\", count: 10 },\r\n     *  { timeUnit: \"year\", count: 50 },\r\n     *  { timeUnit: \"year\", count: 100 }\r\n     * ]\r\n     * ```\r\n     */\n    _this.gridIntervals = new List();\n    /**\r\n     * If data aggregation is enabled by setting Axis' `groupData = true`, the\r\n     * chart will try to aggregate data items into grouped data items.\r\n     *\r\n     * If there are more data items in selected period than `groupCount`, it will\r\n     * group data items into bigger period.\r\n     *\r\n     * For example seconds might be grouped into 10-second aggregate data items.\r\n     *\r\n     * This setting indicates what group intervals can the chart group to.\r\n     *\r\n     * Default intervals:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   { timeUnit: \"millisecond\", count: 1},\r\n     *   { timeUnit: \"millisecond\", count: 10 },\r\n     *   { timeUnit: \"millisecond\", count: 100 },\r\n     *   { timeUnit: \"second\", count: 1 },\r\n     *   { timeUnit: \"second\", count: 10 },\r\n     *   { timeUnit: \"minute\", count: 1 },\r\n     *   { timeUnit: \"minute\", count: 10 },\r\n     *   { timeUnit: \"hour\", count: 1 },\r\n     *   { timeUnit: \"day\", count: 1 },\r\n     *   { timeUnit: \"week\", count: 1 },\r\n     *   { timeUnit: \"month\", count: 1 },\r\n     *   { timeUnit: \"year\", count: 1 }\r\n     * ]\r\n     * ```\r\n     * `groupData = true` does not work in combination with `skipEmptyPeriods = true`.\r\n     *\r\n     * @since 4.7.0\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n     */\n    _this.groupIntervals = new List();\n    /**\r\n     * A collection of date formats to use when formatting different time units\r\n     * on Date/time axis.\r\n     *\r\n     * Actual defaults will depend on the language locale set for the chart.\r\n     *\r\n     * To override format for a specific time unit, say days, you need to set\r\n     * the appropriate key to a format string. E.g.:\r\n     *\r\n     * ```TypeScript\r\n     * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n     * ```\r\n     * ```JavaScript\r\n     * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n     * ```\r\n     * ```JSON\r\n     * \"xAxes\": [{\r\n     *   \"type\": \"DateAxis\",\r\n     *   \"dateFormats\": {\r\n     *     \"day\": \"MMMM d, yyyy\"\r\n     *   }\r\n     * }]\r\n     * ```\r\n     *\r\n     * @see {@link DateFormatter}\r\n     */\n    _this.dateFormats = new Dictionary();\n    /**\r\n     * These formats are applied to labels that are first in a larger unit.\r\n     *\r\n     * For example, if we have a DateAxis with days on it, the first day of month\r\n     * indicates a break in month - a start of the bigger period.\r\n     *\r\n     * For those labels, `periodChangeDateFormats` are applied instead of\r\n     * `dateFormats`.\r\n     *\r\n     * This allows us implement convenient structures, like instead of:\r\n     *\r\n     * `Jan 1 - Jan 2 - Jan 3 - ...`\r\n     *\r\n     * We can have:\r\n     *\r\n     * `Jan - 1 - 2 - 3 - ...`\r\n     *\r\n     * This can be disabled by setting `markUnitChange = false`.\r\n     */\n    _this.periodChangeDateFormats = new Dictionary();\n    /**\r\n     * Actual interval (granularity) derived from the actual data.\r\n     */\n    _this._baseIntervalReal = {\n      timeUnit: \"day\",\n      count: 1\n    };\n    /**\r\n     */\n    _this._prevSeriesTime = {};\n    /**\r\n     * [_minDifference description]\r\n     *\r\n     * @todo Description\r\n     */\n    _this._minDifference = {};\n    /**\r\n     * @ignore\r\n     */\n    _this._firstWeekDay = 1;\n    /**\r\n     * A collection of start timestamps to use as axis' min timestamp for\r\n     * particular data item item periods.\r\n     *\r\n     * @since 4.7.0\r\n     * @readonly\r\n     */\n    _this.groupMin = {};\n    /**\r\n     * A collection of start timestamps to use as axis' max timestamp for\r\n     * particular data item item periods.\r\n     *\r\n     * @since 4.7.0\r\n     * @readonly\r\n     */\n    _this.groupMax = {};\n    _this._intervalMax = {};\n    _this._intervalMin = {};\n    _this.className = \"DateAxis\";\n    _this.setPropertyValue(\"markUnitChange\", true);\n    _this.snapTooltip = true;\n    _this.tooltipPosition = \"pointer\";\n    _this.setPropertyValue(\"groupData\", false);\n    _this.groupCount = 200;\n    _this.events.on(\"parentset\", _this.getDFFormatter, _this, false);\n    // Translatable defaults are applied in `applyInternalDefaults()`\n    // ...\n    // Define default intervals\n    _this.gridIntervals.pushAll([{\n      timeUnit: \"millisecond\",\n      count: 1\n    }, {\n      timeUnit: \"millisecond\",\n      count: 5\n    }, {\n      timeUnit: \"millisecond\",\n      count: 10\n    }, {\n      timeUnit: \"millisecond\",\n      count: 50\n    }, {\n      timeUnit: \"millisecond\",\n      count: 100\n    }, {\n      timeUnit: \"millisecond\",\n      count: 500\n    }, {\n      timeUnit: \"second\",\n      count: 1\n    }, {\n      timeUnit: \"second\",\n      count: 5\n    }, {\n      timeUnit: \"second\",\n      count: 10\n    }, {\n      timeUnit: \"second\",\n      count: 30\n    }, {\n      timeUnit: \"minute\",\n      count: 1\n    }, {\n      timeUnit: \"minute\",\n      count: 5\n    }, {\n      timeUnit: \"minute\",\n      count: 10\n    }, {\n      timeUnit: \"minute\",\n      count: 15\n    }, {\n      timeUnit: \"minute\",\n      count: 30\n    }, {\n      timeUnit: \"hour\",\n      count: 1\n    }, {\n      timeUnit: \"hour\",\n      count: 3\n    }, {\n      timeUnit: \"hour\",\n      count: 6\n    }, {\n      timeUnit: \"hour\",\n      count: 12\n    }, {\n      timeUnit: \"day\",\n      count: 1\n    }, {\n      timeUnit: \"day\",\n      count: 2\n    }, {\n      timeUnit: \"day\",\n      count: 3\n    }, {\n      timeUnit: \"day\",\n      count: 4\n    }, {\n      timeUnit: \"day\",\n      count: 5\n    }, {\n      timeUnit: \"week\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 2\n    }, {\n      timeUnit: \"month\",\n      count: 3\n    }, {\n      timeUnit: \"month\",\n      count: 6\n    }, {\n      timeUnit: \"year\",\n      count: 1\n    }, {\n      timeUnit: \"year\",\n      count: 2\n    }, {\n      timeUnit: \"year\",\n      count: 5\n    }, {\n      timeUnit: \"year\",\n      count: 10\n    }, {\n      timeUnit: \"year\",\n      count: 50\n    }, {\n      timeUnit: \"year\",\n      count: 100\n    }, {\n      timeUnit: \"year\",\n      count: 200\n    }, {\n      timeUnit: \"year\",\n      count: 500\n    }, {\n      timeUnit: \"year\",\n      count: 1000\n    }, {\n      timeUnit: \"year\",\n      count: 2000\n    }, {\n      timeUnit: \"year\",\n      count: 5000\n    }, {\n      timeUnit: \"year\",\n      count: 10000\n    }, {\n      timeUnit: \"year\",\n      count: 100000\n    }]);\n    _this.groupIntervals.pushAll([{\n      timeUnit: \"millisecond\",\n      count: 1\n    }, {\n      timeUnit: \"millisecond\",\n      count: 10\n    }, {\n      timeUnit: \"millisecond\",\n      count: 100\n    }, {\n      timeUnit: \"second\",\n      count: 1\n    }, {\n      timeUnit: \"second\",\n      count: 10\n    }, {\n      timeUnit: \"minute\",\n      count: 1\n    }, {\n      timeUnit: \"minute\",\n      count: 10\n    }, {\n      timeUnit: \"hour\",\n      count: 1\n    }, {\n      timeUnit: \"day\",\n      count: 1\n    }, {\n      timeUnit: \"week\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 1\n    }, {\n      timeUnit: \"year\",\n      count: 1\n    }]);\n    // Set field name\n    _this.axisFieldName = \"date\";\n    // Apply theme\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * A function which applies fills to axis cells.\r\n   *\r\n   * Default function fills every second fill. You can set this to a function\r\n   * that follows some other logic.\r\n   *\r\n   * Function should accept a [[DateAxisDataItem]] and modify its `axisFill`\r\n   * property accordingly.\r\n   */\n  DateAxis.prototype.fillRule = function (dataItem) {\n    var value = dataItem.value;\n    var axis = dataItem.component;\n    var gridInterval = axis._gridInterval;\n    var gridDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    if (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {\n      dataItem.axisFill.__disabled = true;\n    } else {\n      dataItem.axisFill.__disabled = false;\n    }\n  };\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n  DateAxis.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n    // Set default date formats\n    if (!this.dateFormats.hasKey(\"millisecond\")) {\n      this.dateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\n    }\n    if (!this.dateFormats.hasKey(\"second\")) {\n      this.dateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\n    }\n    if (!this.dateFormats.hasKey(\"minute\")) {\n      this.dateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\n    }\n    if (!this.dateFormats.hasKey(\"hour\")) {\n      this.dateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\n    }\n    if (!this.dateFormats.hasKey(\"day\")) {\n      this.dateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\n    }\n    if (!this.dateFormats.hasKey(\"week\")) {\n      this.dateFormats.setKey(\"week\", this.language.translate(\"_date_day\")); // not a mistake\n    }\n\n    if (!this.dateFormats.hasKey(\"month\")) {\n      this.dateFormats.setKey(\"month\", this.language.translate(\"_date_month\"));\n    }\n    if (!this.dateFormats.hasKey(\"year\")) {\n      this.dateFormats.setKey(\"year\", this.language.translate(\"_date_year\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"millisecond\")) {\n      this.periodChangeDateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"second\")) {\n      this.periodChangeDateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"minute\")) {\n      this.periodChangeDateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"hour\")) {\n      this.periodChangeDateFormats.setKey(\"hour\", this.language.translate(\"_date_day\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"day\")) {\n      this.periodChangeDateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"week\")) {\n      this.periodChangeDateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\n    }\n    if (!this.periodChangeDateFormats.hasKey(\"month\")) {\n      this.periodChangeDateFormats.setKey(\"month\", this.language.translate(\"_date_month\") + \" \" + this.language.translate(\"_date_year\"));\n    }\n  };\n  /**\r\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n  DateAxis.prototype.createDataItem = function () {\n    return new DateAxisDataItem();\n  };\n  /**\r\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n   *\r\n   * @return Axis break\r\n   */\n  DateAxis.prototype.createAxisBreak = function () {\n    return new DateAxisBreak();\n  };\n  /**\r\n   * Validates Axis' data items.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.validateDataItems = function () {\n    // allows to keep selection of the same size\n    var start = this.start;\n    var end = this.end;\n    var baseDuration = this.baseDuration;\n    var periodCount = (this.max - this.min) / baseDuration;\n    this._firstWeekDay = this.getFirstWeekDay();\n    this.getDFFormatter();\n    _super.prototype.validateDataItems.call(this);\n    var mainBaseDuration = $time.getDuration(this.mainBaseInterval.timeUnit, this.mainBaseInterval.count);\n    this.maxZoomFactor = Math.max(1, (this.max - this.min) / mainBaseDuration);\n    this._deltaMinMax = this.baseDuration / 2;\n    // allows to keep selection of the same size\n    var newPeriodCount = (this.max - this.min) / baseDuration;\n    start = start + (end - start) * (1 - periodCount / newPeriodCount);\n    this.zoom({\n      start: start,\n      end: end\n    }, false, true); // added instantlyto solve zoomout problem when we have axes gaps. @todo: check how this affects maxZoomFactor\n  };\n  /**\r\n   * Handles process after zoom.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Does nothing?\r\n   */\n  DateAxis.prototype.handleSelectionExtremesChange = function () {};\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.getIntervalMax = function (interval) {\n    return this._intervalMax[interval.timeUnit + interval.count];\n  };\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.getIntervalMin = function (interval) {\n    return this._intervalMin[interval.timeUnit + interval.count];\n  };\n  /**\r\n   * Calculates all positions, related to axis as per current zoom.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.calculateZoom = function () {\n    var _this = this;\n    _super.prototype.calculateZoom.call(this);\n    var difference = this.adjustDifference(this._minZoomed, this._maxZoomed);\n    var dataSetChanged = false;\n    // if data has to be grouped, choose interval and set dataset\n    if (this.groupData && $type.hasValue(difference)) {\n      var mainBaseInterval = this.mainBaseInterval;\n      var min = this.getIntervalMin(mainBaseInterval);\n      var max = this.getIntervalMax(mainBaseInterval);\n      var selectionMin = min + (max - min) * this.start;\n      var selectionMax = min + (max - min) * this.end;\n      var diff = this.adjustDifference(selectionMin, selectionMax);\n      var modifiedDifference = diff + (this.startLocation + (1 - this.endLocation)) * this.baseDuration;\n      var groupInterval = void 0;\n      if (this.groupInterval) {\n        groupInterval = __assign({}, this.groupInterval);\n      } else {\n        groupInterval = this.chooseInterval(0, modifiedDifference, this.groupCount, this.groupIntervals);\n        if ($time.getDuration(groupInterval.timeUnit, groupInterval.count) < $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count)) {\n          groupInterval = __assign({}, mainBaseInterval);\n        }\n      }\n      this._groupInterval = groupInterval;\n      var newId = groupInterval.timeUnit + groupInterval.count;\n      if (this._currentDataSetId != newId) {\n        this._currentDataSetId = newId;\n        this.dispatch(\"groupperiodchanged\");\n      }\n      this.series.each(function (series) {\n        if (series.baseAxis == _this) {\n          if (series.setDataSet(_this._currentDataSetId)) {\n            dataSetChanged = true;\n          }\n        }\n      });\n    }\n    var gridInterval = this.chooseInterval(0, difference, this._gridCount);\n    if ($time.getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {\n      gridInterval = __assign({}, this.baseInterval);\n    }\n    this._gridInterval = gridInterval;\n    this._nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n    // the following is needed to avoid grid flickering while scrolling\n    this._intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    this._gridDate = $time.round(new Date(this.minZoomed - $time.getDuration(gridInterval.timeUnit, gridInterval.count)), gridInterval.timeUnit, gridInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);\n    // tell series start/end\n    $iter.each(this.series.iterator(), function (series) {\n      if (series.baseAxis == _this) {\n        var field_1 = series.getAxisField(_this);\n        var minZoomed = $time.round(new Date(_this._minZoomed + _this.baseDuration * 0.05), _this.baseInterval.timeUnit, _this.baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\n        var minZoomedStr = minZoomed.toString();\n        var startDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(minZoomedStr + series.currentDataSetId);\n        var startIndex = 0;\n        if (_this.start != 0) {\n          if (startDataItem) {\n            startDataItem = _this.findFirst(startDataItem, minZoomed, field_1);\n            startIndex = startDataItem.index;\n          } else {\n            startIndex = series.dataItems.findClosestIndex(_this._minZoomed, function (x) {\n              return x[field_1];\n            }, \"left\");\n          }\n        }\n        // 1 millisecond is removed so that if only first item is selected, it would not count in the second.\n        var baseInterval = _this.baseInterval;\n        var maxZoomed = $time.add($time.round(new Date(_this._maxZoomed), baseInterval.timeUnit, baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone), baseInterval.timeUnit, baseInterval.count, _this._df.utc).getTime();\n        var maxZoomedStr = maxZoomed.toString();\n        var endDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(maxZoomedStr + series.currentDataSetId);\n        var endIndex = series.dataItems.length;\n        if (_this.end != 1) {\n          if (endDataItem) {\n            endIndex = endDataItem.index;\n          } else {\n            maxZoomed -= 1;\n            endIndex = series.dataItems.findClosestIndex(maxZoomed, function (x) {\n              return x[field_1];\n            }, \"right\");\n            // not good - if end is in the gap, indexes go like 5,4,3,4,2,1\n            //if (endIndex < series.dataItems.length) {\n            endIndex++;\n            //}\n          }\n        }\n\n        if (series.max(_this) < minZoomed) {\n          series.startIndex = series.dataItems.length;\n          series.endIndex = series.dataItems.length;\n          series.outOfRange = true;\n        } else if (series.min(_this) > maxZoomed) {\n          series.startIndex = 0;\n          series.endIndex = 0;\n          series.outOfRange = true;\n        } else {\n          series.outOfRange = false;\n          series.startIndex = startIndex;\n          series.endIndex = endIndex;\n        }\n        //\tconsole.log(series.name, startIndex, endIndex);\n        if (!dataSetChanged && series.dataRangeInvalid) {\n          series.validateDataRange();\n        }\n      }\n    });\n  };\n  DateAxis.prototype.findFirst = function (dataItem, time, key) {\n    var index = dataItem.index;\n    if (index > 0) {\n      var series = dataItem.component;\n      var previousDataItem = series.dataItems.getIndex(index - 1);\n      var previousDate = previousDataItem[key];\n      if (!previousDate || previousDate.getTime() < time) {\n        return dataItem;\n      } else {\n        return this.findFirst(previousDataItem, time, key);\n      }\n    } else {\n      return dataItem;\n    }\n  };\n  /**\r\n   * (Re)validates data.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.validateData = function () {\n    _super.prototype.validateData.call(this);\n    if (!$type.isNumber(this.baseInterval.count)) {\n      this.baseInterval.count = 1;\n    }\n  };\n  Object.defineProperty(DateAxis.prototype, \"minDifference\", {\n    /**\r\n     * @ignore\r\n     */\n    get: function () {\n      var _this = this;\n      var minDifference = Number.MAX_VALUE;\n      this.series.each(function (series) {\n        if (minDifference > _this._minDifference[series.uid]) {\n          minDifference = _this._minDifference[series.uid];\n        }\n      });\n      if (minDifference == Number.MAX_VALUE || minDifference == 0) {\n        minDifference = $time.getDuration(\"day\");\n      }\n      return minDifference;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * [dataChangeUpdate description]\r\n   *\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n  DateAxis.prototype.seriesDataChangeUpdate = function (series) {\n    this._minDifference[series.uid] = Number.MAX_VALUE;\n  };\n  /**\r\n   * [postProcessSeriesDataItems description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n  DateAxis.prototype.postProcessSeriesDataItems = function (series) {\n    var _this = this;\n    this._firstWeekDay = this.getFirstWeekDay();\n    if (series) {\n      this.seriesGroupUpdate(series);\n    } else {\n      this.series.each(function (series) {\n        _this.seriesGroupUpdate(series);\n      });\n    }\n    this.addEmptyUnitsBreaks();\n  };\n  DateAxis.prototype.seriesGroupUpdate = function (series) {\n    var _this = this;\n    if (JSON.stringify(series._baseInterval[this.uid]) != JSON.stringify(this.mainBaseInterval)) {\n      series._baseInterval[this.uid] = this.mainBaseInterval;\n      series.mainDataSet.each(function (dataItem) {\n        _this.postProcessSeriesDataItem(dataItem);\n      });\n      if (this.groupData) {\n        this.groupSeriesData(series);\n      }\n    }\n  };\n  /**\r\n   * Calculates series group data.\r\n   *\r\n   * @param  series  Series\r\n   * @ignore\r\n   */\n  DateAxis.prototype.groupSeriesData = function (series) {\n    var _this = this;\n    if (series.baseAxis == this && series.dataItems.length > 0 && !series.dataGrouped) {\n      series.bulletsContainer.removeChildren();\n      // make array of intervals which will be used;\n      var intervals_1 = [];\n      var mainBaseInterval = this.mainBaseInterval;\n      var mainIntervalDuration_1 = $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count);\n      this.groupIntervals.each(function (interval) {\n        var intervalDuration = $time.getDuration(interval.timeUnit, interval.count);\n        if (intervalDuration > mainIntervalDuration_1 && intervalDuration < _this.max - _this.min || _this.groupInterval) {\n          intervals_1.push(interval);\n        }\n      });\n      if (series._dataSets) {\n        series._dataSets.each(function (key, dataItems) {\n          dataItems.each(function (dataItem) {\n            dataItem.dispose();\n          });\n          dataItems.clear();\n        });\n        series._dataSets.clear();\n      }\n      series.dataGrouped = true;\n      $array.each(intervals_1, function (interval) {\n        //let mainBaseInterval = this._mainBaseInterval;\n        var key = \"date\" + _this.axisLetter;\n        // create data set\n        var dataSetId = interval.timeUnit + interval.count;\n        // todo: check where this clone goes\n        var dataSet = new OrderedListTemplate(series.mainDataSet.template.clone());\n        series.dataSets.setKey(dataSetId, dataSet);\n        var dataItems = series.mainDataSet;\n        var previousTime = Number.NEGATIVE_INFINITY;\n        var i = 0;\n        var newDataItem;\n        var dataFields = [];\n        $object.each(series.dataFields, function (dfkey, df) {\n          var dfk = dfkey;\n          if (dfk != key && dfk.indexOf(\"Show\") == -1) {\n            dataFields.push(dfk);\n          }\n        });\n        var roundedDate;\n        dataItems.each(function (dataItem) {\n          var date = dataItem.getDate(key);\n          if (date) {\n            var time = date.getTime();\n            roundedDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n            var currentTime = roundedDate.getTime();\n            // changed period\t\t\t\t\t\t\t\t\n            if (previousTime < currentTime) {\n              if (newDataItem && series._adapterO) {\n                $array.each(dataFields, function (vkey) {\n                  newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\n                    dataItem: newDataItem,\n                    interval: interval,\n                    dataField: vkey,\n                    date: roundedDate,\n                    value: newDataItem.values[vkey].value\n                  }).value;\n                  newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\n                });\n              }\n              newDataItem = dataSet.create();\n              newDataItem.dataContext = {};\n              newDataItem.setWorkingLocation(\"dateX\", series.dataItems.template.locations.dateX, 0);\n              newDataItem.setWorkingLocation(\"openDateX\", series.dataItems.template.locations.openDateX, 0);\n              newDataItem.setWorkingLocation(\"dateY\", series.dataItems.template.locations.dateY, 0);\n              newDataItem.setWorkingLocation(\"openDateY\", series.dataItems.template.locations.openDateY, 0);\n              newDataItem.component = series;\n              // other Dates?\n              newDataItem.setDate(key, roundedDate);\n              newDataItem._index = i;\n              i++;\n              $array.each(dataFields, function (vkey) {\n                //let groupFieldName = vkey + \"Group\";\n                var dvalues = dataItem.values[vkey];\n                if (dvalues) {\n                  var value = dvalues.value;\n                  if (series._adapterO) {\n                    value = series._adapterO.apply(\"groupValue\", {\n                      dataItem: dataItem,\n                      interval: interval,\n                      dataField: vkey,\n                      date: roundedDate,\n                      value: value\n                    }).value;\n                  }\n                  var values = newDataItem.values[vkey];\n                  if ($type.isNumber(value)) {\n                    values.value = value;\n                    values.workingValue = value;\n                    values.open = value;\n                    values.close = value;\n                    values.low = value;\n                    values.high = value;\n                    values.sum = value;\n                    values.average = value;\n                    values.count = 1;\n                  } else {\n                    values.count = 0;\n                  }\n                }\n              });\n              _this.postProcessSeriesDataItem(newDataItem, interval);\n              $object.each(series.propertyFields, function (key, fieldValue) {\n                var f = key;\n                var value = dataItem.properties[key];\n                if ($type.hasValue(value)) {\n                  newDataItem.hasProperties = true;\n                  newDataItem.setProperty(f, value);\n                }\n              });\n              newDataItem.groupDataItems = [dataItem];\n              previousTime = currentTime;\n            } else {\n              if (newDataItem) {\n                $array.each(dataFields, function (vkey) {\n                  var groupFieldName = series.groupFields[vkey];\n                  var dvalues = dataItem.values[vkey];\n                  if (dvalues) {\n                    var value = dvalues.value;\n                    if (series._adapterO) {\n                      value = series._adapterO.apply(\"groupValue\", {\n                        dataItem: dataItem,\n                        interval: interval,\n                        dataField: vkey,\n                        date: roundedDate,\n                        value: value\n                      }).value;\n                    }\n                    if ($type.isNumber(value)) {\n                      var values = newDataItem.values[vkey];\n                      if (!$type.isNumber(values.open)) {\n                        values.open = value;\n                      }\n                      values.close = value;\n                      if (values.low > value || !$type.isNumber(values.low)) {\n                        values.low = value;\n                      }\n                      if (values.high < value || !$type.isNumber(values.high)) {\n                        values.high = value;\n                      }\n                      if ($type.isNumber(values.sum)) {\n                        values.sum += value;\n                      } else {\n                        values.sum = value;\n                      }\n                      values.count++;\n                      values.average = values.sum / values.count;\n                      if ($type.isNumber(values[groupFieldName])) {\n                        values.value = values[groupFieldName];\n                        values.workingValue = values.value;\n                      }\n                    }\n                  }\n                });\n                $utils.copyProperties(dataItem.properties, newDataItem.properties);\n                $object.each(series.propertyFields, function (key, fieldValue) {\n                  var f = key;\n                  var value = dataItem.properties[key];\n                  if ($type.hasValue(value)) {\n                    newDataItem.hasProperties = true;\n                    newDataItem.setProperty(f, value);\n                  }\n                });\n                newDataItem.groupDataItems.push(dataItem);\n              }\n            }\n          }\n          if (newDataItem) {\n            $utils.copyProperties(dataItem.dataContext, newDataItem.dataContext);\n          }\n        });\n        if (newDataItem && series._adapterO) {\n          $array.each(dataFields, function (vkey) {\n            newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\n              dataItem: newDataItem,\n              interval: interval,\n              dataField: vkey,\n              date: roundedDate,\n              value: newDataItem.values[vkey].value\n            }).value;\n            newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\n          });\n        }\n      });\n      this.calculateZoom();\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.getDFFormatter = function () {\n    this._df = this.dateFormatter;\n  };\n  /**\r\n   * [postProcessSeriesDataItem description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem Data item\r\n   */\n  DateAxis.prototype.postProcessSeriesDataItem = function (dataItem, interval) {\n    var _this = this;\n    // we need to do this for all series data items not only added recently, as baseInterval might change\n    var intervalID = \"\";\n    if (interval) {\n      intervalID = interval.timeUnit + interval.count;\n    } else {\n      interval = this.mainBaseInterval;\n    }\n    var series = dataItem.component;\n    var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\n    $object.each(dataItem.dates, function (key) {\n      var date = dataItem.getDate(key);\n      var time = date.getTime();\n      var startDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n      var startTime = startDate.getTime();\n      var endDate = $time.add(new Date(startTime), interval.timeUnit, interval.count, _this._df.utc);\n      dataItem.setCalculatedValue(key, startTime, \"open\");\n      dataItem.setCalculatedValue(key, endDate.getTime(), \"close\");\n      dataItemsByAxis.setKey(startTime + intervalID, dataItem);\n    });\n  };\n  /**\r\n   * Collapses empty stretches of date/time scale by creating [[AxisBreak]]\r\n   * elements for them.\r\n   *\r\n   * Can be used to automatically remove strethes without data, like weekends.\r\n   *\r\n   * No, need to call this manually. It will automatically be done if\r\n   * `skipEmptyPeriods = true`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.addEmptyUnitsBreaks = function () {\n    var _this = this;\n    if (this.skipEmptyPeriods && $type.isNumber(this.min) && $type.isNumber(this.max)) {\n      var timeUnit = this.baseInterval.timeUnit;\n      var count = this.baseInterval.count;\n      if (this._axisBreaks) {\n        this._axisBreaks.clear(); // TODO: what about breaks added by user?\n      }\n\n      var date = $time.round(new Date(this.min), timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n      var axisBreak = void 0;\n      var _loop_1 = function () {\n        $time.add(date, timeUnit, count, this_1._df.utc);\n        var startTime = date.getTime();\n        var startTimeStr = startTime.toString();\n        var hasData = $iter.contains(this_1.series.iterator(), function (series) {\n          return !!series.dataItemsByAxis.getKey(_this.uid).getKey(startTimeStr + series.currentDataSetId);\n        });\n        // open break if not yet opened\n        if (!hasData) {\n          if (!axisBreak) {\n            axisBreak = this_1.axisBreaks.create();\n            axisBreak.startDate = new Date(startTime);\n            this_1._gapBreaks = true;\n          }\n        } else {\n          // close if already opened\n          if (axisBreak) {\n            // close at end time minus one millisecond\n            axisBreak.endDate = new Date(startTime - 1);\n            axisBreak = undefined;\n          }\n        }\n      };\n      var this_1 = this;\n      while (date.getTime() < this.max - this.baseDuration) {\n        _loop_1();\n      }\n    }\n  };\n  /**\r\n   * Updates positioning of Axis breaks after something changes.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.fixAxisBreaks = function () {\n    var _this = this;\n    _super.prototype.fixAxisBreaks.call(this);\n    var axisBreaks = this._axisBreaks;\n    if (axisBreaks) {\n      if (axisBreaks.length > 0) {\n        // process breaks\n        axisBreaks.each(function (axisBreak) {\n          var breakGridCount = Math.ceil(_this._gridCount * (Math.min(_this.end, axisBreak.endPosition) - Math.max(_this.start, axisBreak.startPosition)) / (_this.end - _this.start));\n          axisBreak.gridInterval = _this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);\n          var gridDate = $time.round(new Date(axisBreak.adjustedStartValue), axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\n          if (gridDate.getTime() > axisBreak.startDate.getTime()) {\n            $time.add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._df.utc);\n          }\n          axisBreak.gridDate = gridDate;\n        });\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.getFirstWeekDay = function () {\n    if (this._df) {\n      return this._df.firstDayOfWeek;\n    }\n    return 1;\n  };\n  /**\r\n   * [getGridDate description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param date           [description]\r\n   * @param intervalCount  [description]\r\n   * @return [description]\r\n   */\n  DateAxis.prototype.getGridDate = function (date, intervalCount) {\n    var timeUnit = this._gridInterval.timeUnit;\n    var realIntervalCount = this._gridInterval.count;\n    // round date\n    $time.round(date, timeUnit, 1, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    var prevTimestamp = date.getTime();\n    var newDate = $time.copy(date);\n    // modify date by adding intervalcount\n    var timestamp = $time.add(newDate, timeUnit, intervalCount, this._df.utc).getTime();\n    // if it's axis break, get first rounded date which is not in a break\n    var axisBreak = this.isInBreak(timestamp);\n    if (axisBreak && axisBreak.endDate) {\n      newDate = new Date(axisBreak.endDate.getTime());\n      $time.round(newDate, timeUnit, realIntervalCount, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n      if (newDate.getTime() < axisBreak.endDate.getTime()) {\n        $time.add(newDate, timeUnit, realIntervalCount, this._df.utc);\n      }\n      timestamp = newDate.getTime();\n    }\n    // get duration between grid lines with break duration removed\n    var durationBreaksRemoved = this.adjustDifference(prevTimestamp, timestamp);\n    // calculate how many time units fit to this duration\n    var countBreaksRemoved = Math.round(durationBreaksRemoved / $time.getDuration(timeUnit));\n    // if less units fit, add one and repeat\n    if (countBreaksRemoved < realIntervalCount) {\n      return this.getGridDate(date, intervalCount + realIntervalCount);\n    }\n    return newDate;\n  };\n  /**\r\n   * [getBreaklessDate description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param axisBreak  [description]\r\n   * @param timeUnit   [description]\r\n   * @param count      [description]\r\n   * @return [description]\r\n   */\n  DateAxis.prototype.getBreaklessDate = function (axisBreak, timeUnit, count) {\n    var date = new Date(axisBreak.endValue);\n    $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    $time.add(date, timeUnit, count, this._df.utc);\n    var timestamp = date.getTime();\n    axisBreak = this.isInBreak(timestamp);\n    if (axisBreak) {\n      return this.getBreaklessDate(axisBreak, timeUnit, count);\n    }\n    return date;\n  };\n  /**\r\n   * (Re)validates all Axis elements.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   */\n  DateAxis.prototype.validateAxisElements = function () {\n    var _this = this;\n    if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\n      this.calculateZoom();\n      // first regular items\n      var timestamp = this._gridDate.getTime();\n      var timeUnit = this._gridInterval.timeUnit;\n      var intervalCount = this._gridInterval.count;\n      var prevGridDate = $time.copy(this._gridDate);\n      var dataItemsIterator_1 = this._dataItemsIterator;\n      this.resetIterators();\n      var _loop_2 = function () {\n        var date = this_2.getGridDate($time.copy(prevGridDate), intervalCount);\n        timestamp = date.getTime();\n        var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\n        endDate = $time.add(endDate, timeUnit, intervalCount, this_2._df.utc);\n        var format = this_2.dateFormats.getKey(timeUnit);\n        if (this_2.markUnitChange && prevGridDate) {\n          if ($time.checkChange(date, prevGridDate, this_2._nextGridUnit, this_2._df.utc)) {\n            if (timeUnit !== \"year\") {\n              format = this_2.periodChangeDateFormats.getKey(timeUnit);\n            }\n          }\n        }\n        var text = this_2._df.format(date, format);\n        var dataItem = dataItemsIterator_1.find(function (x) {\n          return x.text === text;\n        });\n        if (dataItem.__disabled) {\n          dataItem.__disabled = false;\n        }\n        this_2.appendDataItem(dataItem);\n        dataItem.axisBreak = undefined;\n        dataItem.date = date;\n        dataItem.endDate = endDate;\n        dataItem.text = text;\n        this_2.validateDataElement(dataItem);\n        prevGridDate = date;\n      };\n      var this_2 = this;\n      while (timestamp <= this._maxZoomed) {\n        _loop_2();\n      }\n      // breaks later\n      var renderer_1 = this.renderer;\n      if (this._axisBreaks) {\n        $iter.each(this._axisBreaks.iterator(), function (axisBreak) {\n          if (axisBreak.breakSize > 0) {\n            var timeUnit_1 = axisBreak.gridInterval.timeUnit;\n            var intervalCount_1 = axisBreak.gridInterval.count;\n            // only add grid if gap is bigger then minGridDistance\n            if ($math.getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer_1.minGridDistance * 4) {\n              var timestamp_1 = axisBreak.gridDate.getTime();\n              var prevGridDate_1;\n              var count = 0;\n              var _loop_3 = function () {\n                var date = $time.copy(axisBreak.gridDate);\n                timestamp_1 = $time.add(date, timeUnit_1, intervalCount_1 * count, _this._df.utc).getTime();\n                count++;\n                if (timestamp_1 > axisBreak.adjustedStartValue && timestamp_1 < axisBreak.adjustedEndValue) {\n                  var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\n                  endDate = $time.add(endDate, timeUnit_1, intervalCount_1, _this._df.utc);\n                  var format = _this.dateFormats.getKey(timeUnit_1);\n                  if (_this.markUnitChange && prevGridDate_1) {\n                    if ($time.checkChange(date, prevGridDate_1, _this._nextGridUnit, _this._df.utc)) {\n                      if (timeUnit_1 !== \"year\") {\n                        format = _this.periodChangeDateFormats.getKey(timeUnit_1);\n                      }\n                    }\n                  }\n                  var text_1 = _this._df.format(date, format);\n                  var dataItem = dataItemsIterator_1.find(function (x) {\n                    return x.text === text_1;\n                  });\n                  if (dataItem.__disabled) {\n                    dataItem.__disabled = false;\n                  }\n                  //this.processDataItem(dataItem);\n                  _this.appendDataItem(dataItem);\n                  dataItem.axisBreak = axisBreak;\n                  axisBreak.dataItems.moveValue(dataItem);\n                  dataItem.date = date;\n                  dataItem.endDate = endDate;\n                  dataItem.text = text_1;\n                  prevGridDate_1 = date;\n                  _this.validateDataElement(dataItem);\n                }\n              };\n              while (timestamp_1 <= axisBreak.adjustedMax) {\n                _loop_3();\n              }\n            }\n          }\n        });\n      }\n    }\n  };\n  /**\r\n   * Validates Axis data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param dataItem Data item\r\n   */\n  DateAxis.prototype.validateDataElement = function (dataItem) {\n    dataItem.itemIndex = this._axisItemCount;\n    this._axisItemCount++;\n    if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\n      var renderer = this.renderer;\n      var timestamp = dataItem.value;\n      var endTimestamp = dataItem.endValue;\n      if (!$type.isNumber(endTimestamp)) {\n        endTimestamp = timestamp;\n      }\n      var position = this.valueToPosition(timestamp);\n      var endPosition = this.valueToPosition(endTimestamp);\n      var fillEndPosition = endPosition;\n      if (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {\n        endPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);\n      }\n      dataItem.position = position;\n      var tick = dataItem.tick;\n      if (tick && !tick.disabled) {\n        renderer.updateTickElement(tick, position, endPosition);\n      }\n      var grid = dataItem.grid;\n      if (grid && !grid.disabled) {\n        renderer.updateGridElement(grid, position, endPosition);\n      }\n      var fill = dataItem.axisFill;\n      if (fill && !fill.disabled) {\n        renderer.updateFillElement(fill, position, fillEndPosition);\n        if (!dataItem.isRange) {\n          this.fillRule(dataItem);\n        }\n      }\n      var mask = dataItem.mask;\n      if (mask) {\n        renderer.updateFillElement(mask, position, endPosition);\n      }\n      if (dataItem.bullet) {\n        renderer.updateBullet(dataItem.bullet, position, endPosition);\n      }\n      var label = dataItem.label;\n      if (label && !label.disabled) {\n        var location_1 = label.location;\n        if (location_1 == 0) {\n          if (this._gridInterval.count == 1 && this._gridInterval.timeUnit != \"week\" && !dataItem.isRange) {\n            location_1 = 0.5;\n          } else {\n            location_1 = 0;\n          }\n        }\n        renderer.updateLabelElement(label, position, endPosition, location_1);\n      }\n    }\n  };\n  Object.defineProperty(DateAxis.prototype, \"baseDuration\", {\n    /**\r\n     * A duration in milliseconds of the `baseInterval`.\r\n     *\r\n     * @return Duration (ms)\r\n     */\n    get: function () {\n      return $time.getDuration(this.baseInterval.timeUnit, this.baseInterval.count);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Adjusts min/max values.\r\n   *\r\n   * @ignore Exclude from docs.\r\n   * @todo Description (review)\r\n   * @param min  Min timestamp\r\n   * @param max  Max timestamp\r\n   * @return Adjusted min/max step\r\n   */\n  DateAxis.prototype.adjustMinMax = function (min, max) {\n    return {\n      min: min,\n      max: max,\n      step: this.baseDuration\n    };\n  };\n  /**\r\n   * Adjusts the minimum timestamp as per cell start location.\r\n   *\r\n   * @param value  Value\r\n   * @return Adjusted value\r\n   */\n  DateAxis.prototype.fixMin = function (value) {\n    // like this because months are not equal\n    var interval = this.baseInterval;\n    var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\n    var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\n    return startTime + (endTime - startTime) * this.startLocation;\n  };\n  /**\r\n   * Adjusts the maximum timestamp as per cell start location.\r\n   *\r\n   * @param value  Value\r\n   * @return Adjusted value\r\n   */\n  DateAxis.prototype.fixMax = function (value) {\n    // like this because months are not equal\n    var interval = this.baseInterval;\n    var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\n    var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\n    return startTime + (endTime - startTime) * this.endLocation;\n  };\n  /**\r\n   * [chooseInterval description]\r\n   *\r\n   * @ignore Exclude from docs.\r\n   * @todo Description\r\n   * @param index      [description]\r\n   * @param duration   [description]\r\n   * @param gridCount  [description]\r\n   * @return [description]\r\n   */\n  DateAxis.prototype.chooseInterval = function (index, duration, gridCount, intervals) {\n    if (!intervals) {\n      intervals = this.gridIntervals;\n    }\n    var gridInterval = intervals.getIndex(index);\n    var intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    var lastIndex = intervals.length - 1;\n    if (index >= lastIndex) {\n      return __assign({}, intervals.getIndex(lastIndex));\n    }\n    var count = Math.ceil(duration / intervalDuration);\n    if (duration < intervalDuration && index > 0) {\n      return __assign({}, intervals.getIndex(index - 1));\n    }\n    if (count <= gridCount) {\n      return __assign({}, intervals.getIndex(index));\n    } else {\n      if (index + 1 < intervals.length) {\n        return this.chooseInterval(index + 1, duration, gridCount, intervals);\n      } else {\n        return __assign({}, intervals.getIndex(index));\n      }\n    }\n  };\n  /**\r\n   * Formats the value according to axis' own [[DateFormatter]].\r\n   *\r\n   * @param value  Source value\r\n   * @return Formatted value\r\n   */\n  DateAxis.prototype.formatLabel = function (value) {\n    return this._df.format(value);\n  };\n  /**\r\n   * Converts a Date to an asbolute pixel position within Axis.\r\n   *\r\n   * @param date  Date\r\n   * @return Position (px)\r\n   */\n  DateAxis.prototype.dateToPosition = function (date) {\n    return this.valueToPosition(date.getTime());\n  };\n  /**\r\n   * Converts a numeric timestamp or a `Date` to a relative position on axis.\r\n   *\r\n   * @param date  Date or a timestamp\r\n   * @return Relative position\r\n   */\n  DateAxis.prototype.anyToPosition = function (date) {\n    if (date instanceof Date) {\n      return this.dateToPosition(date);\n    } else {\n      return this.valueToPosition(date);\n    }\n  };\n  /**\r\n   * Converts date to orientation point (x, y, angle) on axis\r\n   *\r\n   * @param date Date\r\n   * @return IOrientationPoint\r\n   */\n  DateAxis.prototype.dateToPoint = function (date) {\n    var position = this.dateToPosition(date);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\r\n   * Converts a numeric value to orientation (x, y, angle) point on axis\r\n   *\r\n   * @param value  Value\r\n   * @return Orientation point\r\n   */\n  DateAxis.prototype.anyToPoint = function (date) {\n    if (date instanceof Date) {\n      return this.dateToPoint(date);\n    } else {\n      return this.valueToPoint(date);\n    }\n  };\n  /**\r\n   * Converts pixel position within Axis to a corresponding Date.\r\n   *\r\n   * @param position  Position (px)\r\n   * @return Date\r\n   */\n  DateAxis.prototype.positionToDate = function (position) {\n    return new Date(this.positionToValue(position));\n  };\n  /**\r\n   * Returns the relative position on axis for series' data item's value.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Data field to get value from\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n  DateAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    //let stack: number = dataItem.getValue(\"valueX\", \"stack\");\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n    var position = this.valueToPosition(value);\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return position;\n  };\n  /**\r\n   * Returns relative position on axis for series' data item's value.\r\n   *\r\n   * @since 4.5.14\r\n   * @param  dataItem  Data item\r\n   * @param  key       Data field to get value from\r\n   * @param  location  Location (0-1)\r\n   * @return           Relative position\r\n   */\n  DateAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    var stack = dataItem.getValue(\"valueX\", \"stack\");\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n    var position = this.valueToPosition(value + stack);\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return position;\n  };\n  /**\r\n   * Returns an angle for series data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param dataItem  Data item\r\n   * @param key       Data field to get value from\r\n   * @param location  Location (0-1)\r\n   * @param stackKey  Stack ID\r\n   * @param range Range to fit in\r\n   * @return Angle\r\n   */\n  DateAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    var stack = dataItem.getValue(stackKey, \"stack\");\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n    var position = this.valueToPosition(value + stack);\n    if (range) {\n      position = $math.fitToRange(position, range.start, range.end);\n    }\n    return this.positionToAngle(position);\n  };\n  /**\r\n   * [getTimeByLocation description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  [description]\r\n   * @param key       [description]\r\n   * @param location  [description]\r\n   * @return [description]\r\n   */\n  DateAxis.prototype.getTimeByLocation = function (dataItem, key, location) {\n    if (!$type.hasValue(key)) {\n      return;\n    }\n    if (!$type.isNumber(location)) {\n      location = dataItem.workingLocations[key];\n      if (!$type.isNumber(location)) {\n        location = 0;\n      }\n    }\n    var startTime = dataItem.values[key][\"open\"];\n    var endTime = dataItem.values[key][\"close\"];\n    var workingValue = dataItem.values[key].workingValue;\n    var value = dataItem.values[key].value;\n    var difference = value - workingValue;\n    startTime -= difference;\n    endTime -= difference;\n    if ($type.isNumber(startTime) && $type.isNumber(endTime)) {\n      return startTime + (endTime - startTime) * location;\n    }\n  };\n  /**\r\n   * Processes a related series' data item.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param dataItem  Data item\r\n   */\n  DateAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\n    var series = dataItem.component;\n    var time;\n    var date = dataItem[\"date\" + axisLetter];\n    if ($type.isNumber(this.timezoneOffset)) {\n      date.setTime(date.getTime() + (date.getTimezoneOffset() - this.timezoneOffset) * 60000);\n      dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\n    } else if ($type.hasValue(this.timezone)) {\n      date = $time.setTimezone(date, this.timezone);\n      dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\n      dataItem[\"date\" + axisLetter] = date;\n    }\n    if (date) {\n      time = date.getTime();\n    } else {\n      return;\n    }\n    var openDate = dataItem[\"openDate\" + axisLetter];\n    var prevSeriesTime = this._prevSeriesTime[series.uid];\n    var openTime;\n    if (openDate) {\n      openTime = openDate.getTime();\n    }\n    if ($type.isNumber(openTime)) {\n      var difference = Math.abs(time - openTime);\n      if (this._minDifference[series.uid] > difference) {\n        this._minDifference[series.uid] = difference;\n      }\n    }\n    var differece = time - prevSeriesTime;\n    if (differece > 0) {\n      if (this._minDifference[series.uid] > differece) {\n        this._minDifference[series.uid] = differece;\n      }\n    }\n    this._prevSeriesTime[series.uid] = time;\n    if (series._baseInterval[this.uid]) {\n      this.postProcessSeriesDataItem(dataItem);\n    }\n  };\n  /**\r\n   * [updateAxisBySeries description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n  DateAxis.prototype.updateAxisBySeries = function () {\n    _super.prototype.updateAxisBySeries.call(this);\n    var baseInterval = this.chooseInterval(0, this.minDifference, 1);\n    if (this.minDifference >= $time.getDuration(\"day\", 27) && baseInterval.timeUnit == \"week\") {\n      baseInterval.timeUnit = \"month\";\n      baseInterval.count = 1;\n    }\n    if (baseInterval.timeUnit == \"month\") {\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 2) && baseInterval.count == 1) {\n        baseInterval.count = 2;\n      }\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 3) && baseInterval.count == 2) {\n        baseInterval.count = 3;\n      }\n      if (this.minDifference >= $time.getDuration(\"day\", 29 * 6) && baseInterval.count == 5) {\n        baseInterval.count = 6;\n      }\n    }\n    // handle daylight saving\n    if (this.minDifference >= $time.getDuration(\"hour\", 23) && baseInterval.timeUnit == \"hour\") {\n      baseInterval.timeUnit = \"day\";\n      baseInterval.count = 1;\n    }\n    if (this.minDifference >= $time.getDuration(\"week\", 1) - $time.getDuration(\"hour\", 1) && baseInterval.timeUnit == \"day\") {\n      baseInterval.timeUnit = \"week\";\n      baseInterval.count = 1;\n    }\n    if (this.minDifference >= $time.getDuration(\"year\", 1) - $time.getDuration(\"day\", 1.01) && baseInterval.timeUnit == \"month\") {\n      baseInterval.timeUnit = \"year\";\n      baseInterval.count = 1;\n    }\n    this._baseIntervalReal = baseInterval;\n    this._mainBaseInterval = baseInterval;\n    // no need to invalidate\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"baseInterval\", {\n    /**\r\n     * @return Base interval\r\n     */\n    get: function () {\n      if (this._groupInterval) {\n        return this._groupInterval;\n      } else if (this._baseInterval) {\n        return this._baseInterval;\n      } else {\n        return this._baseIntervalReal;\n      }\n    },\n    /**\r\n     * A base interval (granularity) of data.\r\n     *\r\n     * Used to indicate what are the base units of your data.\r\n     *\r\n     * For example, if you have a data set that has a data point every 5 minutes,\r\n     * you may want to set this to `{ timeUnit: \"minute\", count: 5 }`.\r\n     *\r\n     * If not set, the Axis will try to determine the setting by its own, looking\r\n     * at actual data.\r\n     *\r\n     * For best results, try to follow these values for `count`:\r\n     *\r\n     * When unit is \"month\", use 12 / count = round number\r\n     * When unit is \"hour\", use 24 / count = round number\r\n     * When unit is \"second\" and \"minute\", use 60 / count = round number\r\n     *\r\n     * @param timeInterval base interval\r\n     */\n    set: function (timeInterval) {\n      if (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {\n        this._baseInterval = timeInterval;\n        this._mainBaseInterval = timeInterval;\n        if (!$type.isNumber(timeInterval.count)) {\n          timeInterval.count = 1;\n        }\n        this.invalidate();\n        this.postProcessSeriesDataItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"mainBaseInterval\", {\n    /**\r\n     * Indicates granularity of the data of source (unaggregated) data.\r\n     *\r\n     * @since 4.7.0\r\n     * @return Granularity of the main data set\r\n     */\n    get: function () {\n      if (this._baseInterval) {\n        return this._baseInterval;\n      } else if (this._mainBaseInterval) {\n        return this._mainBaseInterval;\n      } else {\n        return this._baseIntervalReal;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"skipEmptyPeriods\", {\n    /**\r\n     * @return Remove empty stretches of time?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"skipEmptyPeriods\");\n    },\n    /**\r\n     * If enabled, axis will automatically collapse empty (without data points)\r\n     * periods of time, i.e. weekends.\r\n     *\r\n     * An \"empty\" period is considered a stretch of time in the length of current\r\n     * `baseInterval` without a single data point in it.\r\n     *\r\n     * For each such empty period, axis will automatically create an\r\n     * [[AxisBreak]]. By default they will be invisible. You can still configure\r\n     * them by accessing `axis.breaks.template`.\r\n     *\r\n     * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).\r\n     *\r\n     * Important notes:\r\n     * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.\r\n     * * Using this feature affects performance. Use only if you need it.\r\n     * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.\r\n     * * Some axis label overlapping might happen.\r\n     * * This setting is not compatible with `groupData = true`.\r\n     *\r\n     * @default false\r\n     * @param value  Remove empty stretches of time?\r\n     */\n    set: function (value) {\n      if (value) {\n        var breakTemplate = this.axisBreaks.template;\n        breakTemplate.startLine.disabled = true;\n        breakTemplate.endLine.disabled = true;\n        breakTemplate.fillShape.disabled = true;\n        breakTemplate.breakSize = 0;\n      } else {\n        if (this._gapBreaks) {\n          this.axisBreaks.clear();\n          this._gapBreaks = false;\n        }\n      }\n      if (this.setPropertyValue(\"skipEmptyPeriods\", value)) {\n        this.invalidate();\n        this.postProcessSeriesDataItems();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"tooltipDateFormat\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"tooltipDateFormat\");\n    },\n    /**\r\n     * A special date format to apply axis tooltips.\r\n     *\r\n     * Will use same format as for labels, if not set.\r\n     *\r\n     * @param value  Date format\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"tooltipDateFormat\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"markUnitChange\", {\n    /**\r\n     * @return Use different format for period beginning?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"markUnitChange\");\n    },\n    /**\r\n     * Use `periodChangeDateFormats` to apply different formats to the first\r\n     * label in bigger time unit.\r\n     *\r\n     * @default true\r\n     * @param value  Use different format for period beginning?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"markUnitChange\", value)) {\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Returns text to show in a tooltip, based on specific relative position\r\n   * within axis.\r\n   *\r\n   * The label will be formatted as per [[DateFormatter]] set for the whole\r\n   * chart, or explicitly for this Axis.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position  Position\r\n   * @return Label (formatted date)\r\n   */\n  DateAxis.prototype.getTooltipText = function (position) {\n    var text;\n    var date = this.positionToDate(position);\n    date = $time.round(date, this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);\n    this.tooltipDate = date;\n    if ($type.hasValue(this.tooltipDateFormat)) {\n      text = this._df.format(date, this.tooltipDateFormat, [\"day\", \"month\", \"week\", \"year\"].indexOf(this.baseInterval.timeUnit) == -1);\n    } else {\n      var dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);\n      if (dateFormat) {\n        text = this._df.format(date, dateFormat);\n      } else {\n        text = this.getPositionLabel(position);\n      }\n    }\n    if (!this._adapterO) {\n      return text;\n    } else {\n      return this._adapterO.apply(\"getTooltipText\", text);\n    }\n  };\n  /**\r\n   * Takes an absolute position within axis and adjust it to a specific position within base interval. (cell)\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param position Source position\r\n   * @param location  Location in the cell\r\n   * @return Adjusted position\r\n   */\n  DateAxis.prototype.roundPosition = function (position, location, axisLocation) {\n    var baseInterval = this.baseInterval;\n    var timeUnit = baseInterval.timeUnit;\n    var count = baseInterval.count;\n    var date = this.positionToDate(position);\n    $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    if (location > 0) {\n      $time.add(date, timeUnit, location * count, this._df.utc);\n    }\n    if (axisLocation > 0 && axisLocation < 1) {\n      date.setTime(date.getTime() + this.baseDuration * axisLocation);\n    }\n    if (this.isInBreak(date.getTime())) {\n      while (date.getTime() < this.max) {\n        $time.add(date, timeUnit, count, this._df.utc);\n        if (!this.isInBreak(date.getTime())) {\n          break;\n        }\n      }\n    }\n    return this.dateToPosition(date);\n  };\n  /**\r\n   * Returns an relative position of the start of the cell (period), that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Relative position\r\n   * @return Cell start relative position\r\n   */\n  DateAxis.prototype.getCellStartPosition = function (position) {\n    return this.roundPosition(position, 0);\n  };\n  /**\r\n   * Returns an relative position of the end of the cell (period), that specific position value falls into.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description (review)\r\n   * @param position  Relative position\r\n   * @return Cell end relative position\r\n   */\n  DateAxis.prototype.getCellEndPosition = function (position) {\n    return this.roundPosition(position, 1);\n    //return this.dateToPosition($time.add(this.positionToDate(this.roundPosition(position, 1)), this.baseInterval.timeUnit, this.baseInterval.count));\n  };\n  /**\r\n   * Returns a Series data item that corresponds to the specific pixel position\r\n   * of the Axis.\r\n   *\r\n   * If `findNearest` (third parameter) is set to `true`, the method will try\r\n   * to locate nearest available data item if none is found directly under\r\n   * `position`.\r\n   *\r\n   * @param series       Series\r\n   * @param position     Position (px)\r\n   * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position\r\n   * @return Data item\r\n   */\n  DateAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\n    var value = this.positionToValue(position);\n    var location = 0.5;\n    if (this.axisLetter == \"Y\") {\n      location = series.dataItems.template.locations.dateY;\n    } else {\n      location = series.dataItems.template.locations.dateX;\n    }\n    var deltaValue = value - location * this.baseDuration;\n    var date = $time.round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    var nextDate = $time.round(new Date(value + this.baseDuration), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n    if (nextDate.getTime() > date.getTime()) {\n      if (Math.abs(nextDate.getTime() - deltaValue) < Math.abs(deltaValue - date.getTime())) {\n        date = nextDate;\n      }\n    }\n    var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\n    var dataItem = dataItemsByAxis.getKey(date.getTime() + series.currentDataSetId);\n    // todo:  alternatively we can find closiest here\n    if (!dataItem && findNearest) {\n      var key_1;\n      if (this.axisLetter == \"Y\") {\n        key_1 = \"dateY\";\n      } else {\n        key_1 = \"dateX\";\n      }\n      dataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), function (x) {\n        if (x[key_1]) {\n          return x[key_1].getTime();\n        } else {\n          return -Infinity;\n        }\n      }, \"any\"));\n    }\n    return dataItem;\n  };\n  /**\r\n   * Returns a formatted date based on position in axis scale.\r\n   *\r\n   * Please note that `position` represents position within axis which may be\r\n   * zoomed and not correspond to Cursor's `position`.\r\n   *\r\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n   * @param position  Relative position on axis (0-1)\r\n   * @return Position label\r\n   */\n  DateAxis.prototype.getPositionLabel = function (position) {\n    // @todo Better format recognition\n    var date = this.positionToDate(position);\n    return this._df.format(date, this.getCurrentLabelFormat());\n  };\n  /**\r\n   * Returns label date format based on currently used time units\r\n   *\r\n   * @return Format\r\n   */\n  DateAxis.prototype.getCurrentLabelFormat = function () {\n    return this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : \"day\");\n  };\n  /**\r\n   * Initializes an Axis renderer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  DateAxis.prototype.initRenderer = function () {\n    _super.prototype.initRenderer.call(this);\n    var renderer = this.renderer;\n    if (renderer) {\n      // Set defaults\n      renderer.ticks.template.location = 0;\n      renderer.grid.template.location = 0;\n      renderer.labels.template.location = 0;\n      renderer.baseGrid.disabled = true;\n    }\n  };\n  Object.defineProperty(DateAxis.prototype, \"basePoint\", {\n    /**\r\n     * Coordinates of the actual axis start.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Base point\r\n     */\n    get: function () {\n      return {\n        x: 0,\n        y: 0\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.animateMinMax = function (min, max) {\n    var _this = this;\n    var animation = this.animate([{\n      property: \"_minAdjusted\",\n      from: this._minAdjusted,\n      to: min\n    }, {\n      property: \"_maxAdjusted\",\n      from: this._maxAdjusted,\n      to: max\n    }], this.rangeChangeDuration, this.rangeChangeEasing);\n    animation.events.on(\"animationprogress\", function () {\n      _this.dispatch(\"extremeschanged\");\n    });\n    return animation;\n  };\n  /**\r\n   * Invalidates axis data items when series extremes change\r\n   */\n  DateAxis.prototype.handleExtremesChange = function () {\n    _super.prototype.handleExtremesChange.call(this);\n    if (this.groupData) {\n      var id = this.baseInterval.timeUnit + this.baseInterval.count;\n      this.groupMin[id] = this._finalMin;\n      this.groupMax[id] = this._finalMax;\n    }\n  };\n  /**\r\n   * Zooms axis to specific Dates.\r\n   *\r\n   * @param startDate       Start date\r\n   * @param endValue        End date\r\n   * @param skipRangeEvent  Do not invoke events\r\n   * @param instantly       Do not play zoom animations\r\n   */\n  DateAxis.prototype.zoomToDates = function (startDate, endDate, skipRangeEvent, instantly, adjust) {\n    startDate = this._df.parse(startDate);\n    endDate = this._df.parse(endDate);\n    this.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly, adjust);\n  };\n  /**\r\n   * Zooms axis to specific values.\r\n   *\r\n   * @param startValue      Start value\r\n   * @param endValue        End value\r\n   * @param skipRangeEvent  Do not invoke events\r\n   * @param instantly       Do not play zoom animations\r\n   */\n  DateAxis.prototype.zoomToValues = function (startValue, endValue, skipRangeEvent, instantly, adjust) {\n    var _this = this;\n    if (!this.groupData) {\n      //let start: number = (startValue - this.min) / (this.max - this.min);\n      //let end: number = (endValue - this.min) / (this.max - this.min);\n      var start = this.valueToPosition(startValue);\n      var end = this.valueToPosition(endValue);\n      this.zoom({\n        start: start,\n        end: end\n      }, skipRangeEvent, instantly);\n    } else {\n      var difference = this.adjustDifference(startValue, endValue);\n      var isEnd = false;\n      if (endValue == this.max) {\n        isEnd = true;\n      }\n      var isStart = false;\n      if (startValue == this.min) {\n        isStart = true;\n      }\n      if ($type.hasValue(difference)) {\n        var mainBaseInterval = this.mainBaseInterval;\n        var groupInterval_1 = this.chooseInterval(0, difference, this.groupCount, this.groupIntervals);\n        if (groupInterval_1.timeUnit == mainBaseInterval.timeUnit && groupInterval_1.count < mainBaseInterval.count || $time.getDuration(groupInterval_1.timeUnit, 1) < $time.getDuration(mainBaseInterval.timeUnit, 1)) {\n          groupInterval_1 = __assign({}, mainBaseInterval);\n        }\n        var id = groupInterval_1.timeUnit + groupInterval_1.count;\n        var min_1 = this.groupMin[id];\n        var max_1 = this.groupMax[id];\n        if (!$type.isNumber(min_1) || !$type.isNumber(max_1)) {\n          min_1 = Number.POSITIVE_INFINITY;\n          max_1 = Number.NEGATIVE_INFINITY;\n          this.series.each(function (series) {\n            var seriesMin = series.min(_this);\n            var seriesMax = series.max(_this);\n            if (series._dataSets) {\n              var ds = series._dataSets.getKey(groupInterval_1.timeUnit + groupInterval_1.count);\n              if (ds) {\n                var mindi = ds.getIndex(0);\n                var maxdi = ds.getIndex(ds.length - 1);\n                if (mindi) {\n                  if (series.xAxis == _this) {\n                    seriesMin = mindi.dateX.getTime();\n                  } else if (series.yAxis == _this) {\n                    seriesMin = mindi.dateY.getTime();\n                  }\n                }\n                if (maxdi) {\n                  if (series.xAxis == _this) {\n                    seriesMax = maxdi.dateX.getTime();\n                  } else if (series.yAxis == _this) {\n                    seriesMax = maxdi.dateY.getTime();\n                  }\n                }\n              }\n            }\n            seriesMax = $time.round($time.add(new Date(seriesMax), groupInterval_1.timeUnit, 1, _this._df.utc), groupInterval_1.timeUnit, 1, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\n            if (seriesMin < min_1) {\n              min_1 = seriesMin;\n            }\n            if (seriesMax > max_1) {\n              max_1 = seriesMax;\n            }\n          });\n          this.groupMin[id] = min_1;\n          this.groupMax[id] = max_1;\n        }\n        startValue = $math.fitToRange(startValue, min_1, max_1);\n        endValue = $math.fitToRange(endValue, min_1, max_1);\n        if (adjust) {\n          if (isEnd) {\n            startValue = endValue - difference;\n            startValue = $math.fitToRange(startValue, min_1, max_1);\n          }\n          if (isStart) {\n            endValue = startValue + difference;\n            endValue = $math.fitToRange(endValue, min_1, max_1);\n          }\n        }\n        var start = (startValue - min_1) / (max_1 - min_1);\n        var end = (endValue - min_1) / (max_1 - min_1);\n        this.zoom({\n          start: start,\n          end: end\n        }, skipRangeEvent, instantly);\n      }\n    }\n  };\n  /**\r\n   * Adds `baseInterval` to \"as is\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as is?\r\n   */\n  DateAxis.prototype.asIs = function (field) {\n    return field == \"baseInterval\" || _super.prototype.asIs.call(this, field);\n  };\n  /**\r\n   * Copies all properties and related data from a different instance of Axis.\r\n   *\r\n   * @param source Source Axis\r\n   */\n  DateAxis.prototype.copyFrom = function (source) {\n    var _this = this;\n    _super.prototype.copyFrom.call(this, source);\n    this.dateFormats = source.dateFormats;\n    this.periodChangeDateFormats = source.periodChangeDateFormats;\n    this.groupIntervals.clear();\n    source.groupIntervals.each(function (interval) {\n      _this.groupIntervals.push(__assign({}, interval));\n    });\n    this.gridIntervals.clear();\n    source.gridIntervals.each(function (interval) {\n      _this.gridIntervals.push(__assign({}, interval));\n    });\n    if (source._baseInterval) {\n      this.baseInterval = source._baseInterval;\n    }\n  };\n  /**\r\n   * Shows Axis tooltip at specific relative position within Axis. (0-1)\r\n   *\r\n   * @param position Position (0-1)\r\n   * @param local or global position\r\n   */\n  DateAxis.prototype.showTooltipAtPosition = function (position, local) {\n    var _this = this;\n    if (!local) {\n      position = this.toAxisPosition(position);\n    }\n    if (this.snapTooltip) {\n      // rounding is not good, pen/aac4e7f66f019d36b2447f050c600c13 (no last tootltip shown)\n      var actualDate = this.positionToDate(position); //$time.round(this.positionToDate(position), this.baseInterval.timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n      var actualTime_1 = actualDate.getTime();\n      var closestDate_1;\n      this.series.each(function (series) {\n        if (series.baseAxis == _this) {\n          var dataItem = _this.getSeriesDataItem(series, position, true);\n          if (dataItem) {\n            var date = void 0;\n            if (series.xAxis == _this) {\n              date = dataItem.dateX;\n            }\n            if (series.yAxis == _this) {\n              date = dataItem.dateY;\n            }\n            if (!closestDate_1) {\n              closestDate_1 = date;\n            } else {\n              if (Math.abs(closestDate_1.getTime() - actualTime_1) > Math.abs(date.getTime() - actualTime_1)) {\n                closestDate_1 = date;\n              }\n            }\n          }\n        }\n      });\n      if (closestDate_1) {\n        var closestTime_1 = closestDate_1.getTime();\n        closestDate_1 = $time.round(new Date(closestTime_1), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\n        closestTime_1 = closestDate_1.getTime();\n        var tooltipLocation = this.renderer.tooltipLocation;\n        if (tooltipLocation == 0) {\n          tooltipLocation = 0.0001;\n        }\n        closestDate_1 = new Date(closestDate_1.getTime() + this.baseDuration * tooltipLocation);\n        position = this.dateToPosition(closestDate_1);\n        if (this.chart.cursor && this.chart.cursor.snapToSeries) {\n          //void\n        } else {\n          this.series.each(function (series) {\n            var dataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(closestTime_1 + series.currentDataSetId);\n            var point = series.showTooltipAtDataItem(dataItem);\n            if (point) {\n              _this.chart._seriesPoints.push({\n                series: series,\n                point: point\n              });\n            } else {\n              // check, otherwise column tooltip will be hidden\n              if (series.tooltipText || series.tooltipHTML) {\n                series.hideTooltip();\n              }\n            }\n          });\n        }\n        //this.chart.sortSeriesTooltips(seriesPoints);\n      }\n    }\n\n    _super.prototype.showTooltipAtPosition.call(this, position, true);\n  };\n  Object.defineProperty(DateAxis.prototype, \"snapTooltip\", {\n    /**\r\n     * @return Should snap?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"snapTooltip\");\n    },\n    /**\r\n     * Should the nearest tooltip be shown if no data item is found on the\r\n     * current cursor position.\r\n     *\r\n     * @default true\r\n     * @param value  Should snap?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"snapTooltip\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupData\", {\n    /**\r\n     * @return Group data points?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"groupData\");\n    },\n    /**\r\n     * Indicates if data should be aggregated to composide data items if there\r\n     * are more data items in selected range than `groupCount`.\r\n     *\r\n     * Grouping will occur automatically, based on current selection range, and\r\n     * will change dynamically when user zooms in/out the chart.\r\n     *\r\n     * NOTE: This works only if [[DateAxis]] is base axis of an [[XYSeries]].\r\n     *\r\n     * The related [[XYSeries]] also needs to be set up to take advantage of, by\r\n     * setting its [`groupFields`](https://www.amcharts.com/docs/v4/reference/xyseries/#groupFields_property).\r\n     *\r\n     * The group intervals to aggregate data to is defined by `groupIntervals`\r\n     * property.\r\n     *\r\n     * ```TypeScript\r\n     * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n     * dateAxis.groupData = true;\r\n     *\r\n     * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n     *\r\n     * let series = chart.series.push(new am4charts.LineSeries());\r\n     * series.dataFields.dateX = \"date\";\r\n     * series.dataFields.valueY = \"value\";\r\n     * series.groupFields.valueY = \"average\";\r\n     * ```\r\n     * ```JavaScript\r\n     * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n     * dateAxis.groupData = true;\r\n     *\r\n     * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n     *\r\n     * var series = chart.series.push(new am4charts.LineSeries());\r\n     * series.dataFields.dateX = \"date\";\r\n     * series.dataFields.valueY = \"value\";\r\n     * series.groupFields.valueY = \"average\";\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"xAxes\": [{\r\n     *     \"type\": \"DateAxis\",\r\n     *     \"groupData\": true\r\n     *   }],\r\n     *   \"yAxes\": [{\r\n     *     \"type\": \"ValueAxis\"\r\n     *   }],\r\n     *   \"series\": [{\r\n     *     \"type\": \"LineSeries\",\r\n     *     \"dataFields\": {\r\n     *       \"dateX\": \"date\",\r\n     *       \"valueY\": \"value\"\r\n     *     },\r\n     *     \"groupFields\": {\r\n     *       \"valueY\": \"average\"\r\n     *     }\r\n     *   }]\r\n     * }\r\n     * ```\r\n     *\r\n     * @default false\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n     * @since 4.7.0\r\n     * @param  value  Group data points?\r\n     */\n    set: function (value) {\n      var _this = this;\n      if (this.setPropertyValue(\"groupData\", value)) {\n        this.series.each(function (series) {\n          series.setDataSet(\"\");\n          if (value && !series.dataGrouped && series.inited) {\n            series._baseInterval[_this.uid] = _this.mainBaseInterval;\n            _this.groupSeriesData(series);\n          }\n        });\n        this._currentDataSetId = \"\";\n        this._groupInterval = undefined;\n        this.invalidate();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupInterval\", {\n    /**\r\n     * @return Interval\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"groupInterval\");\n    },\n    /**\r\n     * Disables automatic selection of data grouping intervals and always uses\r\n     * `groupInterval` if set. Works only if `groupData = true`.\r\n     *\r\n     * @since 4.9.24\r\n     * @param  value  Interval\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"groupInterval\", value)) {\n        this.invalidate();\n        this.invalidateSeries();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"groupCount\", {\n    /**\r\n     * @return Number of data items\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"groupCount\");\n    },\n    /**\r\n     * Indicates threshold of data items in selected range at which to start\r\n     * aggregating data items if `groupData = true`.\r\n     *\r\n     * @default 200\r\n     * @since 4.7.0\r\n     * @param  value  Number of data items\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"groupCount\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"timezoneOffset\", {\n    /**\r\n     * @todo Timezone offset in minutes\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"timezoneOffset\");\n    },\n    /**\r\n     * If set will recalculate all timestamps in data by applying specific offset\r\n     * in minutes.\r\n     *\r\n     * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It\r\n     * will skew your results by applying offset twice.\r\n     *\r\n     * @since 4.8.5\r\n     * @param  value Time zone offset in minutes\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"timezoneOffset\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"timezone\", {\n    /**\r\n     * @return Timezone\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"timezone\");\n    },\n    /**\r\n     * If set will recalculate all timestamps in data to specific named timezone,\r\n     * e.g. `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`, etc.\r\n     *\r\n     * IMPORTANT: it is no longer recommended to use this setting. Please\r\n     * set`timezone` on `dateFormatter`.\r\n     *\r\n     * @deprecated\r\n     * @since 4.10.1\r\n     * @param  value Time zone\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"timezone\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"gridInterval\", {\n    /**\r\n     * Current grid interval.\r\n     *\r\n     * @return Grid interval\r\n     */\n    get: function () {\n      return this._gridInterval;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n  DateAxis.prototype.makeGap = function (dataItem, previous) {\n    var series = dataItem.component;\n    if (dataItem && previous) {\n      if (!series.connect && $type.isNumber(series.autoGapCount)) {\n        if (series.baseAxis == this) {\n          var date = dataItem.dates[\"date\" + this.axisLetter];\n          var prevDate = previous.dates[\"date\" + this.axisLetter];\n          if (date && prevDate) {\n            var time = date.getTime();\n            var prevTime = prevDate.getTime();\n            if (time - prevTime > series.autoGapCount * this.baseDuration) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  };\n  Object.defineProperty(DateAxis.prototype, \"baseValue\", {\n    /**\r\n     * @return base value\r\n     */\n    get: function () {\n      return this.min;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  DateAxis.prototype._saveMinMax = function (min, max) {\n    var groupInterval = this.groupInterval;\n    if (!groupInterval) {\n      groupInterval = this.mainBaseInterval;\n    }\n    var id = groupInterval.timeUnit + groupInterval.count;\n    this._intervalMin[id] = min;\n    this._intervalMax[id] = max;\n  };\n  return DateAxis;\n}(ValueAxis);\nexport { DateAxis };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"DateAxis\"] = DateAxis;\nregistry.registeredClasses[\"DateAxisDataItem\"] = DateAxisDataItem;","map":{"version":3,"names":["__assign","__extends","ValueAxis","ValueAxisDataItem","List","Dictionary","DateAxisBreak","registry","$time","$type","$iter","$math","$array","$object","$utils","OrderedListTemplate","DateAxisDataItem","_super","_this","call","className","applyTheme","values","date","endDate","Object","defineProperty","prototype","get","dates","set","setDate","value","getTime","enumerable","configurable","endValue","DateAxis","_gapBreaks","gridIntervals","groupIntervals","dateFormats","periodChangeDateFormats","_baseIntervalReal","timeUnit","count","_prevSeriesTime","_minDifference","_firstWeekDay","groupMin","groupMax","_intervalMax","_intervalMin","setPropertyValue","snapTooltip","tooltipPosition","groupCount","events","on","getDFFormatter","pushAll","axisFieldName","fillRule","dataItem","axis","component","gridInterval","_gridInterval","gridDuration","getDuration","Math","round","min","axisFill","__disabled","applyInternalDefaults","hasKey","setKey","language","translate","createDataItem","createAxisBreak","validateDataItems","start","end","baseDuration","periodCount","max","getFirstWeekDay","mainBaseDuration","mainBaseInterval","maxZoomFactor","_deltaMinMax","newPeriodCount","zoom","handleSelectionExtremesChange","getIntervalMax","interval","getIntervalMin","calculateZoom","difference","adjustDifference","_minZoomed","_maxZoomed","dataSetChanged","groupData","hasValue","selectionMin","selectionMax","diff","modifiedDifference","startLocation","endLocation","groupInterval","chooseInterval","_groupInterval","newId","_currentDataSetId","dispatch","series","each","baseAxis","setDataSet","_gridCount","baseInterval","_nextGridUnit","getNextUnit","_intervalDuration","_gridDate","Date","minZoomed","_df","utc","timezoneMinutes","timezone","iterator","field_1","getAxisField","undefined","minZoomedStr","toString","startDataItem","dataItemsByAxis","getKey","uid","currentDataSetId","startIndex","findFirst","index","dataItems","findClosestIndex","x","maxZoomed","add","maxZoomedStr","endDataItem","endIndex","length","outOfRange","dataRangeInvalid","validateDataRange","time","key","previousDataItem","getIndex","previousDate","validateData","isNumber","minDifference","Number","MAX_VALUE","seriesDataChangeUpdate","postProcessSeriesDataItems","seriesGroupUpdate","addEmptyUnitsBreaks","JSON","stringify","_baseInterval","mainDataSet","postProcessSeriesDataItem","groupSeriesData","dataGrouped","bulletsContainer","removeChildren","intervals_1","mainIntervalDuration_1","intervalDuration","push","_dataSets","dispose","clear","axisLetter","dataSetId","dataSet","template","clone","dataSets","previousTime","NEGATIVE_INFINITY","i","newDataItem","dataFields","dfkey","df","dfk","indexOf","roundedDate","getDate","firstDayOfWeek","currentTime","_adapterO","vkey","apply","dataField","workingValue","create","dataContext","setWorkingLocation","locations","dateX","openDateX","dateY","openDateY","_index","dvalues","open","close","low","high","sum","average","propertyFields","fieldValue","f","properties","hasProperties","setProperty","groupDataItems","groupFieldName","groupFields","copyProperties","dateFormatter","intervalID","startDate","startTime","setCalculatedValue","skipEmptyPeriods","_axisBreaks","axisBreak","_loop_1","this_1","startTimeStr","hasData","contains","axisBreaks","fixAxisBreaks","breakGridCount","ceil","endPosition","startPosition","adjustedEndValue","adjustedStartValue","gridDate","getGridDate","intervalCount","realIntervalCount","prevTimestamp","newDate","copy","timestamp","isInBreak","durationBreaksRemoved","countBreaksRemoved","getBreaklessDate","validateAxisElements","prevGridDate","dataItemsIterator_1","_dataItemsIterator","resetIterators","_loop_2","this_2","format","markUnitChange","checkChange","text","find","appendDataItem","validateDataElement","renderer_1","renderer","breakSize","timeUnit_1","intervalCount_1","getDistance","startPoint","endPoint","minGridDistance","timestamp_1","prevGridDate_1","_loop_3","text_1","moveValue","adjustedMax","itemIndex","_axisItemCount","endTimestamp","position","valueToPosition","fillEndPosition","isRange","tick","disabled","updateTickElement","grid","updateGridElement","fill","updateFillElement","mask","bullet","updateBullet","label","location_1","location","updateLabelElement","adjustMinMax","step","fixMin","endTime","fixMax","duration","gridCount","intervals","lastIndex","formatLabel","dateToPosition","anyToPosition","dateToPoint","point","positionToPoint","angle","positionToAngle","y","anyToPoint","valueToPoint","positionToDate","positionToValue","getPositionX","stackKey","range","getTimeByLocation","baseValue","fitToRange","getPositionY","stack","getValue","getAngle","workingLocations","processSeriesDataItem","timezoneOffset","setTime","getTimezoneOffset","setValue","setTimezone","openDate","prevSeriesTime","openTime","abs","differece","updateAxisBySeries","_mainBaseInterval","timeInterval","invalidate","getPropertyValue","breakTemplate","startLine","endLine","fillShape","invalidateSeries","invalidateData","getTooltipText","tooltipDate","tooltipDateFormat","dateFormat","getPositionLabel","roundPosition","axisLocation","getCellStartPosition","getCellEndPosition","getSeriesDataItem","findNearest","deltaValue","nextDate","key_1","Infinity","getCurrentLabelFormat","initRenderer","ticks","labels","baseGrid","animateMinMax","animation","animate","property","from","_minAdjusted","to","_maxAdjusted","rangeChangeDuration","rangeChangeEasing","handleExtremesChange","id","_finalMin","_finalMax","zoomToDates","skipRangeEvent","instantly","adjust","parse","zoomToValues","startValue","isEnd","isStart","groupInterval_1","min_1","max_1","POSITIVE_INFINITY","seriesMin","seriesMax","ds","mindi","maxdi","xAxis","yAxis","asIs","field","copyFrom","source","showTooltipAtPosition","local","toAxisPosition","actualDate","actualTime_1","closestDate_1","closestTime_1","tooltipLocation","chart","cursor","snapToSeries","showTooltipAtDataItem","_seriesPoints","tooltipText","tooltipHTML","hideTooltip","inited","makeGap","previous","connect","autoGapCount","prevDate","prevTime","_saveMinMax","registeredClasses"],"sources":["D:/alodelivery test/node_modules/@amcharts/amcharts4/.internal/charts/axes/DateAxis.js"],"sourcesContent":["/**\r\n * DateAxis module\r\n */\r\nimport { __assign, __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { ValueAxis, ValueAxisDataItem } from \"./ValueAxis\";\r\nimport { List } from \"../../core/utils/List\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { DateAxisBreak } from \"./DateAxisBreak\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $time from \"../../core/utils/Time\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport * as $object from \"../../core/utils/Object\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport { OrderedListTemplate } from \"../../core/utils/SortedList\";\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Defines data item for [[DateAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nvar DateAxisDataItem = /** @class */ (function (_super) {\r\n    __extends(DateAxisDataItem, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function DateAxisDataItem() {\r\n        var _this = _super.call(this) || this;\r\n        _this.className = \"DateAxisDataItem\";\r\n        _this.applyTheme();\r\n        _this.values.date = {};\r\n        _this.values.endDate = {};\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DateAxisDataItem.prototype, \"date\", {\r\n        /**\r\n         * @return Date\r\n         */\r\n        get: function () {\r\n            return this.dates[\"date\"];\r\n        },\r\n        /**\r\n         * Date position of the data item.\r\n         *\r\n         * @param date  Date\r\n         */\r\n        set: function (date) {\r\n            this.setDate(\"date\", date);\r\n            this.value = date.getTime();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxisDataItem.prototype, \"endDate\", {\r\n        /**\r\n         * @return End date\r\n         */\r\n        get: function () {\r\n            return this.dates[\"endDate\"];\r\n        },\r\n        /**\r\n         * End date for data item.\r\n         *\r\n         * @param date End date\r\n         */\r\n        set: function (date) {\r\n            this.setDate(\"endDate\", date);\r\n            this.endValue = date.getTime();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return DateAxisDataItem;\r\n}(ValueAxisDataItem));\r\nexport { DateAxisDataItem };\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Used to create a date/time-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Time\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Time\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"DateAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Time\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link IDateAxisEvents} for a list of available Events\r\n * @see {@link IDateAxisAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/} got `DateAxis` documention\r\n * @important\r\n */\r\nvar DateAxis = /** @class */ (function (_super) {\r\n    __extends(DateAxis, _super);\r\n    /**\r\n     * Constructor\r\n     */\r\n    function DateAxis() {\r\n        var _this = \r\n        // Init\r\n        _super.call(this) || this;\r\n        _this._gapBreaks = false;\r\n        /**\r\n         * A list of date/time intervals for Date axis.\r\n         *\r\n         * This define various granularities available for the axis. For example\r\n         * if you have an axis spanning an hour, and space for 6 grid lines / labels\r\n         * the axis will choose the granularity of 10 minutes, displaying a label\r\n         * every 10 minutes.\r\n         *\r\n         * Default intervals:\r\n         *\r\n         * ```JSON\r\n         * [\r\n         *  { timeUnit: \"millisecond\", count: 1 },\r\n         *  { timeUnit: \"millisecond\", count: 5 },\r\n         *  { timeUnit: \"millisecond\", count: 10 },\r\n         *  { timeUnit: \"millisecond\", count: 50 },\r\n         *  { timeUnit: \"millisecond\", count: 100 },\r\n         *  { timeUnit: \"millisecond\", count: 500 },\r\n         *  { timeUnit: \"second\", count: 1 },\r\n         *  { timeUnit: \"second\", count: 5 },\r\n         *  { timeUnit: \"second\", count: 10 },\r\n         *  { timeUnit: \"second\", count: 30 },\r\n         *  { timeUnit: \"minute\", count: 1 },\r\n         *  { timeUnit: \"minute\", count: 5 },\r\n         *  { timeUnit: \"minute\", count: 10 },\r\n         *  { timeUnit: \"minute\", count: 30 },\r\n         *  { timeUnit: \"hour\", count: 1 },\r\n         *  { timeUnit: \"hour\", count: 3 },\r\n         *  { timeUnit: \"hour\", count: 6 },\r\n         *  { timeUnit: \"hour\", count: 12 },\r\n         *  { timeUnit: \"day\", count: 1 },\r\n         *  { timeUnit: \"day\", count: 2 },\r\n         *  { timeUnit: \"day\", count: 3 },\r\n         *  { timeUnit: \"day\", count: 4 },\r\n         *  { timeUnit: \"day\", count: 5 },\r\n         *  { timeUnit: \"week\", count: 1 },\r\n         *  { timeUnit: \"month\", count: 1 },\r\n         *  { timeUnit: \"month\", count: 2 },\r\n         *  { timeUnit: \"month\", count: 3 },\r\n         *  { timeUnit: \"month\", count: 6 },\r\n         *  { timeUnit: \"year\", count: 1 },\r\n         *  { timeUnit: \"year\", count: 2 },\r\n         *  { timeUnit: \"year\", count: 5 },\r\n         *  { timeUnit: \"year\", count: 10 },\r\n         *  { timeUnit: \"year\", count: 50 },\r\n         *  { timeUnit: \"year\", count: 100 }\r\n         * ]\r\n         * ```\r\n         */\r\n        _this.gridIntervals = new List();\r\n        /**\r\n         * If data aggregation is enabled by setting Axis' `groupData = true`, the\r\n         * chart will try to aggregate data items into grouped data items.\r\n         *\r\n         * If there are more data items in selected period than `groupCount`, it will\r\n         * group data items into bigger period.\r\n         *\r\n         * For example seconds might be grouped into 10-second aggregate data items.\r\n         *\r\n         * This setting indicates what group intervals can the chart group to.\r\n         *\r\n         * Default intervals:\r\n         *\r\n         * ```JSON\r\n         * [\r\n         *   { timeUnit: \"millisecond\", count: 1},\r\n         *   { timeUnit: \"millisecond\", count: 10 },\r\n         *   { timeUnit: \"millisecond\", count: 100 },\r\n         *   { timeUnit: \"second\", count: 1 },\r\n         *   { timeUnit: \"second\", count: 10 },\r\n         *   { timeUnit: \"minute\", count: 1 },\r\n         *   { timeUnit: \"minute\", count: 10 },\r\n         *   { timeUnit: \"hour\", count: 1 },\r\n         *   { timeUnit: \"day\", count: 1 },\r\n         *   { timeUnit: \"week\", count: 1 },\r\n         *   { timeUnit: \"month\", count: 1 },\r\n         *   { timeUnit: \"year\", count: 1 }\r\n         * ]\r\n         * ```\r\n         * `groupData = true` does not work in combination with `skipEmptyPeriods = true`.\r\n         *\r\n         * @since 4.7.0\r\n         * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n         */\r\n        _this.groupIntervals = new List();\r\n        /**\r\n         * A collection of date formats to use when formatting different time units\r\n         * on Date/time axis.\r\n         *\r\n         * Actual defaults will depend on the language locale set for the chart.\r\n         *\r\n         * To override format for a specific time unit, say days, you need to set\r\n         * the appropriate key to a format string. E.g.:\r\n         *\r\n         * ```TypeScript\r\n         * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n         * ```\r\n         * ```JavaScript\r\n         * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n         * ```\r\n         * ```JSON\r\n         * \"xAxes\": [{\r\n         *   \"type\": \"DateAxis\",\r\n         *   \"dateFormats\": {\r\n         *     \"day\": \"MMMM d, yyyy\"\r\n         *   }\r\n         * }]\r\n         * ```\r\n         *\r\n         * @see {@link DateFormatter}\r\n         */\r\n        _this.dateFormats = new Dictionary();\r\n        /**\r\n         * These formats are applied to labels that are first in a larger unit.\r\n         *\r\n         * For example, if we have a DateAxis with days on it, the first day of month\r\n         * indicates a break in month - a start of the bigger period.\r\n         *\r\n         * For those labels, `periodChangeDateFormats` are applied instead of\r\n         * `dateFormats`.\r\n         *\r\n         * This allows us implement convenient structures, like instead of:\r\n         *\r\n         * `Jan 1 - Jan 2 - Jan 3 - ...`\r\n         *\r\n         * We can have:\r\n         *\r\n         * `Jan - 1 - 2 - 3 - ...`\r\n         *\r\n         * This can be disabled by setting `markUnitChange = false`.\r\n         */\r\n        _this.periodChangeDateFormats = new Dictionary();\r\n        /**\r\n         * Actual interval (granularity) derived from the actual data.\r\n         */\r\n        _this._baseIntervalReal = { timeUnit: \"day\", count: 1 };\r\n        /**\r\n         */\r\n        _this._prevSeriesTime = {};\r\n        /**\r\n         * [_minDifference description]\r\n         *\r\n         * @todo Description\r\n         */\r\n        _this._minDifference = {};\r\n        /**\r\n         * @ignore\r\n         */\r\n        _this._firstWeekDay = 1;\r\n        /**\r\n         * A collection of start timestamps to use as axis' min timestamp for\r\n         * particular data item item periods.\r\n         *\r\n         * @since 4.7.0\r\n         * @readonly\r\n         */\r\n        _this.groupMin = {};\r\n        /**\r\n         * A collection of start timestamps to use as axis' max timestamp for\r\n         * particular data item item periods.\r\n         *\r\n         * @since 4.7.0\r\n         * @readonly\r\n         */\r\n        _this.groupMax = {};\r\n        _this._intervalMax = {};\r\n        _this._intervalMin = {};\r\n        _this.className = \"DateAxis\";\r\n        _this.setPropertyValue(\"markUnitChange\", true);\r\n        _this.snapTooltip = true;\r\n        _this.tooltipPosition = \"pointer\";\r\n        _this.setPropertyValue(\"groupData\", false);\r\n        _this.groupCount = 200;\r\n        _this.events.on(\"parentset\", _this.getDFFormatter, _this, false);\r\n        // Translatable defaults are applied in `applyInternalDefaults()`\r\n        // ...\r\n        // Define default intervals\r\n        _this.gridIntervals.pushAll([\r\n            { timeUnit: \"millisecond\", count: 1 },\r\n            { timeUnit: \"millisecond\", count: 5 },\r\n            { timeUnit: \"millisecond\", count: 10 },\r\n            { timeUnit: \"millisecond\", count: 50 },\r\n            { timeUnit: \"millisecond\", count: 100 },\r\n            { timeUnit: \"millisecond\", count: 500 },\r\n            { timeUnit: \"second\", count: 1 },\r\n            { timeUnit: \"second\", count: 5 },\r\n            { timeUnit: \"second\", count: 10 },\r\n            { timeUnit: \"second\", count: 30 },\r\n            { timeUnit: \"minute\", count: 1 },\r\n            { timeUnit: \"minute\", count: 5 },\r\n            { timeUnit: \"minute\", count: 10 },\r\n            { timeUnit: \"minute\", count: 15 },\r\n            { timeUnit: \"minute\", count: 30 },\r\n            { timeUnit: \"hour\", count: 1 },\r\n            { timeUnit: \"hour\", count: 3 },\r\n            { timeUnit: \"hour\", count: 6 },\r\n            { timeUnit: \"hour\", count: 12 },\r\n            { timeUnit: \"day\", count: 1 },\r\n            { timeUnit: \"day\", count: 2 },\r\n            { timeUnit: \"day\", count: 3 },\r\n            { timeUnit: \"day\", count: 4 },\r\n            { timeUnit: \"day\", count: 5 },\r\n            { timeUnit: \"week\", count: 1 },\r\n            { timeUnit: \"month\", count: 1 },\r\n            { timeUnit: \"month\", count: 2 },\r\n            { timeUnit: \"month\", count: 3 },\r\n            { timeUnit: \"month\", count: 6 },\r\n            { timeUnit: \"year\", count: 1 },\r\n            { timeUnit: \"year\", count: 2 },\r\n            { timeUnit: \"year\", count: 5 },\r\n            { timeUnit: \"year\", count: 10 },\r\n            { timeUnit: \"year\", count: 50 },\r\n            { timeUnit: \"year\", count: 100 },\r\n            { timeUnit: \"year\", count: 200 },\r\n            { timeUnit: \"year\", count: 500 },\r\n            { timeUnit: \"year\", count: 1000 },\r\n            { timeUnit: \"year\", count: 2000 },\r\n            { timeUnit: \"year\", count: 5000 },\r\n            { timeUnit: \"year\", count: 10000 },\r\n            { timeUnit: \"year\", count: 100000 }\r\n        ]);\r\n        _this.groupIntervals.pushAll([\r\n            { timeUnit: \"millisecond\", count: 1 },\r\n            { timeUnit: \"millisecond\", count: 10 },\r\n            { timeUnit: \"millisecond\", count: 100 },\r\n            { timeUnit: \"second\", count: 1 },\r\n            { timeUnit: \"second\", count: 10 },\r\n            { timeUnit: \"minute\", count: 1 },\r\n            { timeUnit: \"minute\", count: 10 },\r\n            { timeUnit: \"hour\", count: 1 },\r\n            { timeUnit: \"day\", count: 1 },\r\n            { timeUnit: \"week\", count: 1 },\r\n            { timeUnit: \"month\", count: 1 },\r\n            { timeUnit: \"year\", count: 1 }\r\n        ]);\r\n        // Set field name\r\n        _this.axisFieldName = \"date\";\r\n        // Apply theme\r\n        _this.applyTheme();\r\n        return _this;\r\n    }\r\n    /**\r\n     * A function which applies fills to axis cells.\r\n     *\r\n     * Default function fills every second fill. You can set this to a function\r\n     * that follows some other logic.\r\n     *\r\n     * Function should accept a [[DateAxisDataItem]] and modify its `axisFill`\r\n     * property accordingly.\r\n     */\r\n    DateAxis.prototype.fillRule = function (dataItem) {\r\n        var value = dataItem.value;\r\n        var axis = dataItem.component;\r\n        var gridInterval = axis._gridInterval;\r\n        var gridDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n        if (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {\r\n            dataItem.axisFill.__disabled = true;\r\n        }\r\n        else {\r\n            dataItem.axisFill.__disabled = false;\r\n        }\r\n    };\r\n    /**\r\n     * Sets defaults that instantiate some objects that rely on parent, so they\r\n     * cannot be set in constructor.\r\n     */\r\n    DateAxis.prototype.applyInternalDefaults = function () {\r\n        _super.prototype.applyInternalDefaults.call(this);\r\n        // Set default date formats\r\n        if (!this.dateFormats.hasKey(\"millisecond\")) {\r\n            this.dateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\r\n        }\r\n        if (!this.dateFormats.hasKey(\"second\")) {\r\n            this.dateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\r\n        }\r\n        if (!this.dateFormats.hasKey(\"minute\")) {\r\n            this.dateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\r\n        }\r\n        if (!this.dateFormats.hasKey(\"hour\")) {\r\n            this.dateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\r\n        }\r\n        if (!this.dateFormats.hasKey(\"day\")) {\r\n            this.dateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\r\n        }\r\n        if (!this.dateFormats.hasKey(\"week\")) {\r\n            this.dateFormats.setKey(\"week\", this.language.translate(\"_date_day\")); // not a mistake\r\n        }\r\n        if (!this.dateFormats.hasKey(\"month\")) {\r\n            this.dateFormats.setKey(\"month\", this.language.translate(\"_date_month\"));\r\n        }\r\n        if (!this.dateFormats.hasKey(\"year\")) {\r\n            this.dateFormats.setKey(\"year\", this.language.translate(\"_date_year\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"millisecond\")) {\r\n            this.periodChangeDateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"second\")) {\r\n            this.periodChangeDateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"minute\")) {\r\n            this.periodChangeDateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"hour\")) {\r\n            this.periodChangeDateFormats.setKey(\"hour\", this.language.translate(\"_date_day\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"day\")) {\r\n            this.periodChangeDateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"week\")) {\r\n            this.periodChangeDateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\r\n        }\r\n        if (!this.periodChangeDateFormats.hasKey(\"month\")) {\r\n            this.periodChangeDateFormats.setKey(\"month\", this.language.translate(\"_date_month\") + \" \" + this.language.translate(\"_date_year\"));\r\n        }\r\n    };\r\n    /**\r\n     * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n     *\r\n     * @see {@link DataItem}\r\n     * @return Data Item\r\n     */\r\n    DateAxis.prototype.createDataItem = function () {\r\n        return new DateAxisDataItem();\r\n    };\r\n    /**\r\n     * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n     *\r\n     * @return Axis break\r\n     */\r\n    DateAxis.prototype.createAxisBreak = function () {\r\n        return new DateAxisBreak();\r\n    };\r\n    /**\r\n     * Validates Axis' data items.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    DateAxis.prototype.validateDataItems = function () {\r\n        // allows to keep selection of the same size\r\n        var start = this.start;\r\n        var end = this.end;\r\n        var baseDuration = this.baseDuration;\r\n        var periodCount = (this.max - this.min) / baseDuration;\r\n        this._firstWeekDay = this.getFirstWeekDay();\r\n        this.getDFFormatter();\r\n        _super.prototype.validateDataItems.call(this);\r\n        var mainBaseDuration = $time.getDuration(this.mainBaseInterval.timeUnit, this.mainBaseInterval.count);\r\n        this.maxZoomFactor = Math.max(1, (this.max - this.min) / mainBaseDuration);\r\n        this._deltaMinMax = this.baseDuration / 2;\r\n        // allows to keep selection of the same size\r\n        var newPeriodCount = (this.max - this.min) / baseDuration;\r\n        start = start + (end - start) * (1 - periodCount / newPeriodCount);\r\n        this.zoom({ start: start, end: end }, false, true); // added instantlyto solve zoomout problem when we have axes gaps. @todo: check how this affects maxZoomFactor\r\n    };\r\n    /**\r\n     * Handles process after zoom.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Does nothing?\r\n     */\r\n    DateAxis.prototype.handleSelectionExtremesChange = function () {\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.getIntervalMax = function (interval) {\r\n        return this._intervalMax[interval.timeUnit + interval.count];\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.getIntervalMin = function (interval) {\r\n        return this._intervalMin[interval.timeUnit + interval.count];\r\n    };\r\n    /**\r\n     * Calculates all positions, related to axis as per current zoom.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    DateAxis.prototype.calculateZoom = function () {\r\n        var _this = this;\r\n        _super.prototype.calculateZoom.call(this);\r\n        var difference = this.adjustDifference(this._minZoomed, this._maxZoomed);\r\n        var dataSetChanged = false;\r\n        // if data has to be grouped, choose interval and set dataset\r\n        if (this.groupData && $type.hasValue(difference)) {\r\n            var mainBaseInterval = this.mainBaseInterval;\r\n            var min = this.getIntervalMin(mainBaseInterval);\r\n            var max = this.getIntervalMax(mainBaseInterval);\r\n            var selectionMin = min + (max - min) * this.start;\r\n            var selectionMax = min + (max - min) * this.end;\r\n            var diff = this.adjustDifference(selectionMin, selectionMax);\r\n            var modifiedDifference = diff + (this.startLocation + (1 - this.endLocation)) * this.baseDuration;\r\n            var groupInterval = void 0;\r\n            if (this.groupInterval) {\r\n                groupInterval = __assign({}, this.groupInterval);\r\n            }\r\n            else {\r\n                groupInterval = this.chooseInterval(0, modifiedDifference, this.groupCount, this.groupIntervals);\r\n                if ($time.getDuration(groupInterval.timeUnit, groupInterval.count) < $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count)) {\r\n                    groupInterval = __assign({}, mainBaseInterval);\r\n                }\r\n            }\r\n            this._groupInterval = groupInterval;\r\n            var newId = groupInterval.timeUnit + groupInterval.count;\r\n            if (this._currentDataSetId != newId) {\r\n                this._currentDataSetId = newId;\r\n                this.dispatch(\"groupperiodchanged\");\r\n            }\r\n            this.series.each(function (series) {\r\n                if (series.baseAxis == _this) {\r\n                    if (series.setDataSet(_this._currentDataSetId)) {\r\n                        dataSetChanged = true;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        var gridInterval = this.chooseInterval(0, difference, this._gridCount);\r\n        if ($time.getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {\r\n            gridInterval = __assign({}, this.baseInterval);\r\n        }\r\n        this._gridInterval = gridInterval;\r\n        this._nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\r\n        // the following is needed to avoid grid flickering while scrolling\r\n        this._intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n        this._gridDate = $time.round(new Date(this.minZoomed - $time.getDuration(gridInterval.timeUnit, gridInterval.count)), gridInterval.timeUnit, gridInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);\r\n        // tell series start/end\r\n        $iter.each(this.series.iterator(), function (series) {\r\n            if (series.baseAxis == _this) {\r\n                var field_1 = series.getAxisField(_this);\r\n                var minZoomed = $time.round(new Date(_this._minZoomed + _this.baseDuration * 0.05), _this.baseInterval.timeUnit, _this.baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\r\n                var minZoomedStr = minZoomed.toString();\r\n                var startDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(minZoomedStr + series.currentDataSetId);\r\n                var startIndex = 0;\r\n                if (_this.start != 0) {\r\n                    if (startDataItem) {\r\n                        startDataItem = _this.findFirst(startDataItem, minZoomed, field_1);\r\n                        startIndex = startDataItem.index;\r\n                    }\r\n                    else {\r\n                        startIndex = series.dataItems.findClosestIndex(_this._minZoomed, function (x) { return x[field_1]; }, \"left\");\r\n                    }\r\n                }\r\n                // 1 millisecond is removed so that if only first item is selected, it would not count in the second.\r\n                var baseInterval = _this.baseInterval;\r\n                var maxZoomed = $time.add($time.round(new Date(_this._maxZoomed), baseInterval.timeUnit, baseInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone), baseInterval.timeUnit, baseInterval.count, _this._df.utc).getTime();\r\n                var maxZoomedStr = maxZoomed.toString();\r\n                var endDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(maxZoomedStr + series.currentDataSetId);\r\n                var endIndex = series.dataItems.length;\r\n                if (_this.end != 1) {\r\n                    if (endDataItem) {\r\n                        endIndex = endDataItem.index;\r\n                    }\r\n                    else {\r\n                        maxZoomed -= 1;\r\n                        endIndex = series.dataItems.findClosestIndex(maxZoomed, function (x) { return x[field_1]; }, \"right\");\r\n                        // not good - if end is in the gap, indexes go like 5,4,3,4,2,1\r\n                        //if (endIndex < series.dataItems.length) {\r\n                        endIndex++;\r\n                        //}\r\n                    }\r\n                }\r\n                if (series.max(_this) < minZoomed) {\r\n                    series.startIndex = series.dataItems.length;\r\n                    series.endIndex = series.dataItems.length;\r\n                    series.outOfRange = true;\r\n                }\r\n                else if (series.min(_this) > maxZoomed) {\r\n                    series.startIndex = 0;\r\n                    series.endIndex = 0;\r\n                    series.outOfRange = true;\r\n                }\r\n                else {\r\n                    series.outOfRange = false;\r\n                    series.startIndex = startIndex;\r\n                    series.endIndex = endIndex;\r\n                }\r\n                //\tconsole.log(series.name, startIndex, endIndex);\r\n                if (!dataSetChanged && series.dataRangeInvalid) {\r\n                    series.validateDataRange();\r\n                }\r\n            }\r\n        });\r\n    };\r\n    DateAxis.prototype.findFirst = function (dataItem, time, key) {\r\n        var index = dataItem.index;\r\n        if (index > 0) {\r\n            var series = dataItem.component;\r\n            var previousDataItem = series.dataItems.getIndex(index - 1);\r\n            var previousDate = previousDataItem[key];\r\n            if (!previousDate || previousDate.getTime() < time) {\r\n                return dataItem;\r\n            }\r\n            else {\r\n                return this.findFirst(previousDataItem, time, key);\r\n            }\r\n        }\r\n        else {\r\n            return dataItem;\r\n        }\r\n    };\r\n    /**\r\n     * (Re)validates data.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    DateAxis.prototype.validateData = function () {\r\n        _super.prototype.validateData.call(this);\r\n        if (!$type.isNumber(this.baseInterval.count)) {\r\n            this.baseInterval.count = 1;\r\n        }\r\n    };\r\n    Object.defineProperty(DateAxis.prototype, \"minDifference\", {\r\n        /**\r\n         * @ignore\r\n         */\r\n        get: function () {\r\n            var _this = this;\r\n            var minDifference = Number.MAX_VALUE;\r\n            this.series.each(function (series) {\r\n                if (minDifference > _this._minDifference[series.uid]) {\r\n                    minDifference = _this._minDifference[series.uid];\r\n                }\r\n            });\r\n            if (minDifference == Number.MAX_VALUE || minDifference == 0) {\r\n                minDifference = $time.getDuration(\"day\");\r\n            }\r\n            return minDifference;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * [dataChangeUpdate description]\r\n     *\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\r\n    DateAxis.prototype.seriesDataChangeUpdate = function (series) {\r\n        this._minDifference[series.uid] = Number.MAX_VALUE;\r\n    };\r\n    /**\r\n     * [postProcessSeriesDataItems description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\r\n    DateAxis.prototype.postProcessSeriesDataItems = function (series) {\r\n        var _this = this;\r\n        this._firstWeekDay = this.getFirstWeekDay();\r\n        if (series) {\r\n            this.seriesGroupUpdate(series);\r\n        }\r\n        else {\r\n            this.series.each(function (series) {\r\n                _this.seriesGroupUpdate(series);\r\n            });\r\n        }\r\n        this.addEmptyUnitsBreaks();\r\n    };\r\n    DateAxis.prototype.seriesGroupUpdate = function (series) {\r\n        var _this = this;\r\n        if (JSON.stringify(series._baseInterval[this.uid]) != JSON.stringify(this.mainBaseInterval)) {\r\n            series._baseInterval[this.uid] = this.mainBaseInterval;\r\n            series.mainDataSet.each(function (dataItem) {\r\n                _this.postProcessSeriesDataItem(dataItem);\r\n            });\r\n            if (this.groupData) {\r\n                this.groupSeriesData(series);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Calculates series group data.\r\n     *\r\n     * @param  series  Series\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.groupSeriesData = function (series) {\r\n        var _this = this;\r\n        if (series.baseAxis == this && series.dataItems.length > 0 && !series.dataGrouped) {\r\n            series.bulletsContainer.removeChildren();\r\n            // make array of intervals which will be used;\r\n            var intervals_1 = [];\r\n            var mainBaseInterval = this.mainBaseInterval;\r\n            var mainIntervalDuration_1 = $time.getDuration(mainBaseInterval.timeUnit, mainBaseInterval.count);\r\n            this.groupIntervals.each(function (interval) {\r\n                var intervalDuration = $time.getDuration(interval.timeUnit, interval.count);\r\n                if ((intervalDuration > mainIntervalDuration_1 && intervalDuration < (_this.max - _this.min)) || _this.groupInterval) {\r\n                    intervals_1.push(interval);\r\n                }\r\n            });\r\n            if (series._dataSets) {\r\n                series._dataSets.each(function (key, dataItems) {\r\n                    dataItems.each(function (dataItem) {\r\n                        dataItem.dispose();\r\n                    });\r\n                    dataItems.clear();\r\n                });\r\n                series._dataSets.clear();\r\n            }\r\n            series.dataGrouped = true;\r\n            $array.each(intervals_1, function (interval) {\r\n                //let mainBaseInterval = this._mainBaseInterval;\r\n                var key = \"date\" + _this.axisLetter;\r\n                // create data set\r\n                var dataSetId = interval.timeUnit + interval.count;\r\n                // todo: check where this clone goes\r\n                var dataSet = new OrderedListTemplate(series.mainDataSet.template.clone());\r\n                series.dataSets.setKey(dataSetId, dataSet);\r\n                var dataItems = series.mainDataSet;\r\n                var previousTime = Number.NEGATIVE_INFINITY;\r\n                var i = 0;\r\n                var newDataItem;\r\n                var dataFields = [];\r\n                $object.each(series.dataFields, function (dfkey, df) {\r\n                    var dfk = dfkey;\r\n                    if (dfk != key && dfk.indexOf(\"Show\") == -1) {\r\n                        dataFields.push(dfk);\r\n                    }\r\n                });\r\n                var roundedDate;\r\n                dataItems.each(function (dataItem) {\r\n                    var date = dataItem.getDate(key);\r\n                    if (date) {\r\n                        var time = date.getTime();\r\n                        roundedDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\r\n                        var currentTime = roundedDate.getTime();\r\n                        // changed period\t\t\t\t\t\t\t\t\r\n                        if (previousTime < currentTime) {\r\n                            if (newDataItem && series._adapterO) {\r\n                                $array.each(dataFields, function (vkey) {\r\n                                    newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\r\n                                        dataItem: newDataItem,\r\n                                        interval: interval,\r\n                                        dataField: vkey,\r\n                                        date: roundedDate,\r\n                                        value: newDataItem.values[vkey].value\r\n                                    }).value;\r\n                                    newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\r\n                                });\r\n                            }\r\n                            newDataItem = dataSet.create();\r\n                            newDataItem.dataContext = {};\r\n                            newDataItem.setWorkingLocation(\"dateX\", series.dataItems.template.locations.dateX, 0);\r\n                            newDataItem.setWorkingLocation(\"openDateX\", series.dataItems.template.locations.openDateX, 0);\r\n                            newDataItem.setWorkingLocation(\"dateY\", series.dataItems.template.locations.dateY, 0);\r\n                            newDataItem.setWorkingLocation(\"openDateY\", series.dataItems.template.locations.openDateY, 0);\r\n                            newDataItem.component = series;\r\n                            // other Dates?\r\n                            newDataItem.setDate(key, roundedDate);\r\n                            newDataItem._index = i;\r\n                            i++;\r\n                            $array.each(dataFields, function (vkey) {\r\n                                //let groupFieldName = vkey + \"Group\";\r\n                                var dvalues = dataItem.values[vkey];\r\n                                if (dvalues) {\r\n                                    var value = dvalues.value;\r\n                                    if (series._adapterO) {\r\n                                        value = series._adapterO.apply(\"groupValue\", {\r\n                                            dataItem: dataItem,\r\n                                            interval: interval,\r\n                                            dataField: vkey,\r\n                                            date: roundedDate,\r\n                                            value: value\r\n                                        }).value;\r\n                                    }\r\n                                    var values = newDataItem.values[vkey];\r\n                                    if ($type.isNumber(value)) {\r\n                                        values.value = value;\r\n                                        values.workingValue = value;\r\n                                        values.open = value;\r\n                                        values.close = value;\r\n                                        values.low = value;\r\n                                        values.high = value;\r\n                                        values.sum = value;\r\n                                        values.average = value;\r\n                                        values.count = 1;\r\n                                    }\r\n                                    else {\r\n                                        values.count = 0;\r\n                                    }\r\n                                }\r\n                            });\r\n                            _this.postProcessSeriesDataItem(newDataItem, interval);\r\n                            $object.each(series.propertyFields, function (key, fieldValue) {\r\n                                var f = key;\r\n                                var value = dataItem.properties[key];\r\n                                if ($type.hasValue(value)) {\r\n                                    newDataItem.hasProperties = true;\r\n                                    newDataItem.setProperty(f, value);\r\n                                }\r\n                            });\r\n                            newDataItem.groupDataItems = [dataItem];\r\n                            previousTime = currentTime;\r\n                        }\r\n                        else {\r\n                            if (newDataItem) {\r\n                                $array.each(dataFields, function (vkey) {\r\n                                    var groupFieldName = series.groupFields[vkey];\r\n                                    var dvalues = dataItem.values[vkey];\r\n                                    if (dvalues) {\r\n                                        var value = dvalues.value;\r\n                                        if (series._adapterO) {\r\n                                            value = series._adapterO.apply(\"groupValue\", {\r\n                                                dataItem: dataItem,\r\n                                                interval: interval,\r\n                                                dataField: vkey,\r\n                                                date: roundedDate,\r\n                                                value: value\r\n                                            }).value;\r\n                                        }\r\n                                        if ($type.isNumber(value)) {\r\n                                            var values = newDataItem.values[vkey];\r\n                                            if (!$type.isNumber(values.open)) {\r\n                                                values.open = value;\r\n                                            }\r\n                                            values.close = value;\r\n                                            if (values.low > value || !$type.isNumber(values.low)) {\r\n                                                values.low = value;\r\n                                            }\r\n                                            if (values.high < value || !$type.isNumber(values.high)) {\r\n                                                values.high = value;\r\n                                            }\r\n                                            if ($type.isNumber(values.sum)) {\r\n                                                values.sum += value;\r\n                                            }\r\n                                            else {\r\n                                                values.sum = value;\r\n                                            }\r\n                                            values.count++;\r\n                                            values.average = values.sum / values.count;\r\n                                            if ($type.isNumber(values[groupFieldName])) {\r\n                                                values.value = values[groupFieldName];\r\n                                                values.workingValue = values.value;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                });\r\n                                $utils.copyProperties(dataItem.properties, newDataItem.properties);\r\n                                $object.each(series.propertyFields, function (key, fieldValue) {\r\n                                    var f = key;\r\n                                    var value = dataItem.properties[key];\r\n                                    if ($type.hasValue(value)) {\r\n                                        newDataItem.hasProperties = true;\r\n                                        newDataItem.setProperty(f, value);\r\n                                    }\r\n                                });\r\n                                newDataItem.groupDataItems.push(dataItem);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (newDataItem) {\r\n                        $utils.copyProperties(dataItem.dataContext, newDataItem.dataContext);\r\n                    }\r\n                });\r\n                if (newDataItem && series._adapterO) {\r\n                    $array.each(dataFields, function (vkey) {\r\n                        newDataItem.values[vkey].value = series._adapterO.apply(\"groupDataItem\", {\r\n                            dataItem: newDataItem,\r\n                            interval: interval,\r\n                            dataField: vkey,\r\n                            date: roundedDate,\r\n                            value: newDataItem.values[vkey].value\r\n                        }).value;\r\n                        newDataItem.values[vkey].workingValue = newDataItem.values[vkey].value;\r\n                    });\r\n                }\r\n            });\r\n            this.calculateZoom();\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.getDFFormatter = function () {\r\n        this._df = this.dateFormatter;\r\n    };\r\n    /**\r\n     * [postProcessSeriesDataItem description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param dataItem Data item\r\n     */\r\n    DateAxis.prototype.postProcessSeriesDataItem = function (dataItem, interval) {\r\n        var _this = this;\r\n        // we need to do this for all series data items not only added recently, as baseInterval might change\r\n        var intervalID = \"\";\r\n        if (interval) {\r\n            intervalID = interval.timeUnit + interval.count;\r\n        }\r\n        else {\r\n            interval = this.mainBaseInterval;\r\n        }\r\n        var series = dataItem.component;\r\n        var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\r\n        $object.each(dataItem.dates, function (key) {\r\n            var date = dataItem.getDate(key);\r\n            var time = date.getTime();\r\n            var startDate = $time.round(new Date(time), interval.timeUnit, interval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\r\n            var startTime = startDate.getTime();\r\n            var endDate = $time.add(new Date(startTime), interval.timeUnit, interval.count, _this._df.utc);\r\n            dataItem.setCalculatedValue(key, startTime, \"open\");\r\n            dataItem.setCalculatedValue(key, endDate.getTime(), \"close\");\r\n            dataItemsByAxis.setKey(startTime + intervalID, dataItem);\r\n        });\r\n    };\r\n    /**\r\n     * Collapses empty stretches of date/time scale by creating [[AxisBreak]]\r\n     * elements for them.\r\n     *\r\n     * Can be used to automatically remove strethes without data, like weekends.\r\n     *\r\n     * No, need to call this manually. It will automatically be done if\r\n     * `skipEmptyPeriods = true`.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    DateAxis.prototype.addEmptyUnitsBreaks = function () {\r\n        var _this = this;\r\n        if (this.skipEmptyPeriods && $type.isNumber(this.min) && $type.isNumber(this.max)) {\r\n            var timeUnit = this.baseInterval.timeUnit;\r\n            var count = this.baseInterval.count;\r\n            if (this._axisBreaks) {\r\n                this._axisBreaks.clear(); // TODO: what about breaks added by user?\r\n            }\r\n            var date = $time.round(new Date(this.min), timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n            var axisBreak = void 0;\r\n            var _loop_1 = function () {\r\n                $time.add(date, timeUnit, count, this_1._df.utc);\r\n                var startTime = date.getTime();\r\n                var startTimeStr = startTime.toString();\r\n                var hasData = $iter.contains(this_1.series.iterator(), function (series) {\r\n                    return !!series.dataItemsByAxis.getKey(_this.uid).getKey(startTimeStr + series.currentDataSetId);\r\n                });\r\n                // open break if not yet opened\r\n                if (!hasData) {\r\n                    if (!axisBreak) {\r\n                        axisBreak = this_1.axisBreaks.create();\r\n                        axisBreak.startDate = new Date(startTime);\r\n                        this_1._gapBreaks = true;\r\n                    }\r\n                }\r\n                else {\r\n                    // close if already opened\r\n                    if (axisBreak) {\r\n                        // close at end time minus one millisecond\r\n                        axisBreak.endDate = new Date(startTime - 1);\r\n                        axisBreak = undefined;\r\n                    }\r\n                }\r\n            };\r\n            var this_1 = this;\r\n            while (date.getTime() < this.max - this.baseDuration) {\r\n                _loop_1();\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Updates positioning of Axis breaks after something changes.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    DateAxis.prototype.fixAxisBreaks = function () {\r\n        var _this = this;\r\n        _super.prototype.fixAxisBreaks.call(this);\r\n        var axisBreaks = this._axisBreaks;\r\n        if (axisBreaks) {\r\n            if (axisBreaks.length > 0) {\r\n                // process breaks\r\n                axisBreaks.each(function (axisBreak) {\r\n                    var breakGridCount = Math.ceil(_this._gridCount * (Math.min(_this.end, axisBreak.endPosition) - Math.max(_this.start, axisBreak.startPosition)) / (_this.end - _this.start));\r\n                    axisBreak.gridInterval = _this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);\r\n                    var gridDate = $time.round(new Date(axisBreak.adjustedStartValue), axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._firstWeekDay, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone);\r\n                    if (gridDate.getTime() > axisBreak.startDate.getTime()) {\r\n                        $time.add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this._df.utc);\r\n                    }\r\n                    axisBreak.gridDate = gridDate;\r\n                });\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.getFirstWeekDay = function () {\r\n        if (this._df) {\r\n            return this._df.firstDayOfWeek;\r\n        }\r\n        return 1;\r\n    };\r\n    /**\r\n     * [getGridDate description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param date           [description]\r\n     * @param intervalCount  [description]\r\n     * @return [description]\r\n     */\r\n    DateAxis.prototype.getGridDate = function (date, intervalCount) {\r\n        var timeUnit = this._gridInterval.timeUnit;\r\n        var realIntervalCount = this._gridInterval.count;\r\n        // round date\r\n        $time.round(date, timeUnit, 1, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n        var prevTimestamp = date.getTime();\r\n        var newDate = $time.copy(date);\r\n        // modify date by adding intervalcount\r\n        var timestamp = $time.add(newDate, timeUnit, intervalCount, this._df.utc).getTime();\r\n        // if it's axis break, get first rounded date which is not in a break\r\n        var axisBreak = this.isInBreak(timestamp);\r\n        if (axisBreak && axisBreak.endDate) {\r\n            newDate = new Date(axisBreak.endDate.getTime());\r\n            $time.round(newDate, timeUnit, realIntervalCount, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n            if (newDate.getTime() < axisBreak.endDate.getTime()) {\r\n                $time.add(newDate, timeUnit, realIntervalCount, this._df.utc);\r\n            }\r\n            timestamp = newDate.getTime();\r\n        }\r\n        // get duration between grid lines with break duration removed\r\n        var durationBreaksRemoved = this.adjustDifference(prevTimestamp, timestamp);\r\n        // calculate how many time units fit to this duration\r\n        var countBreaksRemoved = Math.round(durationBreaksRemoved / $time.getDuration(timeUnit));\r\n        // if less units fit, add one and repeat\r\n        if (countBreaksRemoved < realIntervalCount) {\r\n            return this.getGridDate(date, intervalCount + realIntervalCount);\r\n        }\r\n        return newDate;\r\n    };\r\n    /**\r\n     * [getBreaklessDate description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param axisBreak  [description]\r\n     * @param timeUnit   [description]\r\n     * @param count      [description]\r\n     * @return [description]\r\n     */\r\n    DateAxis.prototype.getBreaklessDate = function (axisBreak, timeUnit, count) {\r\n        var date = new Date(axisBreak.endValue);\r\n        $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n        $time.add(date, timeUnit, count, this._df.utc);\r\n        var timestamp = date.getTime();\r\n        axisBreak = this.isInBreak(timestamp);\r\n        if (axisBreak) {\r\n            return this.getBreaklessDate(axisBreak, timeUnit, count);\r\n        }\r\n        return date;\r\n    };\r\n    /**\r\n     * (Re)validates all Axis elements.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     */\r\n    DateAxis.prototype.validateAxisElements = function () {\r\n        var _this = this;\r\n        if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\r\n            this.calculateZoom();\r\n            // first regular items\r\n            var timestamp = this._gridDate.getTime();\r\n            var timeUnit = this._gridInterval.timeUnit;\r\n            var intervalCount = this._gridInterval.count;\r\n            var prevGridDate = $time.copy(this._gridDate);\r\n            var dataItemsIterator_1 = this._dataItemsIterator;\r\n            this.resetIterators();\r\n            var _loop_2 = function () {\r\n                var date = this_2.getGridDate($time.copy(prevGridDate), intervalCount);\r\n                timestamp = date.getTime();\r\n                var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\r\n                endDate = $time.add(endDate, timeUnit, intervalCount, this_2._df.utc);\r\n                var format = this_2.dateFormats.getKey(timeUnit);\r\n                if (this_2.markUnitChange && prevGridDate) {\r\n                    if ($time.checkChange(date, prevGridDate, this_2._nextGridUnit, this_2._df.utc)) {\r\n                        if (timeUnit !== \"year\") {\r\n                            format = this_2.periodChangeDateFormats.getKey(timeUnit);\r\n                        }\r\n                    }\r\n                }\r\n                var text = this_2._df.format(date, format);\r\n                var dataItem = dataItemsIterator_1.find(function (x) { return x.text === text; });\r\n                if (dataItem.__disabled) {\r\n                    dataItem.__disabled = false;\r\n                }\r\n                this_2.appendDataItem(dataItem);\r\n                dataItem.axisBreak = undefined;\r\n                dataItem.date = date;\r\n                dataItem.endDate = endDate;\r\n                dataItem.text = text;\r\n                this_2.validateDataElement(dataItem);\r\n                prevGridDate = date;\r\n            };\r\n            var this_2 = this;\r\n            while (timestamp <= this._maxZoomed) {\r\n                _loop_2();\r\n            }\r\n            // breaks later\r\n            var renderer_1 = this.renderer;\r\n            if (this._axisBreaks) {\r\n                $iter.each(this._axisBreaks.iterator(), function (axisBreak) {\r\n                    if (axisBreak.breakSize > 0) {\r\n                        var timeUnit_1 = axisBreak.gridInterval.timeUnit;\r\n                        var intervalCount_1 = axisBreak.gridInterval.count;\r\n                        // only add grid if gap is bigger then minGridDistance\r\n                        if ($math.getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer_1.minGridDistance * 4) {\r\n                            var timestamp_1 = axisBreak.gridDate.getTime();\r\n                            var prevGridDate_1;\r\n                            var count = 0;\r\n                            var _loop_3 = function () {\r\n                                var date = $time.copy(axisBreak.gridDate);\r\n                                timestamp_1 = $time.add(date, timeUnit_1, intervalCount_1 * count, _this._df.utc).getTime();\r\n                                count++;\r\n                                if (timestamp_1 > axisBreak.adjustedStartValue && timestamp_1 < axisBreak.adjustedEndValue) {\r\n                                    var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\r\n                                    endDate = $time.add(endDate, timeUnit_1, intervalCount_1, _this._df.utc);\r\n                                    var format = _this.dateFormats.getKey(timeUnit_1);\r\n                                    if (_this.markUnitChange && prevGridDate_1) {\r\n                                        if ($time.checkChange(date, prevGridDate_1, _this._nextGridUnit, _this._df.utc)) {\r\n                                            if (timeUnit_1 !== \"year\") {\r\n                                                format = _this.periodChangeDateFormats.getKey(timeUnit_1);\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    var text_1 = _this._df.format(date, format);\r\n                                    var dataItem = dataItemsIterator_1.find(function (x) { return x.text === text_1; });\r\n                                    if (dataItem.__disabled) {\r\n                                        dataItem.__disabled = false;\r\n                                    }\r\n                                    //this.processDataItem(dataItem);\r\n                                    _this.appendDataItem(dataItem);\r\n                                    dataItem.axisBreak = axisBreak;\r\n                                    axisBreak.dataItems.moveValue(dataItem);\r\n                                    dataItem.date = date;\r\n                                    dataItem.endDate = endDate;\r\n                                    dataItem.text = text_1;\r\n                                    prevGridDate_1 = date;\r\n                                    _this.validateDataElement(dataItem);\r\n                                }\r\n                            };\r\n                            while (timestamp_1 <= axisBreak.adjustedMax) {\r\n                                _loop_3();\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Validates Axis data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param dataItem Data item\r\n     */\r\n    DateAxis.prototype.validateDataElement = function (dataItem) {\r\n        dataItem.itemIndex = this._axisItemCount;\r\n        this._axisItemCount++;\r\n        if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\r\n            var renderer = this.renderer;\r\n            var timestamp = dataItem.value;\r\n            var endTimestamp = dataItem.endValue;\r\n            if (!$type.isNumber(endTimestamp)) {\r\n                endTimestamp = timestamp;\r\n            }\r\n            var position = this.valueToPosition(timestamp);\r\n            var endPosition = this.valueToPosition(endTimestamp);\r\n            var fillEndPosition = endPosition;\r\n            if (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {\r\n                endPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);\r\n            }\r\n            dataItem.position = position;\r\n            var tick = dataItem.tick;\r\n            if (tick && !tick.disabled) {\r\n                renderer.updateTickElement(tick, position, endPosition);\r\n            }\r\n            var grid = dataItem.grid;\r\n            if (grid && !grid.disabled) {\r\n                renderer.updateGridElement(grid, position, endPosition);\r\n            }\r\n            var fill = dataItem.axisFill;\r\n            if (fill && !fill.disabled) {\r\n                renderer.updateFillElement(fill, position, fillEndPosition);\r\n                if (!dataItem.isRange) {\r\n                    this.fillRule(dataItem);\r\n                }\r\n            }\r\n            var mask = dataItem.mask;\r\n            if (mask) {\r\n                renderer.updateFillElement(mask, position, endPosition);\r\n            }\r\n            if (dataItem.bullet) {\r\n                renderer.updateBullet(dataItem.bullet, position, endPosition);\r\n            }\r\n            var label = dataItem.label;\r\n            if (label && !label.disabled) {\r\n                var location_1 = label.location;\r\n                if (location_1 == 0) {\r\n                    if (this._gridInterval.count == 1 && this._gridInterval.timeUnit != \"week\" && !dataItem.isRange) {\r\n                        location_1 = 0.5;\r\n                    }\r\n                    else {\r\n                        location_1 = 0;\r\n                    }\r\n                }\r\n                renderer.updateLabelElement(label, position, endPosition, location_1);\r\n            }\r\n        }\r\n    };\r\n    Object.defineProperty(DateAxis.prototype, \"baseDuration\", {\r\n        /**\r\n         * A duration in milliseconds of the `baseInterval`.\r\n         *\r\n         * @return Duration (ms)\r\n         */\r\n        get: function () {\r\n            return $time.getDuration(this.baseInterval.timeUnit, this.baseInterval.count);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Adjusts min/max values.\r\n     *\r\n     * @ignore Exclude from docs.\r\n     * @todo Description (review)\r\n     * @param min  Min timestamp\r\n     * @param max  Max timestamp\r\n     * @return Adjusted min/max step\r\n     */\r\n    DateAxis.prototype.adjustMinMax = function (min, max) {\r\n        return { min: min, max: max, step: this.baseDuration };\r\n    };\r\n    /**\r\n     * Adjusts the minimum timestamp as per cell start location.\r\n     *\r\n     * @param value  Value\r\n     * @return Adjusted value\r\n     */\r\n    DateAxis.prototype.fixMin = function (value) {\r\n        // like this because months are not equal\r\n        var interval = this.baseInterval;\r\n        var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\r\n        var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\r\n        return startTime + (endTime - startTime) * this.startLocation;\r\n    };\r\n    /**\r\n     * Adjusts the maximum timestamp as per cell start location.\r\n     *\r\n     * @param value  Value\r\n     * @return Adjusted value\r\n     */\r\n    DateAxis.prototype.fixMax = function (value) {\r\n        // like this because months are not equal\r\n        var interval = this.baseInterval;\r\n        var startTime = $time.round(new Date(value), interval.timeUnit, interval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone).getTime();\r\n        var endTime = $time.add(new Date(startTime), interval.timeUnit, interval.count, this._df.utc).getTime();\r\n        return startTime + (endTime - startTime) * this.endLocation;\r\n    };\r\n    /**\r\n     * [chooseInterval description]\r\n     *\r\n     * @ignore Exclude from docs.\r\n     * @todo Description\r\n     * @param index      [description]\r\n     * @param duration   [description]\r\n     * @param gridCount  [description]\r\n     * @return [description]\r\n     */\r\n    DateAxis.prototype.chooseInterval = function (index, duration, gridCount, intervals) {\r\n        if (!intervals) {\r\n            intervals = this.gridIntervals;\r\n        }\r\n        var gridInterval = intervals.getIndex(index);\r\n        var intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n        var lastIndex = intervals.length - 1;\r\n        if (index >= lastIndex) {\r\n            return __assign({}, intervals.getIndex(lastIndex));\r\n        }\r\n        var count = Math.ceil(duration / intervalDuration);\r\n        if (duration < intervalDuration && index > 0) {\r\n            return __assign({}, intervals.getIndex(index - 1));\r\n        }\r\n        if (count <= gridCount) {\r\n            return __assign({}, intervals.getIndex(index));\r\n        }\r\n        else {\r\n            if (index + 1 < intervals.length) {\r\n                return this.chooseInterval(index + 1, duration, gridCount, intervals);\r\n            }\r\n            else {\r\n                return __assign({}, intervals.getIndex(index));\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Formats the value according to axis' own [[DateFormatter]].\r\n     *\r\n     * @param value  Source value\r\n     * @return Formatted value\r\n     */\r\n    DateAxis.prototype.formatLabel = function (value) {\r\n        return this._df.format(value);\r\n    };\r\n    /**\r\n     * Converts a Date to an asbolute pixel position within Axis.\r\n     *\r\n     * @param date  Date\r\n     * @return Position (px)\r\n     */\r\n    DateAxis.prototype.dateToPosition = function (date) {\r\n        return this.valueToPosition(date.getTime());\r\n    };\r\n    /**\r\n     * Converts a numeric timestamp or a `Date` to a relative position on axis.\r\n     *\r\n     * @param date  Date or a timestamp\r\n     * @return Relative position\r\n     */\r\n    DateAxis.prototype.anyToPosition = function (date) {\r\n        if (date instanceof Date) {\r\n            return this.dateToPosition(date);\r\n        }\r\n        else {\r\n            return this.valueToPosition(date);\r\n        }\r\n    };\r\n    /**\r\n     * Converts date to orientation point (x, y, angle) on axis\r\n     *\r\n     * @param date Date\r\n     * @return IOrientationPoint\r\n     */\r\n    DateAxis.prototype.dateToPoint = function (date) {\r\n        var position = this.dateToPosition(date);\r\n        var point = this.renderer.positionToPoint(position);\r\n        var angle = this.renderer.positionToAngle(position);\r\n        return { x: point.x, y: point.y, angle: angle };\r\n    };\r\n    /**\r\n     * Converts a numeric value to orientation (x, y, angle) point on axis\r\n     *\r\n     * @param value  Value\r\n     * @return Orientation point\r\n     */\r\n    DateAxis.prototype.anyToPoint = function (date) {\r\n        if (date instanceof Date) {\r\n            return this.dateToPoint(date);\r\n        }\r\n        else {\r\n            return this.valueToPoint(date);\r\n        }\r\n    };\r\n    /**\r\n     * Converts pixel position within Axis to a corresponding Date.\r\n     *\r\n     * @param position  Position (px)\r\n     * @return Date\r\n     */\r\n    DateAxis.prototype.positionToDate = function (position) {\r\n        return new Date(this.positionToValue(position));\r\n    };\r\n    /**\r\n     * Returns the relative position on axis for series' data item's value.\r\n     *\r\n     * @since 4.5.14\r\n     * @param  dataItem  Data item\r\n     * @param  key       Data field to get value from\r\n     * @param  location  Location (0-1)\r\n     * @return           Relative position\r\n     */\r\n    DateAxis.prototype.getPositionX = function (dataItem, key, location, stackKey, range) {\r\n        var value = this.getTimeByLocation(dataItem, key, location);\r\n        //let stack: number = dataItem.getValue(\"valueX\", \"stack\");\r\n        if (!$type.isNumber(value)) {\r\n            value = this.baseValue;\r\n        }\r\n        var position = this.valueToPosition(value);\r\n        if (range) {\r\n            position = $math.fitToRange(position, range.start, range.end);\r\n        }\r\n        return position;\r\n    };\r\n    /**\r\n     * Returns relative position on axis for series' data item's value.\r\n     *\r\n     * @since 4.5.14\r\n     * @param  dataItem  Data item\r\n     * @param  key       Data field to get value from\r\n     * @param  location  Location (0-1)\r\n     * @return           Relative position\r\n     */\r\n    DateAxis.prototype.getPositionY = function (dataItem, key, location, stackKey, range) {\r\n        var value = this.getTimeByLocation(dataItem, key, location);\r\n        var stack = dataItem.getValue(\"valueX\", \"stack\");\r\n        if (!$type.isNumber(value)) {\r\n            value = this.baseValue;\r\n        }\r\n        var position = this.valueToPosition(value + stack);\r\n        if (range) {\r\n            position = $math.fitToRange(position, range.start, range.end);\r\n        }\r\n        return position;\r\n    };\r\n    /**\r\n     * Returns an angle for series data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param dataItem  Data item\r\n     * @param key       Data field to get value from\r\n     * @param location  Location (0-1)\r\n     * @param stackKey  Stack ID\r\n     * @param range Range to fit in\r\n     * @return Angle\r\n     */\r\n    DateAxis.prototype.getAngle = function (dataItem, key, location, stackKey, range) {\r\n        var value = this.getTimeByLocation(dataItem, key, location);\r\n        var stack = dataItem.getValue(stackKey, \"stack\");\r\n        if (!$type.isNumber(value)) {\r\n            value = this.baseValue;\r\n        }\r\n        var position = this.valueToPosition(value + stack);\r\n        if (range) {\r\n            position = $math.fitToRange(position, range.start, range.end);\r\n        }\r\n        return this.positionToAngle(position);\r\n    };\r\n    /**\r\n     * [getTimeByLocation description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param dataItem  [description]\r\n     * @param key       [description]\r\n     * @param location  [description]\r\n     * @return [description]\r\n     */\r\n    DateAxis.prototype.getTimeByLocation = function (dataItem, key, location) {\r\n        if (!$type.hasValue(key)) {\r\n            return;\r\n        }\r\n        if (!$type.isNumber(location)) {\r\n            location = dataItem.workingLocations[key];\r\n            if (!$type.isNumber(location)) {\r\n                location = 0;\r\n            }\r\n        }\r\n        var startTime = dataItem.values[key][\"open\"];\r\n        var endTime = dataItem.values[key][\"close\"];\r\n        var workingValue = dataItem.values[key].workingValue;\r\n        var value = dataItem.values[key].value;\r\n        var difference = value - workingValue;\r\n        startTime -= difference;\r\n        endTime -= difference;\r\n        if ($type.isNumber(startTime) && $type.isNumber(endTime)) {\r\n            return startTime + (endTime - startTime) * location;\r\n        }\r\n    };\r\n    /**\r\n     * Processes a related series' data item.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     * @param dataItem  Data item\r\n     */\r\n    DateAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\r\n        var series = dataItem.component;\r\n        var time;\r\n        var date = dataItem[\"date\" + axisLetter];\r\n        if ($type.isNumber(this.timezoneOffset)) {\r\n            date.setTime(date.getTime() + (date.getTimezoneOffset() - this.timezoneOffset) * 60000);\r\n            dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\r\n        }\r\n        else if ($type.hasValue(this.timezone)) {\r\n            date = $time.setTimezone(date, this.timezone);\r\n            dataItem.setValue(\"date\" + axisLetter, date.getTime(), 0);\r\n            dataItem[\"date\" + axisLetter] = date;\r\n        }\r\n        if (date) {\r\n            time = date.getTime();\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n        var openDate = dataItem[\"openDate\" + axisLetter];\r\n        var prevSeriesTime = this._prevSeriesTime[series.uid];\r\n        var openTime;\r\n        if (openDate) {\r\n            openTime = openDate.getTime();\r\n        }\r\n        if ($type.isNumber(openTime)) {\r\n            var difference = Math.abs(time - openTime);\r\n            if (this._minDifference[series.uid] > difference) {\r\n                this._minDifference[series.uid] = difference;\r\n            }\r\n        }\r\n        var differece = time - prevSeriesTime;\r\n        if (differece > 0) {\r\n            if (this._minDifference[series.uid] > differece) {\r\n                this._minDifference[series.uid] = differece;\r\n            }\r\n        }\r\n        this._prevSeriesTime[series.uid] = time;\r\n        if (series._baseInterval[this.uid]) {\r\n            this.postProcessSeriesDataItem(dataItem);\r\n        }\r\n    };\r\n    /**\r\n     * [updateAxisBySeries description]\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description\r\n     */\r\n    DateAxis.prototype.updateAxisBySeries = function () {\r\n        _super.prototype.updateAxisBySeries.call(this);\r\n        var baseInterval = this.chooseInterval(0, this.minDifference, 1);\r\n        if (this.minDifference >= $time.getDuration(\"day\", 27) && baseInterval.timeUnit == \"week\") {\r\n            baseInterval.timeUnit = \"month\";\r\n            baseInterval.count = 1;\r\n        }\r\n        if (baseInterval.timeUnit == \"month\") {\r\n            if (this.minDifference >= $time.getDuration(\"day\", 29 * 2) && baseInterval.count == 1) {\r\n                baseInterval.count = 2;\r\n            }\r\n            if (this.minDifference >= $time.getDuration(\"day\", 29 * 3) && baseInterval.count == 2) {\r\n                baseInterval.count = 3;\r\n            }\r\n            if (this.minDifference >= $time.getDuration(\"day\", 29 * 6) && baseInterval.count == 5) {\r\n                baseInterval.count = 6;\r\n            }\r\n        }\r\n        // handle daylight saving\r\n        if (this.minDifference >= $time.getDuration(\"hour\", 23) && baseInterval.timeUnit == \"hour\") {\r\n            baseInterval.timeUnit = \"day\";\r\n            baseInterval.count = 1;\r\n        }\r\n        if (this.minDifference >= $time.getDuration(\"week\", 1) - $time.getDuration(\"hour\", 1) && baseInterval.timeUnit == \"day\") {\r\n            baseInterval.timeUnit = \"week\";\r\n            baseInterval.count = 1;\r\n        }\r\n        if (this.minDifference >= $time.getDuration(\"year\", 1) - $time.getDuration(\"day\", 1.01) && baseInterval.timeUnit == \"month\") {\r\n            baseInterval.timeUnit = \"year\";\r\n            baseInterval.count = 1;\r\n        }\r\n        this._baseIntervalReal = baseInterval;\r\n        this._mainBaseInterval = baseInterval;\r\n        // no need to invalidate\r\n    };\r\n    Object.defineProperty(DateAxis.prototype, \"baseInterval\", {\r\n        /**\r\n         * @return Base interval\r\n         */\r\n        get: function () {\r\n            if (this._groupInterval) {\r\n                return this._groupInterval;\r\n            }\r\n            else if (this._baseInterval) {\r\n                return this._baseInterval;\r\n            }\r\n            else {\r\n                return this._baseIntervalReal;\r\n            }\r\n        },\r\n        /**\r\n         * A base interval (granularity) of data.\r\n         *\r\n         * Used to indicate what are the base units of your data.\r\n         *\r\n         * For example, if you have a data set that has a data point every 5 minutes,\r\n         * you may want to set this to `{ timeUnit: \"minute\", count: 5 }`.\r\n         *\r\n         * If not set, the Axis will try to determine the setting by its own, looking\r\n         * at actual data.\r\n         *\r\n         * For best results, try to follow these values for `count`:\r\n         *\r\n         * When unit is \"month\", use 12 / count = round number\r\n         * When unit is \"hour\", use 24 / count = round number\r\n         * When unit is \"second\" and \"minute\", use 60 / count = round number\r\n         *\r\n         * @param timeInterval base interval\r\n         */\r\n        set: function (timeInterval) {\r\n            if (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {\r\n                this._baseInterval = timeInterval;\r\n                this._mainBaseInterval = timeInterval;\r\n                if (!$type.isNumber(timeInterval.count)) {\r\n                    timeInterval.count = 1;\r\n                }\r\n                this.invalidate();\r\n                this.postProcessSeriesDataItems();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"mainBaseInterval\", {\r\n        /**\r\n         * Indicates granularity of the data of source (unaggregated) data.\r\n         *\r\n         * @since 4.7.0\r\n         * @return Granularity of the main data set\r\n         */\r\n        get: function () {\r\n            if (this._baseInterval) {\r\n                return this._baseInterval;\r\n            }\r\n            else if (this._mainBaseInterval) {\r\n                return this._mainBaseInterval;\r\n            }\r\n            else {\r\n                return this._baseIntervalReal;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"skipEmptyPeriods\", {\r\n        /**\r\n         * @return Remove empty stretches of time?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"skipEmptyPeriods\");\r\n        },\r\n        /**\r\n         * If enabled, axis will automatically collapse empty (without data points)\r\n         * periods of time, i.e. weekends.\r\n         *\r\n         * An \"empty\" period is considered a stretch of time in the length of current\r\n         * `baseInterval` without a single data point in it.\r\n         *\r\n         * For each such empty period, axis will automatically create an\r\n         * [[AxisBreak]]. By default they will be invisible. You can still configure\r\n         * them by accessing `axis.breaks.template`.\r\n         *\r\n         * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).\r\n         *\r\n         * Important notes:\r\n         * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.\r\n         * * Using this feature affects performance. Use only if you need it.\r\n         * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.\r\n         * * Some axis label overlapping might happen.\r\n         * * This setting is not compatible with `groupData = true`.\r\n         *\r\n         * @default false\r\n         * @param value  Remove empty stretches of time?\r\n         */\r\n        set: function (value) {\r\n            if (value) {\r\n                var breakTemplate = this.axisBreaks.template;\r\n                breakTemplate.startLine.disabled = true;\r\n                breakTemplate.endLine.disabled = true;\r\n                breakTemplate.fillShape.disabled = true;\r\n                breakTemplate.breakSize = 0;\r\n            }\r\n            else {\r\n                if (this._gapBreaks) {\r\n                    this.axisBreaks.clear();\r\n                    this._gapBreaks = false;\r\n                }\r\n            }\r\n            if (this.setPropertyValue(\"skipEmptyPeriods\", value)) {\r\n                this.invalidate();\r\n                this.postProcessSeriesDataItems();\r\n                this.invalidateSeries();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"tooltipDateFormat\", {\r\n        /**\r\n         * @return Date format\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"tooltipDateFormat\");\r\n        },\r\n        /**\r\n         * A special date format to apply axis tooltips.\r\n         *\r\n         * Will use same format as for labels, if not set.\r\n         *\r\n         * @param value  Date format\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"tooltipDateFormat\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"markUnitChange\", {\r\n        /**\r\n         * @return Use different format for period beginning?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"markUnitChange\");\r\n        },\r\n        /**\r\n         * Use `periodChangeDateFormats` to apply different formats to the first\r\n         * label in bigger time unit.\r\n         *\r\n         * @default true\r\n         * @param value  Use different format for period beginning?\r\n         */\r\n        set: function (value) {\r\n            if (this.setPropertyValue(\"markUnitChange\", value)) {\r\n                this.invalidateData();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns text to show in a tooltip, based on specific relative position\r\n     * within axis.\r\n     *\r\n     * The label will be formatted as per [[DateFormatter]] set for the whole\r\n     * chart, or explicitly for this Axis.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param position  Position\r\n     * @return Label (formatted date)\r\n     */\r\n    DateAxis.prototype.getTooltipText = function (position) {\r\n        var text;\r\n        var date = this.positionToDate(position);\r\n        date = $time.round(date, this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, new Date(this.min), this._df.timezoneMinutes, this._df.timezone);\r\n        this.tooltipDate = date;\r\n        if ($type.hasValue(this.tooltipDateFormat)) {\r\n            text = this._df.format(date, this.tooltipDateFormat, [\"day\", \"month\", \"week\", \"year\"].indexOf(this.baseInterval.timeUnit) == -1);\r\n        }\r\n        else {\r\n            var dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);\r\n            if (dateFormat) {\r\n                text = this._df.format(date, dateFormat);\r\n            }\r\n            else {\r\n                text = this.getPositionLabel(position);\r\n            }\r\n        }\r\n        if (!this._adapterO) {\r\n            return text;\r\n        }\r\n        else {\r\n            return this._adapterO.apply(\"getTooltipText\", text);\r\n        }\r\n    };\r\n    /**\r\n     * Takes an absolute position within axis and adjust it to a specific position within base interval. (cell)\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param position Source position\r\n     * @param location  Location in the cell\r\n     * @return Adjusted position\r\n     */\r\n    DateAxis.prototype.roundPosition = function (position, location, axisLocation) {\r\n        var baseInterval = this.baseInterval;\r\n        var timeUnit = baseInterval.timeUnit;\r\n        var count = baseInterval.count;\r\n        var date = this.positionToDate(position);\r\n        $time.round(date, timeUnit, count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n        if (location > 0) {\r\n            $time.add(date, timeUnit, location * count, this._df.utc);\r\n        }\r\n        if (axisLocation > 0 && axisLocation < 1) {\r\n            date.setTime(date.getTime() + this.baseDuration * axisLocation);\r\n        }\r\n        if (this.isInBreak(date.getTime())) {\r\n            while (date.getTime() < this.max) {\r\n                $time.add(date, timeUnit, count, this._df.utc);\r\n                if (!this.isInBreak(date.getTime())) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return this.dateToPosition(date);\r\n    };\r\n    /**\r\n     * Returns an relative position of the start of the cell (period), that specific position value falls into.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param position  Relative position\r\n     * @return Cell start relative position\r\n     */\r\n    DateAxis.prototype.getCellStartPosition = function (position) {\r\n        return this.roundPosition(position, 0);\r\n    };\r\n    /**\r\n     * Returns an relative position of the end of the cell (period), that specific position value falls into.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @todo Description (review)\r\n     * @param position  Relative position\r\n     * @return Cell end relative position\r\n     */\r\n    DateAxis.prototype.getCellEndPosition = function (position) {\r\n        return this.roundPosition(position, 1);\r\n        //return this.dateToPosition($time.add(this.positionToDate(this.roundPosition(position, 1)), this.baseInterval.timeUnit, this.baseInterval.count));\r\n    };\r\n    /**\r\n     * Returns a Series data item that corresponds to the specific pixel position\r\n     * of the Axis.\r\n     *\r\n     * If `findNearest` (third parameter) is set to `true`, the method will try\r\n     * to locate nearest available data item if none is found directly under\r\n     * `position`.\r\n     *\r\n     * @param series       Series\r\n     * @param position     Position (px)\r\n     * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position\r\n     * @return Data item\r\n     */\r\n    DateAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\r\n        var value = this.positionToValue(position);\r\n        var location = 0.5;\r\n        if (this.axisLetter == \"Y\") {\r\n            location = series.dataItems.template.locations.dateY;\r\n        }\r\n        else {\r\n            location = series.dataItems.template.locations.dateX;\r\n        }\r\n        var deltaValue = value - location * this.baseDuration;\r\n        var date = $time.round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n        var nextDate = $time.round(new Date(value + this.baseDuration), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n        if (nextDate.getTime() > date.getTime()) {\r\n            if (Math.abs(nextDate.getTime() - deltaValue) < Math.abs(deltaValue - date.getTime())) {\r\n                date = nextDate;\r\n            }\r\n        }\r\n        var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\r\n        var dataItem = dataItemsByAxis.getKey(date.getTime() + series.currentDataSetId);\r\n        // todo:  alternatively we can find closiest here\r\n        if (!dataItem && findNearest) {\r\n            var key_1;\r\n            if (this.axisLetter == \"Y\") {\r\n                key_1 = \"dateY\";\r\n            }\r\n            else {\r\n                key_1 = \"dateX\";\r\n            }\r\n            dataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), function (x) {\r\n                if (x[key_1]) {\r\n                    return x[key_1].getTime();\r\n                }\r\n                else {\r\n                    return -Infinity;\r\n                }\r\n            }, \"any\"));\r\n        }\r\n        return dataItem;\r\n    };\r\n    /**\r\n     * Returns a formatted date based on position in axis scale.\r\n     *\r\n     * Please note that `position` represents position within axis which may be\r\n     * zoomed and not correspond to Cursor's `position`.\r\n     *\r\n     * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n     * @param position  Relative position on axis (0-1)\r\n     * @return Position label\r\n     */\r\n    DateAxis.prototype.getPositionLabel = function (position) {\r\n        // @todo Better format recognition\r\n        var date = this.positionToDate(position);\r\n        return this._df.format(date, this.getCurrentLabelFormat());\r\n    };\r\n    /**\r\n     * Returns label date format based on currently used time units\r\n     *\r\n     * @return Format\r\n     */\r\n    DateAxis.prototype.getCurrentLabelFormat = function () {\r\n        return this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : \"day\");\r\n    };\r\n    /**\r\n     * Initializes an Axis renderer.\r\n     *\r\n     * @ignore Exclude from docs\r\n     */\r\n    DateAxis.prototype.initRenderer = function () {\r\n        _super.prototype.initRenderer.call(this);\r\n        var renderer = this.renderer;\r\n        if (renderer) {\r\n            // Set defaults\r\n            renderer.ticks.template.location = 0;\r\n            renderer.grid.template.location = 0;\r\n            renderer.labels.template.location = 0;\r\n            renderer.baseGrid.disabled = true;\r\n        }\r\n    };\r\n    Object.defineProperty(DateAxis.prototype, \"basePoint\", {\r\n        /**\r\n         * Coordinates of the actual axis start.\r\n         *\r\n         * @ignore Exclude from docs\r\n         * @return Base point\r\n         */\r\n        get: function () {\r\n            return { x: 0, y: 0 };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.animateMinMax = function (min, max) {\r\n        var _this = this;\r\n        var animation = this.animate([{ property: \"_minAdjusted\", from: this._minAdjusted, to: min }, { property: \"_maxAdjusted\", from: this._maxAdjusted, to: max }], this.rangeChangeDuration, this.rangeChangeEasing);\r\n        animation.events.on(\"animationprogress\", function () {\r\n            _this.dispatch(\"extremeschanged\");\r\n        });\r\n        return animation;\r\n    };\r\n    /**\r\n     * Invalidates axis data items when series extremes change\r\n     */\r\n    DateAxis.prototype.handleExtremesChange = function () {\r\n        _super.prototype.handleExtremesChange.call(this);\r\n        if (this.groupData) {\r\n            var id = this.baseInterval.timeUnit + this.baseInterval.count;\r\n            this.groupMin[id] = this._finalMin;\r\n            this.groupMax[id] = this._finalMax;\r\n        }\r\n    };\r\n    /**\r\n     * Zooms axis to specific Dates.\r\n     *\r\n     * @param startDate       Start date\r\n     * @param endValue        End date\r\n     * @param skipRangeEvent  Do not invoke events\r\n     * @param instantly       Do not play zoom animations\r\n     */\r\n    DateAxis.prototype.zoomToDates = function (startDate, endDate, skipRangeEvent, instantly, adjust) {\r\n        startDate = this._df.parse(startDate);\r\n        endDate = this._df.parse(endDate);\r\n        this.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly, adjust);\r\n    };\r\n    /**\r\n     * Zooms axis to specific values.\r\n     *\r\n     * @param startValue      Start value\r\n     * @param endValue        End value\r\n     * @param skipRangeEvent  Do not invoke events\r\n     * @param instantly       Do not play zoom animations\r\n     */\r\n    DateAxis.prototype.zoomToValues = function (startValue, endValue, skipRangeEvent, instantly, adjust) {\r\n        var _this = this;\r\n        if (!this.groupData) {\r\n            //let start: number = (startValue - this.min) / (this.max - this.min);\r\n            //let end: number = (endValue - this.min) / (this.max - this.min);\r\n            var start = this.valueToPosition(startValue);\r\n            var end = this.valueToPosition(endValue);\r\n            this.zoom({ start: start, end: end }, skipRangeEvent, instantly);\r\n        }\r\n        else {\r\n            var difference = this.adjustDifference(startValue, endValue);\r\n            var isEnd = false;\r\n            if (endValue == this.max) {\r\n                isEnd = true;\r\n            }\r\n            var isStart = false;\r\n            if (startValue == this.min) {\r\n                isStart = true;\r\n            }\r\n            if ($type.hasValue(difference)) {\r\n                var mainBaseInterval = this.mainBaseInterval;\r\n                var groupInterval_1 = this.chooseInterval(0, difference, this.groupCount, this.groupIntervals);\r\n                if ((groupInterval_1.timeUnit == mainBaseInterval.timeUnit && groupInterval_1.count < mainBaseInterval.count) || $time.getDuration(groupInterval_1.timeUnit, 1) < $time.getDuration(mainBaseInterval.timeUnit, 1)) {\r\n                    groupInterval_1 = __assign({}, mainBaseInterval);\r\n                }\r\n                var id = groupInterval_1.timeUnit + groupInterval_1.count;\r\n                var min_1 = this.groupMin[id];\r\n                var max_1 = this.groupMax[id];\r\n                if (!$type.isNumber(min_1) || !$type.isNumber(max_1)) {\r\n                    min_1 = Number.POSITIVE_INFINITY;\r\n                    max_1 = Number.NEGATIVE_INFINITY;\r\n                    this.series.each(function (series) {\r\n                        var seriesMin = series.min(_this);\r\n                        var seriesMax = series.max(_this);\r\n                        if (series._dataSets) {\r\n                            var ds = series._dataSets.getKey(groupInterval_1.timeUnit + groupInterval_1.count);\r\n                            if (ds) {\r\n                                var mindi = ds.getIndex(0);\r\n                                var maxdi = ds.getIndex(ds.length - 1);\r\n                                if (mindi) {\r\n                                    if (series.xAxis == _this) {\r\n                                        seriesMin = mindi.dateX.getTime();\r\n                                    }\r\n                                    else if (series.yAxis == _this) {\r\n                                        seriesMin = mindi.dateY.getTime();\r\n                                    }\r\n                                }\r\n                                if (maxdi) {\r\n                                    if (series.xAxis == _this) {\r\n                                        seriesMax = maxdi.dateX.getTime();\r\n                                    }\r\n                                    else if (series.yAxis == _this) {\r\n                                        seriesMax = maxdi.dateY.getTime();\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        seriesMax = $time.round($time.add(new Date(seriesMax), groupInterval_1.timeUnit, 1, _this._df.utc), groupInterval_1.timeUnit, 1, _this._df.firstDayOfWeek, _this._df.utc, undefined, _this._df.timezoneMinutes, _this._df.timezone).getTime();\r\n                        if (seriesMin < min_1) {\r\n                            min_1 = seriesMin;\r\n                        }\r\n                        if (seriesMax > max_1) {\r\n                            max_1 = seriesMax;\r\n                        }\r\n                    });\r\n                    this.groupMin[id] = min_1;\r\n                    this.groupMax[id] = max_1;\r\n                }\r\n                startValue = $math.fitToRange(startValue, min_1, max_1);\r\n                endValue = $math.fitToRange(endValue, min_1, max_1);\r\n                if (adjust) {\r\n                    if (isEnd) {\r\n                        startValue = endValue - difference;\r\n                        startValue = $math.fitToRange(startValue, min_1, max_1);\r\n                    }\r\n                    if (isStart) {\r\n                        endValue = startValue + difference;\r\n                        endValue = $math.fitToRange(endValue, min_1, max_1);\r\n                    }\r\n                }\r\n                var start = (startValue - min_1) / (max_1 - min_1);\r\n                var end = (endValue - min_1) / (max_1 - min_1);\r\n                this.zoom({ start: start, end: end }, skipRangeEvent, instantly);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Adds `baseInterval` to \"as is\" fields.\r\n     *\r\n     * @param field  Field name\r\n     * @return Assign as is?\r\n     */\r\n    DateAxis.prototype.asIs = function (field) {\r\n        return field == \"baseInterval\" || _super.prototype.asIs.call(this, field);\r\n    };\r\n    /**\r\n     * Copies all properties and related data from a different instance of Axis.\r\n     *\r\n     * @param source Source Axis\r\n     */\r\n    DateAxis.prototype.copyFrom = function (source) {\r\n        var _this = this;\r\n        _super.prototype.copyFrom.call(this, source);\r\n        this.dateFormats = source.dateFormats;\r\n        this.periodChangeDateFormats = source.periodChangeDateFormats;\r\n        this.groupIntervals.clear();\r\n        source.groupIntervals.each(function (interval) {\r\n            _this.groupIntervals.push(__assign({}, interval));\r\n        });\r\n        this.gridIntervals.clear();\r\n        source.gridIntervals.each(function (interval) {\r\n            _this.gridIntervals.push(__assign({}, interval));\r\n        });\r\n        if (source._baseInterval) {\r\n            this.baseInterval = source._baseInterval;\r\n        }\r\n    };\r\n    /**\r\n     * Shows Axis tooltip at specific relative position within Axis. (0-1)\r\n     *\r\n     * @param position Position (0-1)\r\n     * @param local or global position\r\n     */\r\n    DateAxis.prototype.showTooltipAtPosition = function (position, local) {\r\n        var _this = this;\r\n        if (!local) {\r\n            position = this.toAxisPosition(position);\r\n        }\r\n        if (this.snapTooltip) {\r\n            // rounding is not good, pen/aac4e7f66f019d36b2447f050c600c13 (no last tootltip shown)\r\n            var actualDate = this.positionToDate(position); //$time.round(this.positionToDate(position), this.baseInterval.timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n            var actualTime_1 = actualDate.getTime();\r\n            var closestDate_1;\r\n            this.series.each(function (series) {\r\n                if (series.baseAxis == _this) {\r\n                    var dataItem = _this.getSeriesDataItem(series, position, true);\r\n                    if (dataItem) {\r\n                        var date = void 0;\r\n                        if (series.xAxis == _this) {\r\n                            date = dataItem.dateX;\r\n                        }\r\n                        if (series.yAxis == _this) {\r\n                            date = dataItem.dateY;\r\n                        }\r\n                        if (!closestDate_1) {\r\n                            closestDate_1 = date;\r\n                        }\r\n                        else {\r\n                            if (Math.abs(closestDate_1.getTime() - actualTime_1) > Math.abs(date.getTime() - actualTime_1)) {\r\n                                closestDate_1 = date;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            if (closestDate_1) {\r\n                var closestTime_1 = closestDate_1.getTime();\r\n                closestDate_1 = $time.round(new Date(closestTime_1), this.baseInterval.timeUnit, this.baseInterval.count, this._firstWeekDay, this._df.utc, undefined, this._df.timezoneMinutes, this._df.timezone);\r\n                closestTime_1 = closestDate_1.getTime();\r\n                var tooltipLocation = this.renderer.tooltipLocation;\r\n                if (tooltipLocation == 0) {\r\n                    tooltipLocation = 0.0001;\r\n                }\r\n                closestDate_1 = new Date(closestDate_1.getTime() + this.baseDuration * tooltipLocation);\r\n                position = this.dateToPosition(closestDate_1);\r\n                if (this.chart.cursor && this.chart.cursor.snapToSeries) {\r\n                    //void\r\n                }\r\n                else {\r\n                    this.series.each(function (series) {\r\n                        var dataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(closestTime_1 + series.currentDataSetId);\r\n                        var point = series.showTooltipAtDataItem(dataItem);\r\n                        if (point) {\r\n                            _this.chart._seriesPoints.push({ series: series, point: point });\r\n                        }\r\n                        else {\r\n                            // check, otherwise column tooltip will be hidden\r\n                            if (series.tooltipText || series.tooltipHTML) {\r\n                                series.hideTooltip();\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                //this.chart.sortSeriesTooltips(seriesPoints);\r\n            }\r\n        }\r\n        _super.prototype.showTooltipAtPosition.call(this, position, true);\r\n    };\r\n    Object.defineProperty(DateAxis.prototype, \"snapTooltip\", {\r\n        /**\r\n         * @return Should snap?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"snapTooltip\");\r\n        },\r\n        /**\r\n         * Should the nearest tooltip be shown if no data item is found on the\r\n         * current cursor position.\r\n         *\r\n         * @default true\r\n         * @param value  Should snap?\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"snapTooltip\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"groupData\", {\r\n        /**\r\n         * @return Group data points?\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"groupData\");\r\n        },\r\n        /**\r\n         * Indicates if data should be aggregated to composide data items if there\r\n         * are more data items in selected range than `groupCount`.\r\n         *\r\n         * Grouping will occur automatically, based on current selection range, and\r\n         * will change dynamically when user zooms in/out the chart.\r\n         *\r\n         * NOTE: This works only if [[DateAxis]] is base axis of an [[XYSeries]].\r\n         *\r\n         * The related [[XYSeries]] also needs to be set up to take advantage of, by\r\n         * setting its [`groupFields`](https://www.amcharts.com/docs/v4/reference/xyseries/#groupFields_property).\r\n         *\r\n         * The group intervals to aggregate data to is defined by `groupIntervals`\r\n         * property.\r\n         *\r\n         * ```TypeScript\r\n         * let dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n         * dateAxis.groupData = true;\r\n         *\r\n         * let valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n         *\r\n         * let series = chart.series.push(new am4charts.LineSeries());\r\n         * series.dataFields.dateX = \"date\";\r\n         * series.dataFields.valueY = \"value\";\r\n         * series.groupFields.valueY = \"average\";\r\n         * ```\r\n         * ```JavaScript\r\n         * var dateAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n         * dateAxis.groupData = true;\r\n         *\r\n         * var valueAxis = chart.xAxes.push(new am4charts.valueAxis());\r\n         *\r\n         * var series = chart.series.push(new am4charts.LineSeries());\r\n         * series.dataFields.dateX = \"date\";\r\n         * series.dataFields.valueY = \"value\";\r\n         * series.groupFields.valueY = \"average\";\r\n         * ```\r\n         * ```JSON\r\n         * {\r\n         *   // ...\r\n         *   \"xAxes\": [{\r\n         *     \"type\": \"DateAxis\",\r\n         *     \"groupData\": true\r\n         *   }],\r\n         *   \"yAxes\": [{\r\n         *     \"type\": \"ValueAxis\"\r\n         *   }],\r\n         *   \"series\": [{\r\n         *     \"type\": \"LineSeries\",\r\n         *     \"dataFields\": {\r\n         *       \"dateX\": \"date\",\r\n         *       \"valueY\": \"value\"\r\n         *     },\r\n         *     \"groupFields\": {\r\n         *       \"valueY\": \"average\"\r\n         *     }\r\n         *   }]\r\n         * }\r\n         * ```\r\n         *\r\n         * @default false\r\n         * @see {@link https://www.amcharts.com/docs/v4/concepts/axes/date-axis/#Dynamic_data_item_grouping} for more information about dynamic data item grouping.\r\n         * @since 4.7.0\r\n         * @param  value  Group data points?\r\n         */\r\n        set: function (value) {\r\n            var _this = this;\r\n            if (this.setPropertyValue(\"groupData\", value)) {\r\n                this.series.each(function (series) {\r\n                    series.setDataSet(\"\");\r\n                    if (value && !series.dataGrouped && series.inited) {\r\n                        series._baseInterval[_this.uid] = _this.mainBaseInterval;\r\n                        _this.groupSeriesData(series);\r\n                    }\r\n                });\r\n                this._currentDataSetId = \"\";\r\n                this._groupInterval = undefined;\r\n                this.invalidate();\r\n                this.invalidateSeries();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"groupInterval\", {\r\n        /**\r\n         * @return Interval\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"groupInterval\");\r\n        },\r\n        /**\r\n         * Disables automatic selection of data grouping intervals and always uses\r\n         * `groupInterval` if set. Works only if `groupData = true`.\r\n         *\r\n         * @since 4.9.24\r\n         * @param  value  Interval\r\n         */\r\n        set: function (value) {\r\n            if (this.setPropertyValue(\"groupInterval\", value)) {\r\n                this.invalidate();\r\n                this.invalidateSeries();\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"groupCount\", {\r\n        /**\r\n         * @return Number of data items\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"groupCount\");\r\n        },\r\n        /**\r\n         * Indicates threshold of data items in selected range at which to start\r\n         * aggregating data items if `groupData = true`.\r\n         *\r\n         * @default 200\r\n         * @since 4.7.0\r\n         * @param  value  Number of data items\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"groupCount\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"timezoneOffset\", {\r\n        /**\r\n         * @todo Timezone offset in minutes\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"timezoneOffset\");\r\n        },\r\n        /**\r\n         * If set will recalculate all timestamps in data by applying specific offset\r\n         * in minutes.\r\n         *\r\n         * IMPORTANT: do not set `timezoneOffset` on both `DateAxis` and `dateFormatter`. It\r\n         * will skew your results by applying offset twice.\r\n         *\r\n         * @since 4.8.5\r\n         * @param  value Time zone offset in minutes\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"timezoneOffset\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"timezone\", {\r\n        /**\r\n         * @return Timezone\r\n         */\r\n        get: function () {\r\n            return this.getPropertyValue(\"timezone\");\r\n        },\r\n        /**\r\n         * If set will recalculate all timestamps in data to specific named timezone,\r\n         * e.g. `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`, etc.\r\n         *\r\n         * IMPORTANT: it is no longer recommended to use this setting. Please\r\n         * set`timezone` on `dateFormatter`.\r\n         *\r\n         * @deprecated\r\n         * @since 4.10.1\r\n         * @param  value Time zone\r\n         */\r\n        set: function (value) {\r\n            this.setPropertyValue(\"timezone\", value);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DateAxis.prototype, \"gridInterval\", {\r\n        /**\r\n         * Current grid interval.\r\n         *\r\n         * @return Grid interval\r\n         */\r\n        get: function () {\r\n            return this._gridInterval;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * @ignore\r\n     */\r\n    DateAxis.prototype.makeGap = function (dataItem, previous) {\r\n        var series = dataItem.component;\r\n        if (dataItem && previous) {\r\n            if (!series.connect && $type.isNumber(series.autoGapCount)) {\r\n                if (series.baseAxis == this) {\r\n                    var date = dataItem.dates[\"date\" + this.axisLetter];\r\n                    var prevDate = previous.dates[\"date\" + this.axisLetter];\r\n                    if (date && prevDate) {\r\n                        var time = date.getTime();\r\n                        var prevTime = prevDate.getTime();\r\n                        if (time - prevTime > series.autoGapCount * this.baseDuration) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    Object.defineProperty(DateAxis.prototype, \"baseValue\", {\r\n        /**\r\n         * @return base value\r\n         */\r\n        get: function () {\r\n            return this.min;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    DateAxis.prototype._saveMinMax = function (min, max) {\r\n        var groupInterval = this.groupInterval;\r\n        if (!groupInterval) {\r\n            groupInterval = this.mainBaseInterval;\r\n        }\r\n        var id = groupInterval.timeUnit + groupInterval.count;\r\n        this._intervalMin[id] = min;\r\n        this._intervalMax[id] = max;\r\n    };\r\n    return DateAxis;\r\n}(ValueAxis));\r\nexport { DateAxis };\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"DateAxis\"] = DateAxis;\r\nregistry.registeredClasses[\"DateAxisDataItem\"] = DateAxisDataItem;\r\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAAS,EAAEC,iBAAiB,QAAQ,aAAa;AAC1D,SAASC,IAAI,QAAQ,uBAAuB;AAC5C,SAASC,UAAU,QAAQ,6BAA6B;AACxD,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,OAAO,KAAKC,KAAK,MAAM,uBAAuB;AAC9C,OAAO,KAAKC,KAAK,MAAM,uBAAuB;AAC9C,OAAO,KAAKC,KAAK,MAAM,2BAA2B;AAClD,OAAO,KAAKC,KAAK,MAAM,uBAAuB;AAC9C,OAAO,KAAKC,MAAM,MAAM,wBAAwB;AAChD,OAAO,KAAKC,OAAO,MAAM,yBAAyB;AAClD,OAAO,KAAKC,MAAM,MAAM,wBAAwB;AAChD,SAASC,mBAAmB,QAAQ,6BAA6B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,gBAAgB,GAAG,aAAe,UAAUC,MAAM,EAAE;EACpDhB,SAAS,CAACe,gBAAgB,EAAEC,MAAM,CAAC;EACnC;AACJ;AACA;EACI,SAASD,gBAAgBA,CAAA,EAAG;IACxB,IAAIE,KAAK,GAAGD,MAAM,CAACE,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI;IACrCD,KAAK,CAACE,SAAS,GAAG,kBAAkB;IACpCF,KAAK,CAACG,UAAU,CAAC,CAAC;IAClBH,KAAK,CAACI,MAAM,CAACC,IAAI,GAAG,CAAC,CAAC;IACtBL,KAAK,CAACI,MAAM,CAACE,OAAO,GAAG,CAAC,CAAC;IACzB,OAAON,KAAK;EAChB;EACAO,MAAM,CAACC,cAAc,CAACV,gBAAgB,CAACW,SAAS,EAAE,MAAM,EAAE;IACtD;AACR;AACA;IACQC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACC,KAAK,CAAC,MAAM,CAAC;IAC7B,CAAC;IACD;AACR;AACA;AACA;AACA;IACQC,GAAG,EAAE,SAAAA,CAAUP,IAAI,EAAE;MACjB,IAAI,CAACQ,OAAO,CAAC,MAAM,EAAER,IAAI,CAAC;MAC1B,IAAI,CAACS,KAAK,GAAGT,IAAI,CAACU,OAAO,CAAC,CAAC;IAC/B,CAAC;IACDC,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFV,MAAM,CAACC,cAAc,CAACV,gBAAgB,CAACW,SAAS,EAAE,SAAS,EAAE;IACzD;AACR;AACA;IACQC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,OAAO,IAAI,CAACC,KAAK,CAAC,SAAS,CAAC;IAChC,CAAC;IACD;AACR;AACA;AACA;AACA;IACQC,GAAG,EAAE,SAAAA,CAAUP,IAAI,EAAE;MACjB,IAAI,CAACQ,OAAO,CAAC,SAAS,EAAER,IAAI,CAAC;MAC7B,IAAI,CAACa,QAAQ,GAAGb,IAAI,CAACU,OAAO,CAAC,CAAC;IAClC,CAAC;IACDC,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACF,OAAOnB,gBAAgB;AAC3B,CAAC,CAACb,iBAAiB,CAAE;AACrB,SAASa,gBAAgB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIqB,QAAQ,GAAG,aAAe,UAAUpB,MAAM,EAAE;EAC5ChB,SAAS,CAACoC,QAAQ,EAAEpB,MAAM,CAAC;EAC3B;AACJ;AACA;EACI,SAASoB,QAAQA,CAAA,EAAG;IAChB,IAAInB,KAAK;IACT;IACAD,MAAM,CAACE,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI;IACzBD,KAAK,CAACoB,UAAU,GAAG,KAAK;IACxB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQpB,KAAK,CAACqB,aAAa,GAAG,IAAInC,IAAI,CAAC,CAAC;IAChC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQc,KAAK,CAACsB,cAAc,GAAG,IAAIpC,IAAI,CAAC,CAAC;IACjC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQc,KAAK,CAACuB,WAAW,GAAG,IAAIpC,UAAU,CAAC,CAAC;IACpC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQa,KAAK,CAACwB,uBAAuB,GAAG,IAAIrC,UAAU,CAAC,CAAC;IAChD;AACR;AACA;IACQa,KAAK,CAACyB,iBAAiB,GAAG;MAAEC,QAAQ,EAAE,KAAK;MAAEC,KAAK,EAAE;IAAE,CAAC;IACvD;AACR;IACQ3B,KAAK,CAAC4B,eAAe,GAAG,CAAC,CAAC;IAC1B;AACR;AACA;AACA;AACA;IACQ5B,KAAK,CAAC6B,cAAc,GAAG,CAAC,CAAC;IACzB;AACR;AACA;IACQ7B,KAAK,CAAC8B,aAAa,GAAG,CAAC;IACvB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ9B,KAAK,CAAC+B,QAAQ,GAAG,CAAC,CAAC;IACnB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ/B,KAAK,CAACgC,QAAQ,GAAG,CAAC,CAAC;IACnBhC,KAAK,CAACiC,YAAY,GAAG,CAAC,CAAC;IACvBjC,KAAK,CAACkC,YAAY,GAAG,CAAC,CAAC;IACvBlC,KAAK,CAACE,SAAS,GAAG,UAAU;IAC5BF,KAAK,CAA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}